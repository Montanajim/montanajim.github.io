# Generics

Java generics allow you to write classes and methods that can operate on objects of various types while providing stronger type checks at compile-time. Essentially, generics let you parameterize types, making your code safer and more reusable. Here’s a breakdown of how they work and why they are useful:

------

## 1. The Problem Before Generics

Before Java 5 (when generics were introduced), collections like `List` or `Set` held references of type `Object`. If you wanted to store `String` objects in a `List`, you could declare:

```java
List myList = new ArrayList();
myList.add("Hello");
myList.add("World");
```

However, because the list elements were stored as `Object`, retrieving an element required a cast:

```java
String greeting = (String) myList.get(0);
```

If someone mistakenly added a different type (like an `Integer`), you wouldn’t discover the error until runtime (when a `ClassCastException` might be thrown).

------

## 2. How Generics Solve It

Generics let you declare the type of elements in a collection. For example:

```java
List<String> myList = new ArrayList<>();
myList.add("Hello");
myList.add("World");
// myList.add(123); // Compile-time error
```

Now the compiler enforces that you only store `String` objects in `myList`. When you retrieve an element, it’s automatically known to be a `String`, so no cast is needed:

```java
String greeting = myList.get(0);
```

### Benefits of Generics

1. **Type safety**: Errors that might otherwise appear at runtime become compile-time errors.
2. **Elimination of casts**: You no longer need to cast every time you retrieve an element from a collection.
3. **Improved readability**: Code is clearer since the type of elements is explicitly declared.

------

## 3. Generic Classes

You can create your own generic classes by parameterizing the type. For example:

```java
public class Box<T> {
    private T content;

    public void setContent(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }
}
```

- `T` is a type parameter, which represents the type of the object stored in the box.
- When you create an instance, you specify a concrete type:

```java
Box<String> stringBox = new Box<>();
stringBox.setContent("Hello");
String str = stringBox.getContent(); // str is automatically a String
```

------

## 4. Generic Methods

A method can also be generic. Here’s an example:

```java
public static <U> void printArray(U[] array) {
    for (U element : array) {
        System.out.println(element);
    }
}
```

- `<U>` is a type parameter declared before the return type (`void`).
- In a call like `printArray(new Integer[]{1, 2, 3})`, `U` is inferred as `Integer`.

------

## 5. Bounded Type Parameters

Sometimes you need your generic to be restricted to types that extend a certain class or implement an interface:

```java
public static <T extends Number> double sumList(List<T> list) {
    double total = 0;
    for (T num : list) {
        total += num.doubleValue();
    }
    return total;
}
```

- `T extends Number` means `T` can be any class that extends `Number` (like `Integer`, `Double`, etc.).

------

## 6. Wildcards

Java provides **wildcards** to handle flexible subtyping situations, especially with collections.

- **Unbounded wildcard**: `List<?>` means a list of “something,” but we’re not sure what.
- **Upper-bounded wildcard**: `List<? extends Number>` means a list of some type that extends `Number`. This allows reading as a `Number` but restricts writing because the compiler can’t determine the specific subtype.
- **Lower-bounded wildcard**: `List<? super Number>` means a list of some type that is a supertype of `Number`. This is less commonly used but allows writing `Number` elements.

Example of an upper-bounded wildcard:

```java
public static double sumList(List<? extends Number> list) {
    double total = 0;
    for (Number num : list) {
        total += num.doubleValue();
    }
    return total;
}
```

------

## 7. Type Erasure

Under the hood, generics in Java use **type erasure**. During compilation, the generic type information is erased and replaced with the nearest bound (e.g., `Object` or the upper bound if specified). This is why you can’t do operations that rely on runtime type checks for generics (like creating generic arrays). It also explains why generics in Java are different from templates in C++—the compiler does not generate specialized classes at runtime for each parameterized type.

------

## 8. Tips and Best Practices

1. Use the diamond operator (`<>`)

    introduced in Java 7 for cleaner code:

   ```java
   List<String> list = new ArrayList<>();
   ```

2. **Avoid raw types** (i.e., `List` instead of `List<T>`) because you lose the benefits of type safety.

3. **Use bounded wildcards** when you need flexibility in reading or writing to a generic collection.

4. **Prefer List<? extends T> or List<? super T>** to raw types when you must remain flexible about the element type.

------



In Java generics, **type parameters** are placeholders for actual types that you provide when instantiating a generic class or calling a generic method. For example, in a generic class `Box<T>`, `T` is a type parameter that will be replaced by a concrete type (like `String` or `Integer`) when you create an instance of `Box`.

### Naming the Type Parameters

You can use any valid identifier for your type parameters, not just `T` or `U`. The single-letter names you often see (like `T`, `U`, `V`, `K`, `E`) are simply **conventions**, intended to make the code more readable. For example:

**T** – Stands for “Type”

**U** – Often used as a second type parameter (e.g., when you need two types, like a mapping function from `T` to `U`)

**K, V** – Often used in maps (Key, Value)

**E** – Often used for “Element” in a collection

**R -** Return type

So, while `T` and `U` are common choices, you’re free to use descriptive names (e.g., `TypeOfDevice`, `EmployeeType`) if that makes your code clearer.



## Summary

Java generics provide compile-time type checking and eliminate many unchecked casts. They make collections and class designs more robust and expressive, ensuring that you catch type-related errors earlier in the development cycle. By parameterizing types in classes and methods, you can write code that’s more concise, safer, and easier to maintain.