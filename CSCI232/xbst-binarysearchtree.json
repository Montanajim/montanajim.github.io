{"version":3,"kind":"Article","sha256":"00f9b1a5d73e344936f2b41cc014f7e8afbd47624e07479c836012e4d245b2af","slug":"xbst-binarysearchtree","location":"/xBST_BinarySearchTree.md","dependencies":[],"frontmatter":{"title":"Binary Search Tree","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xBST_BinarySearchTree.md","url":"/CSCI232/build/xBST_BinarySearchTre-1472daeeaaa2e611b2db354c7a79ef40.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Background Information","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"p6hSoFTjls"}],"identifier":"background-information","label":"Background Information","html_id":"background-information","implicit":true,"key":"ly74nkbHqP"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"A binary search tree (BST) is a special type of binary tree data structure used to efficiently store and access sorted data. It’s like a regular tree, but with additional rules that keep everything neatly organized:","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"sqyAUX394Z"}],"key":"DhMKblOSP9"},{"type":"paragraph","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Key features:","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"vjVNWSXE9A"}],"key":"TKnoXzOf0g"}],"key":"cWrZk3oOJI"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":11,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Ordering:","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"K7OLHM8ixf"}],"key":"VKURYBi949"},{"type":"text","value":" Each node in the tree has a value (key), and the key of a node is ","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"hXq6k69iIb"},{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"always greater than","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"HoIqOz9MX1"}],"key":"HtSHWACtFA"},{"type":"text","value":" all the keys in its ","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"Zt0F3hEhp8"},{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"left subtree","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"Nl20U5GJNl"}],"key":"RFoQv7vTgX"},{"type":"text","value":" and ","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"kBCsfCdLOn"},{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"less than","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"eHY7qz3SZ5"}],"key":"B1vg3Y6NKS"},{"type":"text","value":" all the keys in its ","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"W9LxQkLkBa"},{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"right subtree","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"XU3OP1nQvE"}],"key":"nf6AXYhMKs"},{"type":"text","value":". This creates a sorted order throughout the tree.","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"COdDWx4gXB"}],"key":"cS2QxWZLES"},{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"strong","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Efficient searching:","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"xYVrT22LiS"}],"key":"zDalLHZWDI"},{"type":"text","value":" Because of this ordering, you can very quickly search for specific values in the tree. Imagine searching a phone book - you wouldn’t start at the very beginning or end, but somewhere in the middle based on the last name. Similarly, in a BST, you can efficiently move left or right depending on the value you’re searching for, narrowing down the possibilities with each comparison.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"Uj2zDH39Kq"}],"key":"Xv5aPXgN4g"},{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"strong","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"Dynamic insertions and deletions:","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"VaIyDflVDv"}],"key":"vXDKRhPHuO"},{"type":"text","value":" You can easily add new values (insert) or remove existing ones (delete) from the tree while maintaining the sorted order. The process involves comparing the new value with existing nodes and finding its appropriate place based on the ordering rule.","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"nRJSw8rKyo"}],"key":"qiYui3PoxS"},{"type":"listItem","spread":true,"position":{"start":{"line":14,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"strong","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"No Duplicates","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"ulcidUXztw"}],"key":"ty8hnAcSnX"},{"type":"text","value":": Typically, BSTs do ","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"MDYsMvUL8W"},{"type":"strong","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"not","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"ogGnLLzD53"}],"key":"tvEPyNwi5B"},{"type":"text","value":" allow duplicate values, although variations exist that permit duplicates with specific rules (e.g., storing duplicates in the left or right subtree).","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"zD4QQkLINm"}],"key":"aNG333R6o2"}],"key":"CmexAZrnBL"},{"type":"paragraph","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Benefits of using BSTs:","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"fqRr1qUdLP"}],"key":"CVFnDaNDBW"}],"key":"o5B36abRYo"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":20,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"strong","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"Fast search:","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"vzGh1hWfgt"}],"key":"wZ6j37JvXA"},{"type":"text","value":" Searching for elements in a balanced BST takes ","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"DYtn49uIDt"},{"type":"strong","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"logarithmic time","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"SzuaWd8FUJ"}],"key":"n4PlSJgKis"},{"type":"text","value":" on average, which is significantly faster than searching an unsorted list.","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"QfKUwSiN3a"}],"key":"IaicHDOGnV"},{"type":"listItem","spread":true,"position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"strong","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"Ordered access:","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"VwPT5x1X86"}],"key":"q1RCKeJKrl"},{"type":"text","value":" You can easily traverse the tree in sorted order (e.g., for printing all elements in ascending order).","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"SSzPAcint5"}],"key":"EhKviOZbR0"},{"type":"listItem","spread":true,"position":{"start":{"line":22,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"strong","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"children":[{"type":"text","value":"Efficient insertions and deletions:","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"key":"IWJC7PmdNW"}],"key":"dPir3zfFNf"},{"type":"text","value":" These operations can also be done in logarithmic time in balanced BSTs.","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"key":"jScp3YRNut"}],"key":"kzNZruK35D"}],"key":"qXkztyfuNl"},{"type":"paragraph","position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"strong","position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"text","value":"However, BSTs also have some drawbacks:","position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"key":"T70Kmb7Ev8"}],"key":"bCYgOnQ6Ua"}],"key":"ZtD4MHoNRh"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":28,"column":1},"end":{"line":32,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"strong","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"text","value":"Performance depends on balance:","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"yV3OMZE6xv"}],"key":"lRYExLpzNv"},{"type":"text","value":" The efficiency of BST operations relies heavily on the tree’s balance. An unbalanced tree can perform much worse than a balanced one.","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"Bf1AgMylZL"}],"key":"V2LXRjnlYp"},{"type":"listItem","spread":true,"position":{"start":{"line":29,"column":1},"end":{"line":32,"column":1}},"children":[{"type":"strong","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"Not self-balancing:","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"qnKmY3pAR1"}],"key":"RvqPqAlEJe"},{"type":"text","value":" By default, BSTs are not self-balancing, meaning insertions and deletions can sometimes lead to imbalances. Special techniques are needed to maintain balance and ensure optimal performance.","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"O17QWfOVfZ"}],"key":"vUYrAbOty9"}],"key":"nxQyHKueZg"},{"type":"paragraph","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"text","value":"Overall, binary search trees are a powerful and versatile data structure for storing and managing sorted data efficiently. They offer fast search, insertion, and deletion operations, making them suitable for various applications like symbol tables, priority queues, and sorting algorithms.","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"key":"dbettOXZud"}],"key":"wnY8JMdb5K"},{"type":"heading","depth":2,"position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"children":[{"type":"text","value":"Lecture Code","position":{"start":{"line":39,"column":1},"end":{"line":39,"column":1}},"key":"LREvYMxQN9"}],"identifier":"lecture-code","label":"Lecture Code","html_id":"lecture-code","implicit":true,"key":"xgUN7MEKxa"},{"type":"code","lang":"java","value":"/*\n * binary tree\n *\n */\npackage btreedemoone;\n\nimport java.util.Scanner;\nimport java.util.Stack;\n\nclass Node {\n\n    // key\n    public int key;\n\n    // data - that's a double\t\n    public int data;\n\n    // node characteristics\n    public Node leftChild;\n    public Node rightChild;\n\n    public Node(int key, int data) {\n        this.key = key;\n        this.data = data;\n    }\n\n    // display node\n    public void displayNode() {\n        System.out.print(\"{\" + key + \",\" + data + \"}\");\n    }\n\n}// end of node\n\nclass Tree {\n\n    private Node root;\n    static Scanner myScan = new Scanner(System.in);\n\n    public Tree() {\n        root = null;\n    }\n\n    public void insert(int key, int data) {\n        // newNode\n        Node newNode = new Node(key, data);\n        boolean run = true;\n\n        if (root == null) {\n            root = newNode;\n        } else {\n            Node current = root;\n            Node parent;\n\n            while (run) {\n                parent = current;\n\n                if (key < current.key) //go left\n                {\n                    current = current.leftChild;\n\n                    if (current == null) {\n                        parent.leftChild = newNode;\n                        run = false;\n                    }\n                } else // go right\n                {\n                    current = current.rightChild;\n\n                    if (current == null) {\n                        parent.rightChild = newNode;\n                        run = false;\n                    }\n                }\n            }\n\n        }\n\n    }// end of insert\n\n    public Node find(int key) {\n\n        Node current = root;\n\n        // check if empty\n        if (root == null) {\n            System.out.println(\"** Tree is empty **\");\n            return null;\n        }\n\n        while (current.key != key) {\n\n            if (key < current.key) // go left?\n            {\n                current = current.leftChild;\n            } else // go right\n            {\n                current = current.rightChild;\n            }\n\n            if (current == null) {\n                System.out.println(\"*** key not found ***\");\n                return null;\n            }\n        }\n\n        System.out.println(\"Key was FOUND\");\n        return current;\n    }\n\n    public boolean delete(int key) {\n        Node current = root;\n        Node parent = root;\n        boolean isLeftChild = true;\n\n        //check if empty\n        if (root == null) {\n            System.out.println(\"*** Tree is empty ***\");\n            return false;\n        }\n\n        // look for the key\n        while (current.key != key) {\n            parent = current;\n\n            if (key < current.key) // go left?\n            {\n                isLeftChild = true;\n                current = current.leftChild;\n            } else // go right\n            {\n                isLeftChild = false;\n                current = current.rightChild;\n            }\n\n            if (current == null) {\n                System.out.println(\"*** key not found ***\");\n                return false;\n            }\n\n        }// end while\n\n        // found we are on the node to delete\n        // if there is no children - simply delete the node\n        if (current.leftChild == null && current.rightChild == null) {\n            //check if node is the root (there is only one node in tree)\n            if (current == root) {\n                root = null;\n            } else if (isLeftChild) {\n                parent.leftChild = null;\n            } else {\n                parent.rightChild = null;\n            }\n        } // if no right child, rplace with left subtree\n        else if (current.rightChild == null) {\n            if (current == root) {\n                root = current.leftChild;\n            } else if (isLeftChild) {\n                parent.leftChild = current.leftChild;\n            } else {\n                parent.rightChild = current.leftChild;\n            }\n        } //if no left child, replace with right subtree\n        else if (current.leftChild == null) {\n            if (current == root) {\n                root = current.rightChild;\n            } else if (isLeftChild) {\n                parent.leftChild = current.rightChild;\n            } else {\n                parent.rightChild = current.rightChild;\n            }\n        } // if there are two children, replace with inorder successor\n        else {\n            //get successor of node to delete of current\n            Node successor = getSuccessor(current);\n\n            // connect parent of current to successor instead\n            if (current == root) {\n                root = successor;\n            } else if (isLeftChild) {\n                parent.leftChild = successor;\n            } else {\n                parent.rightChild = successor;\n            }\n\n            // connect successor to current's left child\n            successor.leftChild = current.leftChild;\n\n            // NOTE: successor cannot have a left child\n        }\n\n        return true;\n\n    }\n\n    // return node with the next highest value after the delete node\n    // goes to right child, then right child's lef descendent's\n    private Node getSuccessor(Node deleteNode) {\n        Node successorParent = deleteNode;\n        Node successor = deleteNode;\n        Node current = deleteNode.rightChild;\n\n        while (current != null) {\n            successorParent = successor;\n            successor = current;\n            current = current.leftChild;\n        }\n\n        // if successor not successful\n        if (successor != deleteNode.rightChild) {\n            successorParent.leftChild = successor.rightChild;\n            successor.rightChild = deleteNode.rightChild;\n        }\n\n        return successor;\n    }\n\n    public void traverse2() {\n\n        System.out.print(\"\\nPreorder Traversal: \");\n        preorder(root);\n\n        System.out.print(\"\\nInorder Traversal: \");\n        inorder(root);\n\n        System.out.print(\"\\nPostorder Traversal: \");\n        postorder(root);\n\n    }\n\n    private void preorder(Node nodeStart) {\n        if (nodeStart != null) {\n            System.out.print(nodeStart.key + \" \");\n            preorder(nodeStart.leftChild);\n            preorder(nodeStart.rightChild);\n        }\n    }\n\n    private void inorder(Node nodeStart) {\n        if (nodeStart != null) {\n            inorder(nodeStart.leftChild);\n            System.out.print(nodeStart.key + \" \");\n            inorder(nodeStart.rightChild);\n        }\n    }\n\n    private void postorder(Node nodeStart) {\n        if (nodeStart != null) {\n            postorder(nodeStart.leftChild);\n            postorder(nodeStart.rightChild);\n            System.out.print(nodeStart.key + \" \");\n        }\n    }\n\n    public void displayTree() {\n        Stack globalStack = new Stack();\n        globalStack.push(root);\n\n        int nBlanks = 32;\n\n        boolean isRowEmpty = false;\n\n        System.out.println(\n                \"\\n..........         Display Tree     ..........................\");\n\n        while (!isRowEmpty) {\n            Stack localStack = new Stack();\n            isRowEmpty = true;\n\n            for (int j = 0; j < nBlanks; j++) {\n                System.out.print(\" \");\n            }\n\n            while (globalStack.isEmpty() == false) {\n                Node temp = (Node) globalStack.pop();\n                if (temp != null) {\n                    System.out.print(temp.data);\n                    localStack.push(temp.leftChild);\n                    localStack.push(temp.rightChild);\n\n                    if (temp.leftChild != null || temp.rightChild != null) {\n                        isRowEmpty = false;\n                    }\n                } else {\n                    System.out.print(\"--\");\n                    localStack.push(null);\n                    localStack.push(null);\n                }\n\n                for (int j = 0; j < nBlanks * 2 - 2; j++) {\n                    System.out.print(' ');\n                }\n            }//while\n\n            System.out.println();\n            nBlanks /= 2;\n            while (localStack.isEmpty() == false) {\n                globalStack.push(localStack.pop());\n            }\n        }\n        // for separation\n        System.out.println(\"---------------------------\");\n    } // display tree\n\n}\n\npublic class BTreeDemoOne {\n\n    static Scanner myScan = new Scanner(System.in);\n\n    public static void main(String[] args) {\n\n        String quit = \"n\";\n\n        int findValue = 0;\n        int deleteValue = 0;\n        int insertValue = 0;\n        \n        boolean result = false;\n\n        Tree theTree = new Tree();\n\n        while (!quit.equals(\"y\")) {\n            theTree.insert(50, 50);\n            theTree.insert(25, 25);\n            theTree.insert(75, 75);\n            theTree.insert(12, 12);\n            theTree.insert(37, 37);\n            theTree.insert(43, 43);\n            theTree.insert(30, 30);\n            theTree.insert(33, 33);\n            theTree.insert(87, 87);\n            theTree.insert(93, 93);\n            theTree.insert(97, 97);\n            theTree.insert(70, 70);\n            theTree.insert(60, 60);\n\n            theTree.displayTree();\n\n            theTree.insert(85, 85);\n            theTree.insert(47, 47);\n            \n\n            theTree.displayTree();\n\n            try {\n                System.out.print(\"Enter an integer to insert \"\n                        + \"or letter to skip: \");\n                insertValue = Integer.parseInt(myScan.nextLine());\n                theTree.insert(insertValue, insertValue);\n                theTree.displayTree();\n                \n            } catch (Exception e) {\n            }\n            \n            \n            theTree.traverse2();\n            try {\n                \n                System.out.print(\"\\nEnter Value To Find or letter to skip: \");\n                findValue = Integer.parseInt(myScan.nextLine());\n                theTree.find(findValue);\n\n            \n                System.out.println(\"\\nEnter value to delete: \");\n                deleteValue = Integer.parseInt(myScan.nextLine());\n\n                if (theTree.delete(deleteValue)) {\n                    theTree.displayTree();\n                } else {\n                    System.out.println(\"NOT FOUND\");\n                }\n            } catch (Exception e) {\n            }\n\n            System.out.print(\"Would you like to quit y/n: \");\n            quit = myScan.nextLine().toLowerCase();\n\n        }\n\n        System.out.println(\"\\nbye\\n\");\n    }\n\n}\n","position":{"start":{"line":41,"column":1},"end":{"line":426,"column":1}},"key":"rwXBjpqwAO"},{"type":"paragraph","position":{"start":{"line":430,"column":1},"end":{"line":430,"column":1}},"children":[{"type":"text","value":"BST as Class","position":{"start":{"line":430,"column":1},"end":{"line":430,"column":1}},"key":"kosl6VBp2D"}],"key":"It2axkX0IL"},{"type":"code","lang":"java","value":"/*\n    Change the package to your specific package\n */\npackage ds_redblacktree_rev2_separateclass;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Stack;\n\n/**\n *\n * @author jgoudy\n */\npublic class BinaryTreeSearch\n{\n\n    class Node\n    {\n\n        int key;\n        Node left;\n        Node right;\n        \n        \n\n        Node(int key)\n        {\n            this.key = key;\n            right = null;\n            left = null;\n        }\n    }\n\n    Node root;\n    public int trip = 0;\n\n    public void add(int key)\n    {\n        root = addRecursive(root, key);\n    }\n\n    private Node addRecursive(Node current, int key)\n    {\n\n        if (current == null)\n        {\n            return new Node(key);\n        }\n\n        if (key < current.key)\n        {\n            current.left = addRecursive(current.left, key);\n        } else if (key > current.key)\n        {\n            current.right = addRecursive(current.right, key);\n        }\n\n        return current;\n    }\n\n    public boolean isEmpty()\n    {\n        return root == null;\n    }\n\n    public int getSize()\n    {\n        return getSizeRecursive(root);\n    }\n\n    private int getSizeRecursive(Node current)\n    {\n        return current == null ? 0 : getSizeRecursive(current.left)\n                + 1 + getSizeRecursive(current.right);\n    }\n\n    public boolean containsNode(int key)\n    {\n        trip = 0;\n        return containsNodeRecursive(root, key);\n    }\n\n    private boolean containsNodeRecursive(Node current, int key)\n    {\n        if (current == null)\n        {\n            return false;\n        }\n        trip++;\n        if (key == current.key)\n        {\n            return true;\n        }\n\n        return key < current.key\n                ? containsNodeRecursive(current.left, key)\n                : containsNodeRecursive(current.right, key);\n    }\n\n    public void delete(int key)\n    {\n        root = deleteRecursive(root, key);\n    }\n\n    private Node deleteRecursive(Node current, int key)\n    {\n        if (current == null)\n        {\n            return null;\n        }\n\n        if (key == current.key)\n        {\n            // Case 1: no children\n            if (current.left == null && current.right == null)\n            {\n                return null;\n            }\n\n            // Case 2: only 1 child\n            if (current.right == null)\n            {\n                return current.left;\n            }\n\n            if (current.left == null)\n            {\n                return current.right;\n            }\n\n            // Case 3: 2 children\n            int smallestValue = findSmallestValue(current.right);\n            current.key = smallestValue;\n            current.right = deleteRecursive(current.right, smallestValue);\n            return current;\n        }\n        if (key < current.key)\n        {\n            current.left = deleteRecursive(current.left, key);\n            return current;\n        }\n\n        current.right = deleteRecursive(current.right, key);\n        return current;\n    }\n\n    public int findSmallestValue(Node root)\n    {\n        return root.left == null ? root.key : findSmallestValue(root.left);\n    }\n\n    public int findLargestValue(Node root)\n    {\n        return root.left == null ? root.key : findLargestValue(root.right);\n    }\n\n    public void traverseInOrder(Node node)\n    {\n        if (node != null)\n        {\n            traverseInOrder(node.left);\n            visit(node.key);\n            traverseInOrder(node.right);\n        }\n    }\n\n    public void traversePreOrder(Node node)\n    {\n        if (node != null)\n        {\n            visit(node.key);\n            traversePreOrder(node.left);\n            traversePreOrder(node.right);\n        }\n    }\n\n    public void traversePostOrder(Node node)\n    {\n        if (node != null)\n        {\n            traversePostOrder(node.left);\n            traversePostOrder(node.right);\n            visit(node.key);\n        }\n    }\n\n    public void traverseLevelOrder()\n    {\n        if (root == null)\n        {\n            return;\n        }\n\n        Queue<Node> nodes = new LinkedList<>();\n        nodes.add(root);\n\n        while (!nodes.isEmpty())\n        {\n\n            Node node = nodes.remove();\n\n            System.out.print(\" \" + node.key);\n\n            if (node.left != null)\n            {\n                nodes.add(node.left);\n            }\n\n            if (node.left != null)\n            {\n                nodes.add(node.right);\n            }\n        }\n    }\n\n    public void traverseInOrderWithoutRecursion()\n    {\n        Stack<Node> stack = new Stack<Node>();\n        Node current = root;\n        stack.push(root);\n        while (!stack.isEmpty())\n        {\n            while (current.left != null)\n            {\n                current = current.left;\n                stack.push(current);\n            }\n            current = stack.pop();\n            visit(current.key);\n            if (current.right != null)\n            {\n                current = current.right;\n                stack.push(current);\n            }\n        }\n    }\n\n    public void traversePreOrderWithoutRecursion()\n    {\n        Stack<Node> stack = new Stack<Node>();\n        Node current = root;\n        stack.push(root);\n        while (!stack.isEmpty())\n        {\n            current = stack.pop();\n            visit(current.key);\n\n            if (current.right != null)\n            {\n                stack.push(current.right);\n            }\n\n            if (current.left != null)\n            {\n                stack.push(current.left);\n            }\n        }\n    }\n\n    public void traversePostOrderWithoutRecursion()\n    {\n        Stack<Node> stack = new Stack<Node>();\n        Node prev = root;\n        Node current = root;\n        stack.push(root);\n\n        while (!stack.isEmpty())\n        {\n            current = stack.peek();\n            boolean hasChild = (current.left != null || current.right != null);\n            boolean isPrevLastChild = (prev == current.right\n                    || (prev == current.left && current.right == null));\n\n            if (!hasChild || isPrevLastChild)\n            {\n                current = stack.pop();\n                visit(current.key);\n                prev = current;\n            } else\n            {\n                if (current.right != null)\n                {\n                    stack.push(current.right);\n                }\n                if (current.left != null)\n                {\n                    stack.push(current.left);\n                }\n            }\n        }\n    }\n\n    private void visit(int key)\n    {\n        System.out.print(\" \" + key);\n    }\n\n}\n","position":{"start":{"line":432,"column":1},"end":{"line":732,"column":1}},"key":"oyOSN5fnjW"}],"key":"vvU1Ao8hob"}],"key":"L5ckr89s8b"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Demonstrate BST using iterative looping and recursion","url":"/xbst-iterative-recursion-search","group":"Algorithms"},"next":{"title":"AVL Tree","url":"/xbst-avltree","group":"Algorithms"}}},"domain":"http://localhost:3002"}