{"version":3,"kind":"Article","sha256":"93e2741e020a27d02716a818d0eefaae04deaa33256b6d59ca2d65bd2d5f002f","slug":"xbst-splaytrees-2025","location":"/xBST_SplayTrees_2025.md","dependencies":[],"frontmatter":{"title":"Splay Trees","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xBST_SplayTrees_2025.md","url":"/CSCI232/build/xBST_SplayTrees_2025-7dabda0af53291a1ac749b29e7cd1682.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Splay Trees","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"bfNZ3UgBVS"}],"identifier":"splay-trees","label":"Splay Trees","html_id":"splay-trees","implicit":true,"key":"dJPgiEKgko"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"A ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"BLzuSZRzm0"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"splay tree","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"xZYlTFQdbR"}],"key":"ex0plpIrN0"},{"type":"text","value":" is a type of self-adjusting binary search tree (BST) where recently accessed elements are moved to the root of the tree using a process called ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"r0WPiBfZ4g"},{"type":"emphasis","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"splaying","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"xZkwf34fDx"}],"key":"HylzBVQ6is"},{"type":"text","value":". This helps ensure that frequently accessed elements are quicker to access.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"A7uHUommCS"}],"key":"y3MsliJZXc"},{"type":"heading","depth":2,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Who Invented It:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"XHqyzOuYfb"}],"identifier":"who-invented-it","label":"Who Invented It:","html_id":"who-invented-it","implicit":true,"key":"MWMTJuo7Ou"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":9,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":9,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Splay trees were invented by ","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"MlqaMcygVd"},{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Daniel Sleator","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"OGtu8B2nFM"}],"key":"AFo4J069MI"},{"type":"text","value":" and ","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"kwWCWV1oPS"},{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Robert Tarjan","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"sjiUC6djTZ"}],"key":"KCNoOg6o7t"},{"type":"text","value":" in 1985. The invention was part of their research on self-adjusting data structures.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"NNLjib2smE"}],"key":"rAqgwpPgSg"}],"key":"gGbQb9CPDK"},{"type":"heading","depth":3,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"When Was It Invented:","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"hf7Kj1DU0Q"}],"identifier":"when-was-it-invented","label":"When Was It Invented:","html_id":"when-was-it-invented","implicit":true,"key":"tIHDzX7WgC"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":13,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"The splay tree was introduced in ","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"VdqbKuXB5Y"},{"type":"strong","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"1985","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"V25iy6TZBv"}],"key":"YwRrNwzZH6"},{"type":"text","value":".","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"nf32iHzkt1"}],"key":"JQlS7MBtkc"}],"key":"y57rbYTxUV"},{"type":"heading","depth":2,"position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"Major Uses:","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"mswGaq1c1W"}],"identifier":"major-uses","label":"Major Uses:","html_id":"major-uses","implicit":true,"key":"KOn25vLqKK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":17,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"strong","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Dynamic sets","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"luJsxT3rbA"}],"key":"iAEJpOaN2T"},{"type":"text","value":": Splay trees are used to maintain a dynamic set of elements that can support a variety of search and update operations.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"cieLLUJw2y"}],"key":"iUzG9I0X3u"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Memory-efficient","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"CkIr7CYL1z"}],"key":"qeqbUr65yl"},{"type":"text","value":": Since splay trees do not require additional space for balancing data like AVL trees or Red-Black trees, they can be more memory-efficient.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"oyjabj9bmK"}],"key":"y10SCpNZiQ"},{"type":"listItem","spread":true,"position":{"start":{"line":19,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"strong","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"text","value":"Efficient in practice for certain workloads","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"du8ieRdMqK"}],"key":"b1uranFd0W"},{"type":"text","value":": Splay trees perform well when there are repeated accesses to a small subset of elements (i.e., the access pattern exhibits locality).","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"V85Rq4EHBM"}],"key":"DzuYK5qmax"}],"key":"q32dMqdBbo"},{"type":"heading","depth":2,"position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"Typical Applications:","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"waMgFzYPdd"}],"identifier":"typical-applications","label":"Typical Applications:","html_id":"typical-applications","implicit":true,"key":"R5DG7nQAlL"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":23,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"strong","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"Cache systems","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"l21zmtsz8Q"}],"key":"RY9iWEN5h5"},{"type":"text","value":": Frequently accessed items bubble to the front.","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"p4p53JCC7R"}],"key":"lpCIiXdZY2"},{"type":"listItem","spread":true,"position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"strong","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"text","value":"Text editors","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"aQs9Slcw36"}],"key":"JSUk01ChPz"},{"type":"text","value":": Recently opened files or commands can be organized in a splay list.","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"s07kdj7UoL"}],"key":"EI3sIQQlsu"},{"type":"listItem","spread":true,"position":{"start":{"line":25,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"strong","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"text","value":"Autocomplete lists","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"pbctKLu3Ae"}],"key":"tAt6XissXb"},{"type":"text","value":": Recently or frequently used search terms are moved to the front.","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"tcFiBAcKJg"}],"key":"hlCl1SDztA"}],"key":"tOjj22M8er"},{"type":"heading","depth":2,"position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"text","value":"Insert Function:","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"key":"ii9I55sLAO"}],"identifier":"insert-function","label":"Insert Function:","html_id":"insert-function","implicit":true,"key":"EQkdPP9CEw"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":29,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":29,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"strong","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"Insertion in a splay tree","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"IuTkkfTmQ7"}],"key":"JG7jKyG3kP"},{"type":"text","value":" is similar to that in a regular binary search tree. The node is inserted following the normal BST rules. However, after insertion, the tree is “splayed” to bring the newly inserted node to the root.","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"icdHr8NZSO"}],"key":"wKtynapGb3"}],"key":"Xq6ODgTYA4"},{"type":"code","lang":"java","value":"public void insert(int value) {\n    root = insertRec(root, value);\n    splay(root, value);\n}\n\nprivate Node insertRec(Node root, int value) {\n    if (root == null) {\n        root = new Node(value);\n        return root;\n    }\n\n    if (value < root.data) {\n        root.left = insertRec(root.left, value);\n    } else if (value > root.data) {\n        root.right = insertRec(root.right, value);\n    }\n\n    return root;\n}","position":{"start":{"line":31,"column":1},"end":{"line":51,"column":1}},"key":"o9YfysZDOU"},{"type":"heading","depth":2,"position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"Delete Function:","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"s2SJcBCNR4"}],"identifier":"delete-function","label":"Delete Function:","html_id":"delete-function","implicit":true,"key":"Sr78QNocys"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":55,"column":1},"end":{"line":56,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":55,"column":1},"end":{"line":56,"column":1}},"children":[{"type":"strong","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"children":[{"type":"text","value":"Deletion","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"key":"QgCznRVorK"}],"key":"Xv2XVQuzIV"},{"type":"text","value":" is performed in the same way as in a normal binary search tree. After finding the node to delete, it is removed, and then the tree is splayed to restore the tree’s structure.","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"key":"jGp92AHHFZ"}],"key":"C4daJJyh0n"}],"key":"yKFRGjkPUh"},{"type":"code","lang":"java","value":"public void delete(int value) {\n    root = deleteRec(root, value);\n}\n\nprivate Node deleteRec(Node root, int value) {\n    if (root == null) return root;\n\n    if (value < root.data) {\n        root.left = deleteRec(root.left, value);\n    } else if (value > root.data) {\n        root.right = deleteRec(root.right, value);\n    } else {\n        // node with value found\n        if (root.left == null) return root.right;\n        else if (root.right == null) return root.left;\n    }\n\n    return root;\n}","position":{"start":{"line":57,"column":1},"end":{"line":77,"column":1}},"key":"oIliHYhPpM"},{"type":"heading","depth":2,"position":{"start":{"line":79,"column":1},"end":{"line":79,"column":1}},"children":[{"type":"text","value":"Find Function:","position":{"start":{"line":79,"column":1},"end":{"line":79,"column":1}},"key":"HOdAGWJ9Di"}],"identifier":"find-function","label":"Find Function:","html_id":"find-function","implicit":true,"key":"xlUmO9m9QK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":81,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":81,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"text","value":"The ","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"MTuIS1f3nI"},{"type":"strong","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"children":[{"type":"text","value":"find function","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"nzS2gUctTH"}],"key":"s8idwdmfNe"},{"type":"text","value":" searches for a value in the tree, and if the value is found, it performs a splay operation to bring that value to the root. If the value is not found, the tree remains unchanged.","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"FH1qXGlpui"}],"key":"LasSS5MyG5"}],"key":"GSaJdOJmd6"},{"type":"code","lang":"java","value":"public boolean find(int value) {\n    root = splay(root, value);\n    return (root != null && root.data == value);\n}","position":{"start":{"line":83,"column":1},"end":{"line":88,"column":1}},"key":"blXazSSSfU"},{"type":"heading","depth":2,"position":{"start":{"line":90,"column":1},"end":{"line":90,"column":1}},"children":[{"type":"text","value":"Rules for Rotations:","position":{"start":{"line":90,"column":1},"end":{"line":90,"column":1}},"key":"OlHghD58Em"}],"identifier":"rules-for-rotations","label":"Rules for Rotations:","html_id":"rules-for-rotations","implicit":true,"key":"okfpBlyaDJ"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":92,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":92,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"text","value":"Splay trees use three types of rotations to adjust the tree during splaying:","position":{"start":{"line":92,"column":1},"end":{"line":92,"column":1}},"key":"neEzjt7zAv"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":93,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"strong","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"text","value":"Zig","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"XxowMg1dB3"}],"key":"mDs9S1iFak"},{"type":"text","value":": When the node is the child of the root.","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"kjqqtKZlr4"}],"key":"IqXgADAVh1"},{"type":"listItem","spread":true,"position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"children":[{"type":"strong","position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"children":[{"type":"text","value":"Zig-Zig","position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"key":"B0ouiR6Z5A"}],"key":"cbnmVESkxR"},{"type":"text","value":": When the node is the left or right child of a left or right child (two-level deep).","position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"key":"IrV574GVO3"}],"key":"FIQBpC5pqg"},{"type":"listItem","spread":true,"position":{"start":{"line":95,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"strong","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"Zig-Zag","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"RwWMHBNzc8"}],"key":"AEdCsllwN1"},{"type":"text","value":": When the node is the left child of the right child or the right child of the left child.","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ZXftDzCLHA"}],"key":"QvuL8S3z4n"}],"key":"YmNd7kis4p"}],"key":"HuqOBPzSuj"}],"key":"t5D720piOC"},{"type":"heading","depth":2,"position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"children":[{"type":"text","value":"Rotations:","position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"key":"aoA7oeOVs5"}],"identifier":"rotations","label":"Rotations:","html_id":"rotations","implicit":true,"key":"h2lz2xWjvQ"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":99,"column":1},"end":{"line":101,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"children":[{"type":"strong","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"children":[{"type":"text","value":"Single Rotation (Zig)","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"key":"Z2n7NeHmMv"}],"key":"OHiuzKeAky"},{"type":"text","value":": If the node is the child of the root, perform a single rotation (right or left depending on the situation).","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"key":"sPTYtXARw2"}],"key":"csKArHbp66"},{"type":"listItem","spread":true,"position":{"start":{"line":100,"column":1},"end":{"line":101,"column":1}},"children":[{"type":"strong","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"children":[{"type":"text","value":"Double Rotation (Zig-Zig or Zig-Zag)","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"key":"YIKzVF4T3B"}],"key":"OaGgQtjMQi"},{"type":"text","value":": In these cases, two rotations are needed. They help in cases where the tree has more than one level to adjust.","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"key":"VAuJQP3wwR"}],"key":"mad1xqDWpw"}],"key":"yHpOa1m0KE"},{"type":"code","lang":"java","value":"private Node splay(Node root, int value) {\n    if (root == null || root.data == value) return root;\n\n    if (value < root.data) {\n        if (root.left == null) return root;\n        if (value < root.left.data) {\n            root.left.left = splay(root.left.left, value);\n            root = rotateRight(root);\n        } else if (value > root.left.data) {\n            root.left.right = splay(root.left.right, value);\n            if (root.left.right != null) {\n                root.left = rotateLeft(root.left);\n            }\n        }\n        return (root.left == null) ? root : rotateRight(root);\n    } else {\n        if (root.right == null) return root;\n        if (value > root.right.data) {\n            root.right.right = splay(root.right.right, value);\n            root = rotateLeft(root);\n        } else if (value < root.right.data) {\n            root.right.left = splay(root.right.left, value);\n            if (root.right.left != null) {\n                root.right = rotateRight(root.right);\n            }\n        }\n        return (root.right == null) ? root : rotateLeft(root);\n    }\n}","position":{"start":{"line":102,"column":1},"end":{"line":132,"column":1}},"key":"GTNhcICb9E"},{"type":"heading","depth":2,"position":{"start":{"line":134,"column":1},"end":{"line":134,"column":1}},"children":[{"type":"text","value":"Java Program Demonstrating Insert, Find, Delete, and Pretty Print:","position":{"start":{"line":134,"column":1},"end":{"line":134,"column":1}},"key":"uf2J6mKwwp"}],"identifier":"java-program-demonstrating-insert-find-delete-and-pretty-print","label":"Java Program Demonstrating Insert, Find, Delete, and Pretty Print:","html_id":"java-program-demonstrating-insert-find-delete-and-pretty-print","implicit":true,"key":"AgKQ1vN5ow"},{"type":"code","lang":"java","value":"package inst_splay_2025;\n\nclass SplayTree {\n\n    private Node root;\n\n    // Inner class representing a node in the splay tree\n    class Node {\n\n        int data;\n        Node left, right;\n\n        public Node(int item)\n        {\n            data = item;\n            left = right = null;\n        }\n    }\n\n    // Inserts a value into the tree\n    public void insert(int value)\n    {\n        if (root == null) {\n            root = new Node(value);\n            return;\n        }\n\n        // Splay the tree to bring the value (or closest) to the root\n        root = splay(root, value);\n\n        // If the value already exists, no need to insert\n        if (root.data == value) {\n            return;\n        }\n\n        Node newNode = new Node(value);\n\n        // If the new value is smaller, make the new node root and adjust pointers\n        if (value < root.data) {\n            newNode.right = root;\n            newNode.left = root.left;\n            root.left = null;\n        } else { // If the new value is greater\n            newNode.left = root;\n            newNode.right = root.right;\n            root.right = null;\n        }\n\n        root = newNode; // Update root\n    }\n\n    // Searches for a value in the tree\n    public boolean find(int value)\n    {\n        root = splay(root, value);\n        return (root != null && root.data == value);\n    }\n\n    // Deletes a node with the given value\n    public void delete(int value)\n    {\n        if (root == null) {\n            return;\n        }\n\n        // Splay the tree so that the value (or closest) is at the root\n        root = splay(root, value);\n\n        if (root.data != value) {\n            return; // If not found, do nothing\n        }\n        if (root.left == null) {\n            root = root.right;\n        } else {\n            Node temp = root;\n            // Splay the largest node in the left subtree to make it new root\n            root = splay(root.left, value);\n            root.right = temp.right;\n        }\n    }\n\n    // Right rotation (Zig rotation)\n    private Node rotateRight(Node root)\n    {\n        if (root == null || root.left == null) {\n            return root;\n        }\n        Node newRoot = root.left;\n        root.left = newRoot.right;\n        newRoot.right = root;\n        return newRoot;\n    }\n\n    // Left rotation (Zag rotation)\n    private Node rotateLeft(Node root)\n    {\n        if (root == null || root.right == null) {\n            return root;\n        }\n        Node newRoot = root.right;\n        root.right = newRoot.left;\n        newRoot.left = root;\n        return newRoot;\n    }\n\n    /*\n     * Splay Operation: Moves the given value to the root if present, or the closest value.\n     * \n     * Splay tree follows these rules for rotations:\n     * \n     * - Zig Rotation (Single Right): When the value is in the left child of the root.\n     * - Zag Rotation (Single Left): When the value is in the right child of the root.\n     * - Zig-Zig (Double Right Rotation): When the value is in the left child of the left child.\n     * - Zag-Zag (Double Left Rotation): When the value is in the right child of the right child.\n     * - Zig-Zag (Left-Right Rotation): When the value is in the right child of the left child.\n     * - Zag-Zig (Right-Left Rotation): When the value is in the left child of the right child.\n     */\n    private Node splay(Node root, int value)\n    {\n        if (root == null || root.data == value) {\n            return root;\n        }\n\n        if (value < root.data) {\n            if (root.left == null) {\n                return root;\n            }\n\n            // Zig-Zig case (left-left)\n            if (value < root.left.data) {\n                root.left.left = splay(root.left.left, value);\n                root = rotateRight(root);\n            } // Zig-Zag case (left-right)\n            else if (value > root.left.data) {\n                root.left.right = splay(root.left.right, value);\n                if (root.left.right != null) {\n                    root.left = rotateLeft(root.left);\n                }\n            }\n\n            // Perform a final Zig rotation\n            return (root.left == null) ? root : rotateRight(root);\n        } else {\n            if (root.right == null) {\n                return root;\n            }\n\n            // Zag-Zag case (right-right)\n            if (value > root.right.data) {\n                root.right.right = splay(root.right.right, value);\n                root = rotateLeft(root);\n            } // Zag-Zig case (right-left)\n            else if (value < root.right.data) {\n                root.right.left = splay(root.right.left, value);\n                if (root.right.left != null) {\n                    root.right = rotateRight(root.right);\n                }\n            }\n\n            // Perform a final Zag rotation\n            return (root.right == null) ? root : rotateLeft(root);\n        }\n    }\n\n    // Prints the tree structure\n    public void prettyPrint(Node root, String indent)\n    {\n        if (root == null) {\n            return;\n        }\n        prettyPrint(root.right, indent + \"   \");\n        System.out.println(indent + root.data);\n        prettyPrint(root.left, indent + \"   \");\n    }\n\n    // Initiates tree printing\n    public void printTree()\n    {\n        prettyPrint(root, \"\");\n    }\n}\n\n// Driver class to test the Splay Tree implementation\npublic class Inst_splay_2025 {\n\n    public static void main(String[] args)\n    {\n        SplayTree tree = new SplayTree();\n\n        tree.insert(10);\n        tree.insert(20);\n        tree.insert(5);\n        tree.insert(55);\n        tree.insert(60);\n        tree.insert(65);\n        tree.insert(70);\n        tree.insert(75);\n        tree.insert(30);\n        tree.insert(15);\n        tree.insert(25);\n\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.find(20);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.find(5);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.find(65);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(10);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(30);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(15);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(5);\n        tree.printTree();\n    }\n}\n\n","position":{"start":{"line":137,"column":1},"end":{"line":372,"column":1}},"key":"Ktf3iaidEu"},{"type":"heading","depth":2,"position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"children":[{"type":"text","value":"Explanation of Rotation Rules:","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"InthFPODa2"}],"identifier":"explanation-of-rotation-rules","label":"Explanation of Rotation Rules:","html_id":"explanation-of-rotation-rules","implicit":true,"key":"lvmy4P7Yll"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":376,"column":1},"end":{"line":379,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"children":[{"type":"strong","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"children":[{"type":"text","value":"Zig (Single Rotation)","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"tGi5AXZEHB"}],"key":"m0aBMTMU8A"},{"type":"text","value":": If the node to be accessed is the left or right child of the root, perform a single rotation (either left or right).","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"XmoD4XKL2J"}],"key":"Ho7HK1faMn"},{"type":"listItem","spread":true,"position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"children":[{"type":"strong","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"children":[{"type":"text","value":"Zig-Zig (Double Rotation)","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"key":"kwwnm1wJOd"}],"key":"howtooWyRE"},{"type":"text","value":": If the node is the left or right child of a left or right child (two levels deep), perform two rotations. This optimizes the tree by rotating both the node and its parent.","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"key":"nlXjRFS5MF"}],"key":"LI44P0x0T7"},{"type":"listItem","spread":true,"position":{"start":{"line":378,"column":1},"end":{"line":379,"column":1}},"children":[{"type":"strong","position":{"start":{"line":378,"column":1},"end":{"line":378,"column":1}},"children":[{"type":"text","value":"Zig-Zag (Double Rotation)","position":{"start":{"line":378,"column":1},"end":{"line":378,"column":1}},"key":"k49A2jyiBt"}],"key":"RhIcKy2ZkC"},{"type":"text","value":": If the node is the left child of the right child, or the right child of the left child (mixed child directions), perform a rotation on the child followed by a rotation on the node itself.","position":{"start":{"line":378,"column":1},"end":{"line":378,"column":1}},"key":"S4taGukYiM"}],"key":"gvO5X7IWUK"}],"key":"Ty6HiWzEVb"},{"type":"paragraph","position":{"start":{"line":380,"column":1},"end":{"line":380,"column":1}},"children":[{"type":"text","value":"This program demonstrates how to use splay tree operations and includes helpful comments and explanations of the rotation rules. Each rotation helps ensure the tree remains balanced by moving frequently accessed nodes towards the root.","position":{"start":{"line":380,"column":1},"end":{"line":380,"column":1}},"key":"PWbC1FWtWT"}],"key":"cVrmBtuYr2"},{"type":"thematicBreak","position":{"start":{"line":384,"column":1},"end":{"line":384,"column":1}},"key":"ov9vnsYLtN"},{"type":"heading","depth":2,"position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"children":[{"type":"text","value":"Splay using for loops","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"CP1J12ng7a"}],"identifier":"splay-using-for-loops","label":"Splay using for loops","html_id":"splay-using-for-loops","implicit":true,"key":"eveTsqoiQt"},{"type":"paragraph","position":{"start":{"line":390,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"text","value":"This version avoids the recursive calls and uses loops to handle the tree traversal and adjustments.","position":{"start":{"line":390,"column":1},"end":{"line":390,"column":1}},"key":"HWZN2fjwkh"}],"key":"agj9VQM1pg"},{"type":"code","lang":"java","value":"class SplayTree {\n    private Node root;\n\n    // Node class to represent each node in the tree\n    class Node {\n        int data;  // Data stored in the node\n        Node left, right;  // Left and right child nodes\n\n        // Constructor to create a new node with the given value\n        public Node(int item) {\n            data = item;\n            left = right = null;\n        }\n    }\n\n    // Insert function to add a new value into the splay tree\n    public void insert(int value) {\n        if (root == null) {\n            root = new Node(value);  // If tree is empty, create a new node as root\n            return;\n        }\n\n        Node node = root;\n        Node parent = null;\n\n        // Loop to find the correct position for insertion\n        while (node != null) {\n            parent = node;\n            if (value < node.data) {\n                node = node.left;\n            } else if (value > node.data) {\n                node = node.right;\n            } else {\n                return;  // If the value is already present, do nothing\n            }\n        }\n\n        // Create a new node and attach it to the parent\n        node = new Node(value);\n        if (value < parent.data) {\n            parent.left = node;\n        } else {\n            parent.right = node;\n        }\n\n        // After insertion, splay the tree to bring the inserted node to the root\n        root = splay(root, value);\n    }\n\n    // Delete function to remove a node from the splay tree\n    public void delete(int value) {\n        if (root == null) return;\n\n        // Splay the tree to bring the node to be deleted to the root\n        root = splay(root, value);\n\n        if (root == null || root.data != value) return;  // Node not found\n\n        // Node to be deleted is at the root\n        if (root.left == null) {\n            root = root.right;  // If left child is null, replace root with right child\n        } else {\n            Node rightSubtree = root.right;\n            root = root.left;\n            root = splay(root, value);  // Splay the left subtree to bring the max element to the root\n            root.right = rightSubtree;  // Attach the right subtree to the new root\n        }\n    }\n\n    // Find function to search for a value in the splay tree\n    public boolean find(int value) {\n        if (root == null) return false;\n\n        // Splay the tree to bring the searched node to the root\n        root = splay(root, value);\n\n        return (root != null && root.data == value);\n    }\n\n    // Function to perform a right rotation on the tree (used during splaying)\n    private Node rotateRight(Node root) {\n        Node newRoot = root.left;  // Make the left child the new root\n        root.left = newRoot.right;  // Make the right child of the new root the left child of the old root\n        newRoot.right = root;  // Make the old root the right child of the new root\n        return newRoot;  // Return the new root\n    }\n\n    // Function to perform a left rotation on the tree (used during splaying)\n    private Node rotateLeft(Node root) {\n        Node newRoot = root.right;  // Make the right child the new root\n        root.right = newRoot.left;  // Make the left child of the new root the right child of the old root\n        newRoot.left = root;  // Make the old root the left child of the new root\n        return newRoot;  // Return the new root\n    }\n\n    // Splay function to bring the node with the given value to the root\n    private Node splay(Node root, int value) {\n        while (root != null) {\n            // Base case: if the node is found or we reach the leaf, break out of the loop\n            if (root.data == value) return root;\n\n            // Zig (single rotation): If the node is the left child or right child of the root\n            if (value < root.data) {\n                if (root.left == null) break;  // If there's no left child, stop\n\n                // Zig-Zig (double rotation): If node's value is in the left subtree of left child\n                if (value < root.left.data) {\n                    root = rotateRight(root);\n                } else if (value > root.left.data) {\n                    // Zig-Zag (double rotation): If node's value is in the right subtree of left child\n                    root.left = rotateLeft(root.left);\n                    root = rotateRight(root);\n                }\n            } else {\n                if (root.right == null) break;  // If there's no right child, stop\n\n                // Zig-Zig (double rotation): If node's value is in the right subtree of right child\n                if (value > root.right.data) {\n                    root = rotateLeft(root);\n                } else if (value < root.right.data) {\n                    // Zig-Zag (double rotation): If node's value is in the left subtree of right child\n                    root.right = rotateRight(root.right);\n                    root = rotateLeft(root);\n                }\n            }\n        }\n        return root;\n    }\n\n    // Pretty print function to display the tree visually\n    public void prettyPrint(Node root, String indent) {\n        if (root == null) return;  // If the root is null, return\n\n        // Print the right subtree first with increased indentation\n        prettyPrint(root.right, indent + \"   \");\n        System.out.println(indent + root.data);  // Print the current node\n        // Print the left subtree with increased indentation\n        prettyPrint(root.left, indent + \"   \");\n    }\n\n    // Wrapper function to print the tree\n    public void printTree() {\n        prettyPrint(root, \"\");  // Call the prettyPrint function starting from the root\n    }\n\n    public static void main(String[] args) {\n        SplayTree tree = new SplayTree();\n\n        // Inserting values into the tree\n        tree.insert(10);\n        tree.insert(20);\n        tree.insert(30);\n        tree.insert(15);\n\n        // Pretty print the tree after insertion\n        System.out.println(\"Tree after insertion:\");\n        tree.printTree();\n\n        // Find a value in the tree and bring it to the root\n        tree.find(20);\n        System.out.println(\"\\nTree after finding 20:\");\n        tree.printTree();\n\n        // Delete a value from the tree\n        tree.delete(10);\n        System.out.println(\"\\nTree after deleting 10:\");\n        tree.printTree();\n    }\n}","position":{"start":{"line":392,"column":1},"end":{"line":562,"column":1}},"key":"yeULeCJSR0"},{"type":"heading","depth":2,"position":{"start":{"line":564,"column":1},"end":{"line":564,"column":1}},"children":[{"type":"text","value":"Explanation of Changes:","position":{"start":{"line":564,"column":1},"end":{"line":564,"column":1}},"key":"lbXOJFjDCU"}],"identifier":"explanation-of-changes","label":"Explanation of Changes:","html_id":"explanation-of-changes","implicit":true,"key":"w7JwzQk7k3"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":566,"column":1},"end":{"line":570,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"children":[{"type":"strong","position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"children":[{"type":"text","value":"Insert Method","position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"key":"XovWr7K0bd"}],"key":"zbJGd9D8ri"},{"type":"text","value":": The insertion now uses a loop to traverse the tree and find the correct position to insert the new node. The insertion process is followed by a splay operation to move the newly inserted node to the root.","position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"key":"Vh4LePUwL2"}],"key":"DC5vU1m9qF"},{"type":"listItem","spread":true,"position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"children":[{"type":"strong","position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"children":[{"type":"text","value":"Delete Method","position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"key":"x5tSN0VgKR"}],"key":"jF7W1Uts2i"},{"type":"text","value":": Similar to insertion, the delete method now uses a loop to traverse the tree and delete the node. It also includes a splay operation to move the necessary nodes after deletion.","position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"key":"sKLURdOviX"}],"key":"rujTvxawCJ"},{"type":"listItem","spread":true,"position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"children":[{"type":"strong","position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"children":[{"type":"text","value":"Splay Method","position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"key":"DAXWUlEZJp"}],"key":"n2Xmq4bv73"},{"type":"text","value":": The splay function has been rewritten to use a loop instead of recursion. It continuously adjusts the tree until the target node is either found or no further adjustments are necessary.","position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"key":"DUiHX3LJU8"}],"key":"pexsLffiqr"},{"type":"listItem","spread":true,"position":{"start":{"line":569,"column":1},"end":{"line":570,"column":1}},"children":[{"type":"strong","position":{"start":{"line":569,"column":1},"end":{"line":569,"column":1}},"children":[{"type":"text","value":"Rotation Methods","position":{"start":{"line":569,"column":1},"end":{"line":569,"column":1}},"key":"lh1fAeWsBj"}],"key":"rNbrfBm4F0"},{"type":"text","value":": The left and right rotations remain the same, as these are simple tree manipulations that don’t depend on recursion.","position":{"start":{"line":569,"column":1},"end":{"line":569,"column":1}},"key":"jnKG8mffl0"}],"key":"g68svJ0z7z"}],"key":"Kx36Xocewh"},{"type":"paragraph","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"children":[{"type":"text","value":"This approach eliminates recursion in favor of iterative methods using loops, which may help avoid potential stack overflow issues with deep trees, though it may still be less efficient compared to a more balanced tree like an AVL or Red-Black tree. However, the splay tree performs well with specific access patterns, especially when there is locality of reference.","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"key":"YWnLu2DrXu"}],"key":"GOTCa4vxCt"}],"key":"vQks4iszDj"}],"key":"wdfUE4VBhs"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"BST AVL Red Black Tree Comparisons","url":"/xbst-comparisiontable","group":"Algorithms"},"next":{"title":"Hash Table","url":"/xhashing-hashtable","group":"Algorithms"}}},"domain":"http://localhost:3002"}