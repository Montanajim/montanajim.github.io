{"version":3,"kind":"Article","sha256":"cd845d4aa55646ed9008fc9e1e6add2c9d506b59207b58b8e1add2067e109f81","slug":"xgraphsdfs","location":"/xGraphsDFS.md","dependencies":[],"frontmatter":{"title":"Depth-First Search (DFS)","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xGraphsDFS.md","url":"/CSCI232/build/xGraphsDFS-560f61884b921dc159e6c5cbcc9a3c14.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Depth-First Search (DFS) is an algorithm for exploring tree or graph data structures. Imagine you’re navigating a maze, and DFS is like taking a very narrow path, going as far as you can down one tunnel before checking any side passages. Here’s how it works on graphs:","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"ACZ3Za2D8Z"}],"key":"PA94cPym8q"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":5,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Start at a Node:","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"MfVrxRlZsu"}],"key":"L37CDH3voy"},{"type":"text","value":" You begin at any node (like the entrance to the maze).","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"W8sdV63lR2"}],"key":"jCWD2xOwQ6"},{"type":"listItem","spread":true,"position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"strong","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"children":[{"type":"text","value":"Explore Deepest Path:","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"tE5YPD5e1t"}],"key":"sibp9Pb3I9"},{"type":"text","value":" Visit all the unvisited neighbors of that node (like going down the main tunnel).","position":{"start":{"line":6,"column":1},"end":{"line":6,"column":1}},"key":"oUedhgbcVd"}],"key":"xom229iLeh"},{"type":"listItem","spread":true,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Mark and Backtrack:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"zJgfDsNiEc"}],"key":"dV3XUR0LmL"},{"type":"text","value":"  Mark the current node as visited to avoid revisiting it. If you reach a dead end (a node with no unvisited neighbors), backtrack to the most recent un-explored path (like going back to a fork in the maze and taking a different tunnel).","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"krUBLVlhyr"}],"key":"xQidzWb3wA"},{"type":"listItem","spread":true,"position":{"start":{"line":8,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"strong","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"Repeat:","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"ZHYrCwScAe"}],"key":"E3lAAIRl0Y"},{"type":"text","value":"  Keep repeating steps 2 and 3 until you’ve explored all possible paths from the starting node.","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"kc8tt329Gp"}],"key":"ya7CYf8doO"}],"key":"hS7AuE4nqb"},{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"strong","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Data Structures Used:","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"xaOT6fsbFu"}],"key":"w3DBt0DWES"}],"key":"ZwB3g1qNFk"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":12,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"strong","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Stack:","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"r8S4pCmaOl"}],"key":"ITZ1QeS4Xd"},{"type":"text","value":" DFS typically uses a stack (LIFO - Last In, First Out) to keep track of the path being explored. Nodes are added to the stack as you move deeper into the graph, and removed as you backtrack.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"eRhtIBEG17"}],"key":"Io6Jx68lzP"},{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"strong","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"Visited List:","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"pBzb4Il0V4"}],"key":"hWQqc04bvM"},{"type":"text","value":"  An additional data structure, like a visited list or array, is used to keep track of the nodes already explored and avoid revisiting them.","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"Uqu1i9cnRz"}],"key":"Lja3VkgNTU"}],"key":"JaLU7J8zy2"},{"type":"paragraph","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"strong","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"Applications of DFS:","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"tkZg8WDnLo"}],"key":"gLsFN3thNE"}],"key":"YRyRyUxFVe"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":17,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Finding paths in mazes or games.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"ZwhomS5Ros"}],"key":"TaUBwriAup"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Topological sorting (ordering a directed acyclic graph where each node has dependencies only on nodes preceding it in the order).","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"NzzgrnZWaW"}],"key":"ArcibXIZgZ"},{"type":"listItem","spread":true,"position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"text","value":"Cycle detection in graphs.","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"KyR3mWt5Nz"}],"key":"H4OuCj2sK1"},{"type":"listItem","spread":true,"position":{"start":{"line":20,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"Finding connected components in graphs (groups of nodes connected by edges).","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"wA3EZCt3D1"}],"key":"euEDParubA"}],"key":"gxk17P6ZyK"},{"type":"paragraph","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"children":[{"type":"strong","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"children":[{"type":"text","value":"Advantages and Disadvantages:","position":{"start":{"line":22,"column":1},"end":{"line":22,"column":1}},"key":"UYuErFWEwp"}],"key":"DOzkkLtV88"}],"key":"FDOm0PFgJt"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":24,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"strong","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"text","value":"Advantages:","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"kKQS5wgKO5"}],"key":"fT2AQiTWlr"},{"type":"text","value":" DFS can be efficient for certain graph structures and finding specific paths quickly.","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"itzpWUotqY"}],"key":"GsR6ex6O4m"},{"type":"listItem","spread":true,"position":{"start":{"line":25,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"strong","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"text","value":"Disadvantages:","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"JdveAfVz7N"}],"key":"V0dzV6ecC5"},{"type":"text","value":"  DFS might not be ideal for finding the shortest path between two nodes, and it can get stuck in infinite loops if there are cycles in the graph (without proper handling).","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"n4TBx4WMK0"}],"key":"JdtKbWZGph"}],"key":"m9RfDm5WBp"},{"type":"paragraph","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"strong","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"text","value":"Here are some resources for further learning:","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"key":"zwtqwzMvc5"}],"key":"rdi3oxK8qN"}],"key":"r3AuMhQujW"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":29,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"A visual explanation of DFS on graphs: YouTube video on Depth First Search: ","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"J0exTZlys9"},{"type":"link","url":"https://gemini.google.com/app/371acaa163b28c36","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"YouTube","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"gdbFJNxxFr"}],"urlSource":"https://gemini.google.com/app/371acaa163b28c36","key":"erEXTlIhtS"}],"key":"rtMyiyHOkG"},{"type":"listItem","spread":true,"position":{"start":{"line":30,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"text","value":"A step-by-step explanation of the DFS algorithm: ","position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"key":"kHcnW6ijQm"},{"type":"link","url":"https://www.programiz.com/dsa/graph-dfs","position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"text","value":"https://​www​.programiz​.com​/dsa​/graph​-dfs","position":{"start":{"line":30,"column":1},"end":{"line":30,"column":1}},"key":"LSaBloQNbn"}],"urlSource":"https://www.programiz.com/dsa/graph-dfs","key":"QzXQ3347Xt"}],"key":"eWBiIYVICq"}],"key":"MEmvsHU8xF"},{"type":"heading","depth":2,"position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"children":[{"type":"text","value":"Lecture Code","position":{"start":{"line":34,"column":1},"end":{"line":34,"column":1}},"key":"uLexiLuRtv"}],"identifier":"lecture-code","label":"Lecture Code","html_id":"lecture-code","implicit":true,"key":"FOtQNRsWyY"},{"type":"code","lang":"java","value":"import java.util.ArrayList;\nimport java.util.List;\n\nclass Node {\n  int data;\n  boolean visited;\n\n  public Node(int data) {\n    this.data = data;\n  }\n}\n\nclass Graph {\n  List<List<Node>> adjList;\n\n  public Graph(int vertices) {\n    adjList = new ArrayList<>(vertices);\n    for (int i = 0; i < vertices; i++) {\n      adjList.add(new ArrayList<>());\n    }\n  }\n\n  public void addEdge(int src, int dest) {\n    adjList.get(src).add(new Node(dest));\n  }\n\n  public void DFS(int startNode) {\n    boolean visited[] = new boolean[adjList.size()];\n    DFSUtil(startNode, visited);\n  }\n\n  private void DFSUtil(int node, boolean[] visited) {\n    visited[node] = true;\n    System.out.print(node + \" \");\n\n    // Visit all unvisited neighbors\n    for (Node neighbor : adjList.get(node)) {\n      if (!visited[neighbor.data]) {\n        DFSUtil(neighbor.data, visited);\n      }\n    }\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    int vertices = 6;\n    Graph graph = new Graph(vertices);\n\n    graph.addEdge(0, 1);\n    graph.addEdge(0, 2);\n    graph.addEdge(1, 2);\n    graph.addEdge(1, 3);\n    graph.addEdge(2, 3);\n    graph.addEdge(4, 5);\n\n    System.out.println(\"Depth First Traversal (starting from vertex 0)\");\n    \n    for(int i= 0; i < vertices; i++)\n    {\n        System.out.print(\"V = \" + i + \" : \");\n        graph.DFS(i);\n        System.out.println();\n    }\n  }\n}\n/*\nDepth First Traversal (starting from vertex 0)\nV = 0 : 0 1 2 3 \nV = 1 : 1 2 3 \nV = 2 : 2 3 \nV = 3 : 3 \nV = 4 : 4 5 \nV = 5 : 5 \n*/","position":{"start":{"line":36,"column":1},"end":{"line":112,"column":1}},"key":"iJ5NIiIduU"}],"key":"YRqvHrYoJA"}],"key":"VHctlGsSDp"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Seven Bridges of Königsberg","url":"/xgraphssevenbridges","group":"Algorithms"},"next":{"title":"Breadth First","url":"/xgraphsbfs","group":"Algorithms"}}},"domain":"http://localhost:3002"}