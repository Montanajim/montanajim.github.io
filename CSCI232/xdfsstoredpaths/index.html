<!DOCTYPE html><html lang="en" class="" style="scroll-padding:60px"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>DFS - Stored Paths - Algorithms</title><meta property="og:title" content="DFS - Stored Paths - Algorithms"/><meta name="generator" content="mystmd"/><meta name="keywords" content=""/><link rel="stylesheet" href="/CSCI232/build/_assets/app-2K3KGISG.css"/><link rel="stylesheet" href="/CSCI232/build/_assets/thebe-core-VKVHG5VY.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jupyter-matplotlib@0.11.3/css/mpl_widget.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"/><link rel="icon" href="/CSCI232/favicon.ico"/><link rel="stylesheet" href="/CSCI232/myst-theme.css"/><script>
  const savedTheme = localStorage.getItem("myst:theme");
  const theme = window.matchMedia("(prefers-color-scheme: light)").matches ? 'light' : 'dark';
  const classes = document.documentElement.classList;
  const hasAnyTheme = classes.contains('light') || classes.contains('dark');
  if (!hasAnyTheme) classes.add(savedTheme ?? theme);
</script></head><body class="m-0 transition-colors duration-500 bg-white dark:bg-stone-900"><div class="myst-skip-to-article fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1" aria-label="skip to content options"><a href="#skip-to-frontmatter" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article frontmatter</a><a href="#skip-to-article" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article content</a></div><dialog id="myst-no-css" style="position:fixed;left:0px;top:0px;width:100%;height:100vh;font-size:4rem;padding:1rem;color:black;background:white"><strong>Site not loading correctly?</strong><p>This may be due to an incorrect <code>BASE_URL</code> configuration. See<!-- --> <a href="https://mystmd.org/guide/deployment#deploy-base-url">the MyST Documentation</a> <!-- -->for reference.</p><script>
    (() => {
            // Test for has-styling variable set by the MyST stylesheet
            const node = document.currentScript.parentNode;
            const hasCSS = window.getComputedStyle(node).getPropertyValue("--has-styling");
            if (hasCSS === ""){
                    node.showModal();
            }

    })()
</script></dialog><div class="myst-top-nav bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 sticky w-full top-0 z-30 h-[60px]"><nav class="myst-top-nav-bar flex items-center justify-between flex-nowrap max-w-[1440px] mx-auto"><div class="flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center shrink-0"><div class="block xl:hidden"><button class="myst-top-nav-menu-button flex items-center justify-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100 w-10 h-10"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem"><path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd"></path></svg><span class="sr-only">Open Menu</span></button></div><a class="myst-home-link flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7" href="/CSCI232/"><span class="text-md sm:text-xl tracking-tight sm:mr-5">CSCI 211</span></a></div><div class="flex items-center flex-grow w-auto"><div class="flex-grow hidden text-md lg:block"></div><div class="flex-grow block"></div><button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R75cp:" data-state="closed" class="myst-search-bar flex items-center h-10 aspect-square sm:w-64 text-left text-gray-600 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 myst-search-bar-disabled hover:ring-blue-500 dark:hover:ring-blue-500 hover:border-blue-500 dark:hover:border-blue-500"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="p-2.5 h-10 w-10 aspect-square"><path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd"></path></svg><span class="myst-search-text-placeholder hidden sm:block grow">Search</span><div aria-hidden="true" class="myst-search-shortcut items-center hidden mx-1 font-mono text-sm text-gray-600 dark:text-gray-300 sm:flex gap-x-1"><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none hide-mac">CTRL</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none show-mac">⌘</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none ">K</kbd><script>
;(() => {
const script = document.currentScript;
const root = script.parentElement;

const isMac = /mac/i.test(
      window.navigator.userAgentData?.platform ?? window.navigator.userAgent,
    );
root.querySelectorAll(".hide-mac").forEach(node => {node.classList.add(isMac ? "hidden" : "block")});
root.querySelectorAll(".show-mac").forEach(node => {node.classList.add(!isMac ? "hidden" : "block")});
})()</script></div></button><button class="myst-theme-button theme rounded-full aspect-square border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 w-10 h-10 mx-3" title="Toggle theme between light and dark mode" aria-label="Toggle theme between light and dark mode"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-moon-icon h-full w-full p-0.5 hidden dark:block"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z" clip-rule="evenodd"></path></svg><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-sun-icon h-full w-full p-0.5 dark:hidden"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"></path></svg></button><div class="block sm:hidden"></div><div class="hidden sm:block"></div></div></nav></div><div class="myst-primary-sidebar fixed xl:article-grid grid-gap xl:w-full xl:pointer-events-none overflow-auto max-xl:w-[75vw] max-xl:max-w-[350px] max-xl:!top-0 max-xl:h-screen hidden z-10" style="top:60px"><div class="myst-primary-sidebar-pointer pointer-events-auto xl:col-margin-left flex-col overflow-hidden max-xl:h-full hidden xl:flex"><div class="myst-primary-sidebar-nav flex-grow py-6 overflow-y-auto primary-scrollbar"><nav aria-label="Navigation" class="myst-primary-sidebar-topnav overflow-y-hidden transition-opacity lg:hidden ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="w-full px-1 dark:text-white font-medium"></div></nav><div class="my-3 border-b-2 lg:hidden"></div><nav aria-label="Table of Contents" class="myst-primary-sidebar-toc flex-grow overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="myst-toc w-full px-1 dark:text-white"><a title="Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30 font-bold" href="/CSCI232/">Algorithms</a><a title="CSCI 232 Data Structures and Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xcsci232-intro">CSCI 232 Data Structures and Algorithms</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Terms and Concepts" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xterms">Terms and Concepts</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:Rupsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:Rupsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Binary Search Tree - Intro" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xbst-intro">Binary Search Tree - Intro</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R16psp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R16psp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Hash Table" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xhashing-hashtable">Hash Table</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1epsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1epsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="Skip List" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xskiplist">Skip List</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Graphs" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xgraphs">Graphs</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1upsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1upsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="Huffman Code" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xhuffmancode">Huffman Code</a><a title="Serialization" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xserializable">Serialization</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="JAVA Techniques" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xjavatechniques">JAVA Techniques</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R2mpsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R2mpsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="End" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xend">End</a></div></nav></div><div class="myst-primary-sidebar-footer flex-none py-6 transition-all duration-700 translate-y-6 opacity-0 ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="article footer myst-primary-sidebar-footer"><p>© 2026 by James Goudy</p></div></div></div></div><main class="article-grid grid-gap"><article class="article-grid subgrid-gap col-screen article content"><div class="hidden"></div><div id="skip-to-frontmatter" aria-label="article frontmatter" class="myst-fm-block mb-8 pt-9"><div class="myst-fm-block-header flex items-center mb-5 h-6 text-sm font-light"><div class="flex-grow"></div><div class="myst-fm-block-badges"><a href="https://github.com/executablebooks/jupyter-book" title="GitHub Repository: executablebooks/jupyter-book" target="_blank" rel="noopener noreferrer" class="myst-fm-github-link text-inherit hover:text-inherit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" width="1.25rem" height="1.25rem" class="myst-fm-github-icon inline-block mr-1 opacity-60 hover:opacity-100"><path d="M12 2.5c-5.4 0-9.8 4.4-9.8 9.7 0 4.3 2.8 8 6.7 9.2.5.1.7-.2.7-.5v-1.8c-2.4.5-3.1-.6-3.3-1.1-.1-.3-.6-1.1-1-1.4-.3-.2-.8-.6 0-.6s1.3.7 1.5 1c.9 1.5 2.3 1.1 2.8.8.1-.6.3-1.1.6-1.3-2.2-.2-4.4-1.1-4.4-4.8 0-1.1.4-1.9 1-2.6-.1-.2-.4-1.2.1-2.6 0 0 .8-.3 2.7 1 .8-.2 1.6-.3 2.4-.3.8 0 1.7.1 2.4.3 1.9-1.3 2.7-1 2.7-1 .5 1.3.2 2.3.1 2.6.6.7 1 1.5 1 2.6 0 3.7-2.3 4.6-4.4 4.8.4.3.7.9.7 1.8V21c0 .3.2.6.7.5 3.9-1.3 6.6-4.9 6.6-9.2 0-5.4-4.4-9.8-9.8-9.8z"></path></svg></a></div><div class="myst-fm-downloads-dropdown relative flex inline-block mx-1 grow-0" data-headlessui-state=""><button class="myst-fm-downloads-button relative ml-2 -mr-1" id="headlessui-menu-button-:Rs8ucp:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Downloads</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.25rem" height="1.25rem" class="myst-fm-downloads-icon"><title>Download</title><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"></path></svg></button></div></div><h1 class="myst-fm-block-title mb-0">DFS - Stored Paths</h1><header class="myst-fm-authors-affiliations mt-4 not-prose"><div class="myst-fm-authors-list"><span class="myst-fm-author font-semibold text-sm myst-fm-author-item inline-block"><button class="myst-fm-author-popover focus:shadow-[0_0_0_2px] focus:shadow-black outline-none hover:underline" aria-label="Author Details" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R78ucp:" data-state="closed"><span class="myst-fm-author-name">James Goudy</span></button></span></div></header></div><div class="block my-10 lg:sticky lg:z-10 lg:h-0 lg:pt-0 lg:my-0 lg:ml-10 lg:col-margin-right" style="top:60px"><nav></nav></div><div id="skip-to-article"></div><p>This Java code defines a <code>DFS</code> class that implements Depth-First Search for an undirected graph represented using an adjacency list. It provides standard DFS traversal methods (both recursive and iterative) that print the visited node order, as well as specialized methods (also recursive and iterative) designed to find and store all possible paths starting from a given source vertex discovered during the DFS exploration. The <code>Main</code> class demonstrates how to create a graph, add edges, and utilize both the traversal and path-finding functionalities provided by the <code>DFS</code> class.</p><p>Java</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Stack;

class DFS {

    // Num Vertices
    private final int numVertices;

    // Adjacency list to store edges
    public final List&lt;LinkedList&lt;Integer&gt;&gt; adjencyList;

    // List to store all paths found by the last DFS run
    private List&lt;List&lt;Integer&gt;&gt; allPaths;

    // Constructor
    public DFS(int vertices) {
        this.numVertices = vertices;
        this.adjencyList = new ArrayList&lt;&gt;(vertices);
        this.allPaths = new ArrayList&lt;&gt;(); // Initialize the path list

        for (int i = 0; i &lt; vertices; i++) {
            this.adjencyList.add(new LinkedList&lt;&gt;());
        }
    }

    // Add edges (undirected graph)
    public void addEdge(int source, int destination) {
        // Ensure vertices are within bounds
        if (source &lt; 0 || source &gt;= numVertices || destination &lt; 0 || destination &gt;= numVertices) {
            System.err.println(&quot;Warning: Vertex index out of bounds. Edge not added.&quot;);
            return;
        }
        adjencyList.get(source).add(destination);
        adjencyList.get(destination).add(source); // For undirected graph
    }

    // --- Recursive DFS Path Finding ---

    /**
     * Finds all paths starting from startVertex using recursive DFS.
     * Stores the paths in the allPaths list.
     *
     * @param startVertex The vertex to start the search from.
     */
    public void findAllPathsRecursive(int startVertex) {
        if (startVertex &lt; 0 || startVertex &gt;= numVertices) {
             System.err.println(&quot;Error: Start vertex out of bounds.&quot;);
             return;
        }
        boolean[] visited = new boolean[numVertices];
        this.allPaths = new ArrayList&lt;&gt;(); // Reset paths for new search
        List&lt;Integer&gt; currentPath = new ArrayList&lt;&gt;();

        System.out.println(&quot;\nFinding all paths (Recursive DFS) starting from vertex &quot; + startVertex + &quot;:&quot;);
        findAllPathsRecursiveUtil(startVertex, visited, currentPath);
    }

    /**
     * Recursive helper function for DFS path finding.
     *
     * @param vertex      The current vertex being visited.
     * @param visited     Array to keep track of visited nodes in the current recursion path.
     * @param currentPath The path taken to reach the current vertex.
     */
    private void findAllPathsRecursiveUtil(int vertex, boolean[] visited, List&lt;Integer&gt; currentPath) {
        // Mark the current node as visited and add it to the path
        visited[vertex] = true;
        currentPath.add(vertex);

        // Store a copy of the current path
        // This captures the path to the *current* vertex
        allPaths.add(new ArrayList&lt;&gt;(currentPath));
        // System.out.println(&quot;Path found: &quot; + currentPath); // Optional: print paths as they are found

        // Recur for all adjacent vertices
        for (int neighbor : adjencyList.get(vertex)) {
            if (!visited[neighbor]) {
                findAllPathsRecursiveUtil(neighbor, visited, currentPath);
            }
        }

        // Backtrack: remove current vertex from path and mark as unvisited
        // for other potential paths.
        currentPath.remove(currentPath.size() - 1);
        visited[vertex] = false;
    }


    // --- Iterative DFS Path Finding ---

     /**
      * Finds paths using iterative DFS and stores them.
      * This version uses a stack storing pairs of (node, path_to_node).
      * Note: The order of path discovery might differ from the recursive version.
      *
      * @param startVertex The vertex to start the search from.
      */
    public void findAllPathsIterative(int startVertex) {
         if (startVertex &lt; 0 || startVertex &gt;= numVertices) {
             System.err.println(&quot;Error: Start vertex out of bounds.&quot;);
             return;
         }
         this.allPaths = new ArrayList&lt;&gt;(); // Reset paths
         System.out.println(&quot;\nFinding all paths (Iterative DFS) starting from vertex &quot; + startVertex + &quot;:&quot;);

         // Stack stores pairs: the node and the path to reach it
         Stack&lt;Pair&lt;Integer, List&lt;Integer&gt;&gt;&gt; stack = new Stack&lt;&gt;();

         // Initial path contains only the start vertex
         List&lt;Integer&gt; initialPath = new ArrayList&lt;&gt;();
         initialPath.add(startVertex);
         stack.push(new Pair&lt;&gt;(startVertex, initialPath));

         // Keep track of visited nodes *globally* across different path explorations
         // This prevents infinite loops in cyclic graphs and redundant processing.
         boolean[] globallyVisited = new boolean[numVertices];


         while (!stack.isEmpty()) {
             Pair&lt;Integer, List&lt;Integer&gt;&gt; currentPair = stack.pop();
             int currentVertex = currentPair.getKey();
             List&lt;Integer&gt; currentPath = currentPair.getValue();

             // If we haven&#x27;t processed this node *through this specific path expansion*
             // Mark it visited *globally* only after processing its path.
             // This allows finding different paths to the same node, but standard
             // iterative DFS usually uses a simpler visited check.
             // For simplicity matching the recursive intent, let&#x27;s only proceed
             // if the node hasn&#x27;t been the *end* of a stored path yet.
             // A better approach might be needed for complex path requirements.

             // Store the path found to this vertex
             allPaths.add(new ArrayList&lt;&gt;(currentPath)); // Store a copy
             // System.out.println(&quot;Path found: &quot; + currentPath); // Optional: print


             if (!globallyVisited[currentVertex]) {
                 globallyVisited[currentVertex] = true; // Mark globally visited

                  // Explore neighbors
                 // Iterate in reverse to mimic recursive DFS neighbor order more closely (optional)
                 List&lt;Integer&gt; neighbors = adjencyList.get(currentVertex);
                 // Collections.reverse(neighbors); // Uncomment to push neighbors in reverse order

                 for (int neighbor : neighbors) {
                     // Check if the neighbor is already in the *current* path to avoid cycles within a single path
                     boolean visitedInCurrentPath = false;
                     for(int nodeInPath : currentPath) {
                         if (nodeInPath == neighbor) {
                             visitedInCurrentPath = true;
                             break;
                         }
                     }

                     // If the neighbor hasn&#x27;t been visited *in this specific path*
                     if (!visitedInCurrentPath) {
                         List&lt;Integer&gt; newPath = new ArrayList&lt;&gt;(currentPath);
                         newPath.add(neighbor);
                         stack.push(new Pair&lt;&gt;(neighbor, newPath));
                     }
                 }
                 // Collections.reverse(neighbors); // Reverse back if reversed earlier
             }
         }
     }


    // --- Original Traversal Methods (for comparison/demonstration) ---

    /**
     * Performs the original iterative DFS traversal, printing nodes as visited.
     * Does not store paths.
     * @param startVertex The vertex to start from.
     */
    public void performDFSTraversalIterative(int startVertex) {
        if (startVertex &lt; 0 || startVertex &gt;= numVertices) {
            System.err.println(&quot;Error: Start vertex out of bounds.&quot;);
            return;
        }
        boolean[] visited = new boolean[numVertices];
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // Use Stack&#x27;s push/pop for LIFO (DFS)

        visited[startVertex] = true;
        stack.push(startVertex); // Push onto stack

        System.out.println(&quot;\nDFS Traversal Order (Iterative): starting from &quot; + startVertex + &quot; &quot;);

        while (!stack.isEmpty()) {
            int currentVertex = stack.pop(); // Pop from stack (LIFO)
            System.out.print(currentVertex + &quot; &quot;);

            // Get neighbors and push unvisited ones onto the stack
            // Process neighbors in natural order (or reverse to mimic recursion)
            List&lt;Integer&gt; neighbors = adjencyList.get(currentVertex);
             // Collections.reverse(neighbors); // To more closely match typical recursive order

            for (int neighbor : neighbors) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    stack.push(neighbor);
                }
            }
             // Collections.reverse(neighbors); // Reverse back if needed
        }
        System.out.println();
    }

     /**
     * Performs the original recursive DFS traversal, printing nodes as visited.
     * Does not store paths.
     * @param startVertex The vertex to start from.
     */
    public void performDFSTraversalRecursive(int startVertex) {
         if (startVertex &lt; 0 || startVertex &gt;= numVertices) {
             System.err.println(&quot;Error: Start vertex out of bounds.&quot;);
             return;
         }
        boolean[] visited = new boolean[numVertices];
        System.out.println(&quot;\nDFS Traversal Order (Recursive) starting from vertex &quot; + startVertex + &quot;:&quot;);
        performDFSTraversalRecursiveUtil(startVertex, visited);
        System.out.println();
    }

    private void performDFSTraversalRecursiveUtil(int vertex, boolean[] visited) {
        visited[vertex] = true;
        System.out.print(vertex + &quot; &quot;);

        for (int neighbor : adjencyList.get(vertex)) {
            if (!visited[neighbor]) {
                performDFSTraversalRecursiveUtil(neighbor, visited);
            }
        }
    }

    // --- Utility ---

    /**
     * Returns the list of paths found by the last pathfinding call.
     * @return A list where each element is a list of integers representing a path.
     */
    public List&lt;List&lt;Integer&gt;&gt; getAllPaths() {
        return allPaths;
    }

     /**
      * Prints all stored paths.
      */
     public void printAllPaths() {
         if (allPaths == null || allPaths.isEmpty()) {
             System.out.println(&quot;No paths have been generated or stored yet.&quot;);
             return;
         }
         System.out.println(&quot;\n--- Stored Paths ---&quot;);
         int pathNum = 1;
         for (List&lt;Integer&gt; path : allPaths) {
             System.out.println(&quot;Path &quot; + (pathNum++) + &quot;: &quot; + path);
         }
         System.out.println(&quot;--------------------&quot;);
     }

     // Simple generic Pair class (or use javafx.util.Pair if available/allowed)
     private static class Pair&lt;K, V&gt; {
         private final K key;
         private final V value;

         public Pair(K key, V value) {
             this.key = key;
             this.value = value;
         }

         public K getKey() { return key; }
         public V getValue() { return value; }
     }
}

class Main {

    public static void main(String[] args) {

        DFS graph = new DFS(12);

        // Build the graph
        graph.addEdge(0, 1);
        graph.addEdge(0, 2);
        graph.addEdge(1, 3);
        graph.addEdge(2, 4);
        graph.addEdge(4, 5);
        graph.addEdge(0, 6); // 0 -&gt; 6
        graph.addEdge(0, 7); // 0 -&gt; 7
        graph.addEdge(7, 8); // 7 -&gt; 8
        graph.addEdge(7, 9); // 7 -&gt; 9
        graph.addEdge(9, 10); // 9 -&gt; 10
        graph.addEdge(5, 11); // 5 -&gt; 11

        // Print Adjacency List (for verification)
        System.out.println(&quot;--- Adjacency List ---&quot;);
        for (int i = 0; i &lt; graph.adjencyList.size(); i++) {
            System.out.println(&quot;Vertex &quot; + i + &quot;: &quot; + graph.adjencyList.get(i));
        }
         System.out.println(&quot;----------------------&quot;);

        // --- Demonstrate Original Traversals ---
        graph.performDFSTraversalIterative(0);
        graph.performDFSTraversalRecursive(0);

        // --- Find and Store Paths (Recursive) ---
        graph.findAllPathsRecursive(0);
        // Print the paths found by the recursive method
        graph.printAllPaths();

        // --- Find and Store Paths (Iterative) ---
        graph.findAllPathsIterative(0);
         // Print the paths found by the iterative method
         // Note: The order and exact paths might differ slightly depending on implementation details
         graph.printAllPaths();

         // Example: Get paths and process them
         System.out.println(&quot;\nAccessing paths manually after iterative search:&quot;);
         List&lt;List&lt;Integer&gt;&gt; storedPaths = graph.getAllPaths();
         if (storedPaths != null &amp;&amp; !storedPaths.isEmpty()) {
             System.out.println(&quot;Total paths found: &quot; + storedPaths.size());
             System.out.println(&quot;First path found: &quot; + storedPaths.get(0));
             System.out.println(&quot;Last path found: &quot; + storedPaths.get(storedPaths.size() - 1));
         }
    }
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>This code defines a <code>DFS</code> class that represents a graph and provides methods for performing Depth-First Search (DFS) operations on it. It specifically includes implementations for:</p><ol start="1"><li><strong>Standard DFS Traversal (Recursive &amp; Iterative):</strong> These methods visit nodes in DFS order and typically print them, primarily demonstrating the traversal algorithm itself.</li><li><strong>Finding All Paths via DFS (Recursive &amp; Iterative):</strong> These are more complex methods designed to find and store <em>all</em> possible paths starting from a given vertex that can be discovered through a DFS exploration.</li></ol><p>Here’s a breakdown of the components:</p><p><strong><code>DFS</code> Class:</strong></p><ol start="1"><li><p><strong>Fields:</strong></p><ul><li><code>numVertices</code>: An integer storing the number of vertices in the graph.</li><li><code>adjencyList</code>: A <code>List&lt;LinkedList&lt;Integer&gt;&gt;</code>. This is the core graph representation using an <strong>adjacency list</strong>. The outer list has an index for each vertex (0 to <code>numVertices - 1</code>). The <code>LinkedList</code> at each index <code>i</code> stores the vertices directly connected (adjacent) to vertex <code>i</code>.</li><li><code>allPaths</code>: A <code>List&lt;List&lt;Integer&gt;&gt;</code>. This list is used to store the results of the path-finding operations (<code>findAllPathsRecursive</code> or <code>findAllPathsIterative</code>). Each element within <code>allPaths</code> is itself a <code>List&lt;Integer&gt;</code> representing a single path found.</li></ul></li><li><p><strong>Constructor (<code>DFS(int vertices)</code>):</strong></p><ul><li>Initializes the graph with a specified number of vertices.</li><li>Creates the <code>adjencyList</code> structure, adding an empty <code>LinkedList</code> for each vertex.</li><li>Initializes the <code>allPaths</code> list.</li></ul></li><li><p><strong><code>addEdge(int source, int destination)</code>:</strong></p><ul><li>Adds an edge between the <code>source</code> vertex and the <code>destination</code> vertex.</li><li>Includes basic error checking to ensure vertex indices are valid.</li><li>Adds <code>destination</code> to <code>source</code>’s list and <code>source</code> to <code>destination</code>’s list. This makes the graph <strong>undirected</strong> (an edge exists in both directions).</li></ul></li><li><p><strong>Recursive Path Finding (<code>findAllPathsRecursive</code> and <code>findAllPathsRecursiveUtil</code>):</strong></p><ul><li><p><code>findAllPathsRecursive(startVertex)</code>: The public method to initiate the search. It sets up a <code>visited</code> array (local to the current path exploration) and resets the <code>allPaths</code> list before calling the helper function.</p></li><li><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-text" style="white-space:pre">findAllPathsRecursiveUtil(vertex, visited, currentPath)</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>:</p><ul><li>This is the core recursive logic.</li><li>It marks the current <code>vertex</code> as visited <em>for the current path exploration</em>.</li><li>Adds the <code>vertex</code> to the <code>currentPath</code>.</li><li><strong>Crucially:</strong> It adds a <em>copy</em> of the <code>currentPath</code> (up to the current <code>vertex</code>) to the <code>allPaths</code> list. This means every node encountered during the DFS becomes the end of a stored path.</li><li>It iterates through the neighbors of the current <code>vertex</code>. If a neighbor hasn’t been visited <em>in the current recursive call stack</em>, it recursively calls itself for that neighbor.</li><li><strong>Backtracking:</strong> After exploring all paths stemming from the current <code>vertex</code>, it removes the <code>vertex</code> from <code>currentPath</code> and marks it as unvisited (<code>visited[vertex] = false</code>). This is essential to allow the algorithm to explore <em>other</em> paths that might reach this <code>vertex</code> through a different sequence.</li></ul></li></ul></li><li><p><strong>Iterative Path Finding (<code>findAllPathsIterative</code>):</strong></p><ul><li><p>This method attempts to find all paths using an iterative approach with a <code>Stack</code>.</p></li><li><p>It uses a</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-text" style="white-space:pre">Stack</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>where each element is a</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-text" style="white-space:pre">Pair</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>containing:</p><ul><li>The current vertex (<code>Integer</code>).</li><li>The path (<code>List&lt;Integer&gt;</code>) taken to reach that vertex.</li></ul></li><li><p>It also uses a</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-text" style="white-space:pre">globallyVisited</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>array. The logic here is slightly different from the recursive version’s</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-text" style="white-space:pre">visited</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><p>array:</p><ul><li>It adds the path to <code>allPaths</code> <em>when</em> a <code>Pair</code> is popped from the stack.</li><li>It checks <code>globallyVisited</code> <em>after</em> storing the path. If the node hasn’t been globally visited yet, it marks it and explores its neighbors.</li><li>When exploring neighbors, it checks if the neighbor is already present in the <em>current specific path</em> (<code>visitedInCurrentPath</code> loop) to prevent cycles <em>within that single path</em>.</li><li>If a neighbor is valid (not creating a cycle in the current path), a new path is created by extending the current one, and a new <code>Pair</code> is pushed onto the stack.</li></ul></li><li><p><strong>Note:</strong> The use of <code>globallyVisited</code> prevents re-exploring <em>from</em> a node once <em>any</em> path ending there has been processed. This helps avoid infinite loops in cyclic graphs but might prune some paths compared to a pure recursive backtracking approach if the goal was <em>all simple paths</em>. The order of paths found might also differ from the recursive version due to stack LIFO order and neighbor processing order.</p></li></ul></li><li><p><strong>Standard Traversal Methods (<code>performDFSTraversalIterative</code>, <code>performDFSTraversalRecursive</code>, <code>performDFSTraversalRecursiveUtil</code>):</strong></p><ul><li>These implement the more “standard” DFS algorithm where the goal is just to visit each reachable node once.</li><li>They use a <code>visited</code> array to keep track of nodes already visited during the <em>entire</em> traversal.</li><li>They print the vertex when it’s visited (recursive) or popped (iterative).</li><li>They do <strong>not</strong> store paths.</li></ul></li><li><p><strong>Utility Methods:</strong></p><ul><li><code>getAllPaths()</code>: Returns the <code>allPaths</code> list (containing results from the last path-finding call).</li><li><code>printAllPaths()</code>: Prints all the paths currently stored in the <code>allPaths</code> list in a readable format.</li><li><code>Pair&lt;K, V&gt;</code>: A simple private static inner class to hold pairs of objects (used in the iterative path finding).</li></ul></li></ol><p><strong><code>Main</code> Class:</strong></p><ul><li>Creates an instance of the <code>DFS</code> graph with 12 vertices.</li><li>Adds edges to define the graph structure.</li><li>Prints the adjacency list to show the graph’s structure.</li><li>Demonstrates the standard iterative and recursive DFS <em>traversals</em>, printing the order nodes are visited.</li><li>Calls <code>findAllPathsRecursive(0)</code> to find paths starting from vertex 0 using recursion and prints the results.</li><li>Calls <code>findAllPathsIterative(0)</code> to find paths starting from vertex 0 using iteration and prints those results.</li><li>Shows how to retrieve the list of paths using <code>getAllPaths()</code> after a search.</li></ul><p>In essence, this code provides a robust <code>DFS</code> class for undirected graphs, offering both standard traversal and more complex path-finding capabilities, implemented recursively and iteratively.</p><div class="myst-backmatter-parts"></div><div class="myst-footer-links flex pt-10 mb-10 space-x-4"><a class="myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700 myst-footer-link-prev" href="/CSCI232/xgraphsbfs"><div class="flex h-full align-middle"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="myst-footer-link-icon self-center transition-transform group-hover:-translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"></path></svg><div class="flex-grow text-right"><div class="myst-footer-link-group text-xs text-gray-500 dark:text-gray-400">Algorithms</div>Breadth First</div></div></a><a class="myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700 myst-footer-link-next" href="/CSCI232/xgraphsmazesolverdfs"><div class="flex h-full align-middle"><div class="flex-grow"><div class="myst-footer-link-group text-xs text-gray-500 dark:text-gray-400">Algorithms</div>DSF - Maze Solving</div><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="myst-footer-link-icon self-center transition-transform group-hover:translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"></path></svg></div></a></div></article></main><script>((a,l)=>{if(!window.history.state||!window.history.state.key){let u=Math.random().toString(32).slice(2);window.history.replaceState({key:u},"")}try{let d=JSON.parse(sessionStorage.getItem(a)||"{}")[l||window.history.state.key];typeof d=="number"&&window.scrollTo(0,d)}catch(u){console.error(u),sessionStorage.removeItem(a)}})("positions", null)</script><link rel="modulepreload" href="/CSCI232/build/entry.client-PCJPW7TK.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-AQ2CODAG.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-JJXTQVMA.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-OZE3FFNP.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-G62B6HZR.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-C4DFGG5C.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-J7TUH54J.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-FZ2S7OYD.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-JEM6JXYA.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-34XIY2DH.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-KQM5FBHR.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-OCWQY3HK.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-7HNKBP4B.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-CUKUDK3R.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-3EBOCCHJ.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-O4VQNZ62.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-4OEDG4JQ.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-GUCIBHGO.js"/><link rel="modulepreload" href="/CSCI232/build/root-PMP5BIHC.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-IX5KPAHP.js"/><link rel="modulepreload" href="/CSCI232/build/routes/$-5ZLZ2O3Y.js"/><script>window.__remixContext = {"url":"/xdfsstoredpaths","state":{"loaderData":{"root":{"config":{"version":2,"myst":"1.6.0","options":{"logo_text":"CSCI 211","folders":true},"parts":{"primary_sidebar_footer":{"mdast":{"type":"root","children":[{"type":"block","data":{"part":"primary_sidebar_footer"},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"© 2026 by James Goudy","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JNqyZV4dE3"}],"key":"rHtYhRJkF4"}],"key":"Q6hsjbFdwJ"}],"key":"bEhouLfs9N"},"frontmatter":{"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024"}}},"nav":[],"actions":[],"projects":[{"bibliography":["C:\\a_books\\CSCI232_algobook\\references.bib"],"exports":[],"title":"Algorithms","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","toc":[{"file":"intro.md"},{"file":"xCSCI232_Intro.md"},{"children":[{"file":"xTerms_Radix.md"},{"file":"xTerms_Serializable.md"},{"file":"xTerms_Iterator.md"}],"file":"xTerms.md"},{"children":[{"file":"xBST_Applications.md"},{"file":"xBST_Comparisons.md"},{"file":"xBST_TreeTraversal.md"},{"file":"xBST_Iterative_Recursion_Search.md"},{"file":"xBST_BinarySearchTree.md"},{"file":"xBST_AVLTree.md"},{"file":"xBST_RedBlack.md"},{"file":"xBST_ComparisionTable.md"},{"file":"xBST_SplayTrees_2025.md"}],"file":"xBST_Intro.md"},{"children":[{"file":"xHashing_UnderstandingHashTables.md"},{"file":"xHashing_ModulusHashFunction.md"},{"file":"xHashing_Chaining.md"},{"file":"xHashing_OpenAddressing.md"},{"file":"xHashing_OpenAddressingHashingCodeExamples.md"}],"file":"xHashing_HashTable.md"},{"file":"xSkipList.md"},{"children":[{"file":"xGraphsAnalysisOfBFSandDFS.md"},{"file":"xUnderstandingBFS_202504.md"},{"file":"xUnderstandingDFS_202504.md"},{"file":"xGraphsSevenBridges.md"},{"file":"xGraphsDFS.md"},{"file":"xGraphsBFS.md"},{"file":"xDFSStoredPaths.md"},{"file":"xGraphsMazeSolverDFS.md"},{"file":"xGraphsDijkstra.md"}],"file":"xGraphs.md"},{"file":"xHuffmanCode.md"},{"file":"xSerializable.md"},{"children":[{"file":"xJavaHashMapTreeMapLinkedHashMap.md"},{"file":"xHashSetLinkedHashSetTreeSetComparision.md"},{"file":"xProgrammingToTheInterfacemd.md"}],"file":"xJAVATechniques.md"},{"file":"xEnd.md"}],"index":"index","pages":[{"slug":"xcsci232-intro","title":"CSCI 232 Data Structures and Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms","title":"Terms and Concepts","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms-radix","title":"Radix - Number Bases","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-serializable","title":"Serializable","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-iterator","title":"Iterator","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-intro","title":"Binary Search Tree - Intro","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbst-applications","title":"Applications That Use Binary Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisons","title":"Binary Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-treetraversal","title":"Tree Traversal","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-iterative-recursion-search","title":"Demonstrate BST using iterative looping and recursion","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-binarysearchtree","title":"Binary Search Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-avltree","title":"AVL Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-redblack","title":"Red Black Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisiontable","title":"BST AVL Red Black Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-splaytrees-2025","title":"Splay Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-hashtable","title":"Hash Table","description":"","date":"","thumbnail":"/CSCI232/build/f694c399ae1cdea2e011d1ecd6ed8d9d.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xhashing-understandinghashtables","title":"Understanding Hash Tables and Hash Functions*","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-modulushashfunction","title":"Modulus Hash Function","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-chaining","title":"Hash Tables - Chaining","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressing","title":"Hash Table - Open Addressing","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressinghashingcodeexamples","title":"Java code for double hashing in a hash table:","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xskiplist","title":"Skip List","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphs","title":"Graphs","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphsanalysisofbfsanddfs","title":"A Comparative Analysis of Breadth-First Search and Depth-First Search Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingbfs-202504","title":"Understanding Breadth-First Search (BFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingdfs-202504","title":"Understanding Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphssevenbridges","title":"Seven Bridges of Königsberg","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdfs","title":"Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsbfs","title":"Breadth First","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdfsstoredpaths","title":"DFS - Stored Paths","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsmazesolverdfs","title":"DSF - Maze Solving","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdijkstra","title":"Dijkstra’s Algorithm","description":"","date":"","thumbnail":"/CSCI232/build/dijkstra_example-8cca3c2c620cd1d44d2c9745b698d02d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhuffmancode","title":"Huffman Code","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xserializable","title":"Serialization","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavatechniques","title":"JAVA Techniques","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavahashmaptreemaplinkedhashmap","title":"Examples of Java’s HashMap, TreeMap, and LinkedHashMap","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashsetlinkedhashsettreesetcomparision","title":"HashSet, LinkedHashSet, and TreeSet Comparision","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xprogrammingtotheinterfacemd","title":"Programming To The Interface, Not The Implementation\"","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}]},"CONTENT_CDN_PORT":"3100","MODE":"static","BASE_URL":"/CSCI232"},"routes/$":{"config":{"version":2,"myst":"1.6.0","options":{"logo_text":"CSCI 211","folders":true},"parts":{"primary_sidebar_footer":{"mdast":{"type":"root","children":[{"type":"block","data":{"part":"primary_sidebar_footer"},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"© 2026 by James Goudy","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JNqyZV4dE3"}],"key":"rHtYhRJkF4"}],"key":"Q6hsjbFdwJ"}],"key":"bEhouLfs9N"},"frontmatter":{"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024"}}},"nav":[],"actions":[],"projects":[{"bibliography":["C:\\a_books\\CSCI232_algobook\\references.bib"],"exports":[],"title":"Algorithms","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","toc":[{"file":"intro.md"},{"file":"xCSCI232_Intro.md"},{"children":[{"file":"xTerms_Radix.md"},{"file":"xTerms_Serializable.md"},{"file":"xTerms_Iterator.md"}],"file":"xTerms.md"},{"children":[{"file":"xBST_Applications.md"},{"file":"xBST_Comparisons.md"},{"file":"xBST_TreeTraversal.md"},{"file":"xBST_Iterative_Recursion_Search.md"},{"file":"xBST_BinarySearchTree.md"},{"file":"xBST_AVLTree.md"},{"file":"xBST_RedBlack.md"},{"file":"xBST_ComparisionTable.md"},{"file":"xBST_SplayTrees_2025.md"}],"file":"xBST_Intro.md"},{"children":[{"file":"xHashing_UnderstandingHashTables.md"},{"file":"xHashing_ModulusHashFunction.md"},{"file":"xHashing_Chaining.md"},{"file":"xHashing_OpenAddressing.md"},{"file":"xHashing_OpenAddressingHashingCodeExamples.md"}],"file":"xHashing_HashTable.md"},{"file":"xSkipList.md"},{"children":[{"file":"xGraphsAnalysisOfBFSandDFS.md"},{"file":"xUnderstandingBFS_202504.md"},{"file":"xUnderstandingDFS_202504.md"},{"file":"xGraphsSevenBridges.md"},{"file":"xGraphsDFS.md"},{"file":"xGraphsBFS.md"},{"file":"xDFSStoredPaths.md"},{"file":"xGraphsMazeSolverDFS.md"},{"file":"xGraphsDijkstra.md"}],"file":"xGraphs.md"},{"file":"xHuffmanCode.md"},{"file":"xSerializable.md"},{"children":[{"file":"xJavaHashMapTreeMapLinkedHashMap.md"},{"file":"xHashSetLinkedHashSetTreeSetComparision.md"},{"file":"xProgrammingToTheInterfacemd.md"}],"file":"xJAVATechniques.md"},{"file":"xEnd.md"}],"index":"index","pages":[{"slug":"xcsci232-intro","title":"CSCI 232 Data Structures and Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms","title":"Terms and Concepts","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms-radix","title":"Radix - Number Bases","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-serializable","title":"Serializable","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-iterator","title":"Iterator","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-intro","title":"Binary Search Tree - Intro","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbst-applications","title":"Applications That Use Binary Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisons","title":"Binary Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-treetraversal","title":"Tree Traversal","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-iterative-recursion-search","title":"Demonstrate BST using iterative looping and recursion","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-binarysearchtree","title":"Binary Search Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-avltree","title":"AVL Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-redblack","title":"Red Black Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisiontable","title":"BST AVL Red Black Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-splaytrees-2025","title":"Splay Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-hashtable","title":"Hash Table","description":"","date":"","thumbnail":"/CSCI232/build/f694c399ae1cdea2e011d1ecd6ed8d9d.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xhashing-understandinghashtables","title":"Understanding Hash Tables and Hash Functions*","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-modulushashfunction","title":"Modulus Hash Function","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-chaining","title":"Hash Tables - Chaining","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressing","title":"Hash Table - Open Addressing","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressinghashingcodeexamples","title":"Java code for double hashing in a hash table:","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xskiplist","title":"Skip List","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphs","title":"Graphs","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphsanalysisofbfsanddfs","title":"A Comparative Analysis of Breadth-First Search and Depth-First Search Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingbfs-202504","title":"Understanding Breadth-First Search (BFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingdfs-202504","title":"Understanding Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphssevenbridges","title":"Seven Bridges of Königsberg","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdfs","title":"Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsbfs","title":"Breadth First","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdfsstoredpaths","title":"DFS - Stored Paths","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsmazesolverdfs","title":"DSF - Maze Solving","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdijkstra","title":"Dijkstra’s Algorithm","description":"","date":"","thumbnail":"/CSCI232/build/dijkstra_example-8cca3c2c620cd1d44d2c9745b698d02d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhuffmancode","title":"Huffman Code","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xserializable","title":"Serialization","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavatechniques","title":"JAVA Techniques","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavahashmaptreemaplinkedhashmap","title":"Examples of Java’s HashMap, TreeMap, and LinkedHashMap","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashsetlinkedhashsettreesetcomparision","title":"HashSet, LinkedHashSet, and TreeSet Comparision","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xprogrammingtotheinterfacemd","title":"Programming To The Interface, Not The Implementation\"","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}]},"page":{"version":3,"kind":"Article","sha256":"205ae65ee439b687ba42d2e29f1b30a02ad8ea1b40761f761105e75857188ec8","slug":"xdfsstoredpaths","location":"/xDFSStoredPaths.md","dependencies":[],"frontmatter":{"title":"DFS - Stored Paths","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xDFSStoredPaths.md","url":"/CSCI232/build/xDFSStoredPaths-8f891a8fd6ca6378a610067913efc489.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"This Java code defines a ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"hcilnWBO6S"},{"type":"inlineCode","value":"DFS","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"zHHc6e6OHm"},{"type":"text","value":" class that implements Depth-First Search for an undirected graph represented using an adjacency list. It provides standard DFS traversal methods (both recursive and iterative) that print the visited node order, as well as specialized methods (also recursive and iterative) designed to find and store all possible paths starting from a given source vertex discovered during the DFS exploration. The ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"nwqBzzi0n1"},{"type":"inlineCode","value":"Main","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"Yx5fVOfgJ6"},{"type":"text","value":" class demonstrates how to create a graph, add edges, and utilize both the traversal and path-finding functionalities provided by the ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"wDenYeNDyO"},{"type":"inlineCode","value":"DFS","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"OYtTMI5taJ"},{"type":"text","value":" class.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"Mzbq7sLno6"}],"key":"USlULoYOX1"},{"type":"paragraph","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Java","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"BWAoqw9nP5"}],"key":"a0Euc2cTCN"},{"type":"code","lang":"java","value":"import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\n\nclass DFS {\n\n    // Num Vertices\n    private final int numVertices;\n\n    // Adjacency list to store edges\n    public final List\u003cLinkedList\u003cInteger\u003e\u003e adjencyList;\n\n    // List to store all paths found by the last DFS run\n    private List\u003cList\u003cInteger\u003e\u003e allPaths;\n\n    // Constructor\n    public DFS(int vertices) {\n        this.numVertices = vertices;\n        this.adjencyList = new ArrayList\u003c\u003e(vertices);\n        this.allPaths = new ArrayList\u003c\u003e(); // Initialize the path list\n\n        for (int i = 0; i \u003c vertices; i++) {\n            this.adjencyList.add(new LinkedList\u003c\u003e());\n        }\n    }\n\n    // Add edges (undirected graph)\n    public void addEdge(int source, int destination) {\n        // Ensure vertices are within bounds\n        if (source \u003c 0 || source \u003e= numVertices || destination \u003c 0 || destination \u003e= numVertices) {\n            System.err.println(\"Warning: Vertex index out of bounds. Edge not added.\");\n            return;\n        }\n        adjencyList.get(source).add(destination);\n        adjencyList.get(destination).add(source); // For undirected graph\n    }\n\n    // --- Recursive DFS Path Finding ---\n\n    /**\n     * Finds all paths starting from startVertex using recursive DFS.\n     * Stores the paths in the allPaths list.\n     *\n     * @param startVertex The vertex to start the search from.\n     */\n    public void findAllPathsRecursive(int startVertex) {\n        if (startVertex \u003c 0 || startVertex \u003e= numVertices) {\n             System.err.println(\"Error: Start vertex out of bounds.\");\n             return;\n        }\n        boolean[] visited = new boolean[numVertices];\n        this.allPaths = new ArrayList\u003c\u003e(); // Reset paths for new search\n        List\u003cInteger\u003e currentPath = new ArrayList\u003c\u003e();\n\n        System.out.println(\"\\nFinding all paths (Recursive DFS) starting from vertex \" + startVertex + \":\");\n        findAllPathsRecursiveUtil(startVertex, visited, currentPath);\n    }\n\n    /**\n     * Recursive helper function for DFS path finding.\n     *\n     * @param vertex      The current vertex being visited.\n     * @param visited     Array to keep track of visited nodes in the current recursion path.\n     * @param currentPath The path taken to reach the current vertex.\n     */\n    private void findAllPathsRecursiveUtil(int vertex, boolean[] visited, List\u003cInteger\u003e currentPath) {\n        // Mark the current node as visited and add it to the path\n        visited[vertex] = true;\n        currentPath.add(vertex);\n\n        // Store a copy of the current path\n        // This captures the path to the *current* vertex\n        allPaths.add(new ArrayList\u003c\u003e(currentPath));\n        // System.out.println(\"Path found: \" + currentPath); // Optional: print paths as they are found\n\n        // Recur for all adjacent vertices\n        for (int neighbor : adjencyList.get(vertex)) {\n            if (!visited[neighbor]) {\n                findAllPathsRecursiveUtil(neighbor, visited, currentPath);\n            }\n        }\n\n        // Backtrack: remove current vertex from path and mark as unvisited\n        // for other potential paths.\n        currentPath.remove(currentPath.size() - 1);\n        visited[vertex] = false;\n    }\n\n\n    // --- Iterative DFS Path Finding ---\n\n     /**\n      * Finds paths using iterative DFS and stores them.\n      * This version uses a stack storing pairs of (node, path_to_node).\n      * Note: The order of path discovery might differ from the recursive version.\n      *\n      * @param startVertex The vertex to start the search from.\n      */\n    public void findAllPathsIterative(int startVertex) {\n         if (startVertex \u003c 0 || startVertex \u003e= numVertices) {\n             System.err.println(\"Error: Start vertex out of bounds.\");\n             return;\n         }\n         this.allPaths = new ArrayList\u003c\u003e(); // Reset paths\n         System.out.println(\"\\nFinding all paths (Iterative DFS) starting from vertex \" + startVertex + \":\");\n\n         // Stack stores pairs: the node and the path to reach it\n         Stack\u003cPair\u003cInteger, List\u003cInteger\u003e\u003e\u003e stack = new Stack\u003c\u003e();\n\n         // Initial path contains only the start vertex\n         List\u003cInteger\u003e initialPath = new ArrayList\u003c\u003e();\n         initialPath.add(startVertex);\n         stack.push(new Pair\u003c\u003e(startVertex, initialPath));\n\n         // Keep track of visited nodes *globally* across different path explorations\n         // This prevents infinite loops in cyclic graphs and redundant processing.\n         boolean[] globallyVisited = new boolean[numVertices];\n\n\n         while (!stack.isEmpty()) {\n             Pair\u003cInteger, List\u003cInteger\u003e\u003e currentPair = stack.pop();\n             int currentVertex = currentPair.getKey();\n             List\u003cInteger\u003e currentPath = currentPair.getValue();\n\n             // If we haven't processed this node *through this specific path expansion*\n             // Mark it visited *globally* only after processing its path.\n             // This allows finding different paths to the same node, but standard\n             // iterative DFS usually uses a simpler visited check.\n             // For simplicity matching the recursive intent, let's only proceed\n             // if the node hasn't been the *end* of a stored path yet.\n             // A better approach might be needed for complex path requirements.\n\n             // Store the path found to this vertex\n             allPaths.add(new ArrayList\u003c\u003e(currentPath)); // Store a copy\n             // System.out.println(\"Path found: \" + currentPath); // Optional: print\n\n\n             if (!globallyVisited[currentVertex]) {\n                 globallyVisited[currentVertex] = true; // Mark globally visited\n\n                  // Explore neighbors\n                 // Iterate in reverse to mimic recursive DFS neighbor order more closely (optional)\n                 List\u003cInteger\u003e neighbors = adjencyList.get(currentVertex);\n                 // Collections.reverse(neighbors); // Uncomment to push neighbors in reverse order\n\n                 for (int neighbor : neighbors) {\n                     // Check if the neighbor is already in the *current* path to avoid cycles within a single path\n                     boolean visitedInCurrentPath = false;\n                     for(int nodeInPath : currentPath) {\n                         if (nodeInPath == neighbor) {\n                             visitedInCurrentPath = true;\n                             break;\n                         }\n                     }\n\n                     // If the neighbor hasn't been visited *in this specific path*\n                     if (!visitedInCurrentPath) {\n                         List\u003cInteger\u003e newPath = new ArrayList\u003c\u003e(currentPath);\n                         newPath.add(neighbor);\n                         stack.push(new Pair\u003c\u003e(neighbor, newPath));\n                     }\n                 }\n                 // Collections.reverse(neighbors); // Reverse back if reversed earlier\n             }\n         }\n     }\n\n\n    // --- Original Traversal Methods (for comparison/demonstration) ---\n\n    /**\n     * Performs the original iterative DFS traversal, printing nodes as visited.\n     * Does not store paths.\n     * @param startVertex The vertex to start from.\n     */\n    public void performDFSTraversalIterative(int startVertex) {\n        if (startVertex \u003c 0 || startVertex \u003e= numVertices) {\n            System.err.println(\"Error: Start vertex out of bounds.\");\n            return;\n        }\n        boolean[] visited = new boolean[numVertices];\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e(); // Use Stack's push/pop for LIFO (DFS)\n\n        visited[startVertex] = true;\n        stack.push(startVertex); // Push onto stack\n\n        System.out.println(\"\\nDFS Traversal Order (Iterative): starting from \" + startVertex + \" \");\n\n        while (!stack.isEmpty()) {\n            int currentVertex = stack.pop(); // Pop from stack (LIFO)\n            System.out.print(currentVertex + \" \");\n\n            // Get neighbors and push unvisited ones onto the stack\n            // Process neighbors in natural order (or reverse to mimic recursion)\n            List\u003cInteger\u003e neighbors = adjencyList.get(currentVertex);\n             // Collections.reverse(neighbors); // To more closely match typical recursive order\n\n            for (int neighbor : neighbors) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    stack.push(neighbor);\n                }\n            }\n             // Collections.reverse(neighbors); // Reverse back if needed\n        }\n        System.out.println();\n    }\n\n     /**\n     * Performs the original recursive DFS traversal, printing nodes as visited.\n     * Does not store paths.\n     * @param startVertex The vertex to start from.\n     */\n    public void performDFSTraversalRecursive(int startVertex) {\n         if (startVertex \u003c 0 || startVertex \u003e= numVertices) {\n             System.err.println(\"Error: Start vertex out of bounds.\");\n             return;\n         }\n        boolean[] visited = new boolean[numVertices];\n        System.out.println(\"\\nDFS Traversal Order (Recursive) starting from vertex \" + startVertex + \":\");\n        performDFSTraversalRecursiveUtil(startVertex, visited);\n        System.out.println();\n    }\n\n    private void performDFSTraversalRecursiveUtil(int vertex, boolean[] visited) {\n        visited[vertex] = true;\n        System.out.print(vertex + \" \");\n\n        for (int neighbor : adjencyList.get(vertex)) {\n            if (!visited[neighbor]) {\n                performDFSTraversalRecursiveUtil(neighbor, visited);\n            }\n        }\n    }\n\n    // --- Utility ---\n\n    /**\n     * Returns the list of paths found by the last pathfinding call.\n     * @return A list where each element is a list of integers representing a path.\n     */\n    public List\u003cList\u003cInteger\u003e\u003e getAllPaths() {\n        return allPaths;\n    }\n\n     /**\n      * Prints all stored paths.\n      */\n     public void printAllPaths() {\n         if (allPaths == null || allPaths.isEmpty()) {\n             System.out.println(\"No paths have been generated or stored yet.\");\n             return;\n         }\n         System.out.println(\"\\n--- Stored Paths ---\");\n         int pathNum = 1;\n         for (List\u003cInteger\u003e path : allPaths) {\n             System.out.println(\"Path \" + (pathNum++) + \": \" + path);\n         }\n         System.out.println(\"--------------------\");\n     }\n\n     // Simple generic Pair class (or use javafx.util.Pair if available/allowed)\n     private static class Pair\u003cK, V\u003e {\n         private final K key;\n         private final V value;\n\n         public Pair(K key, V value) {\n             this.key = key;\n             this.value = value;\n         }\n\n         public K getKey() { return key; }\n         public V getValue() { return value; }\n     }\n}\n\nclass Main {\n\n    public static void main(String[] args) {\n\n        DFS graph = new DFS(12);\n\n        // Build the graph\n        graph.addEdge(0, 1);\n        graph.addEdge(0, 2);\n        graph.addEdge(1, 3);\n        graph.addEdge(2, 4);\n        graph.addEdge(4, 5);\n        graph.addEdge(0, 6); // 0 -\u003e 6\n        graph.addEdge(0, 7); // 0 -\u003e 7\n        graph.addEdge(7, 8); // 7 -\u003e 8\n        graph.addEdge(7, 9); // 7 -\u003e 9\n        graph.addEdge(9, 10); // 9 -\u003e 10\n        graph.addEdge(5, 11); // 5 -\u003e 11\n\n        // Print Adjacency List (for verification)\n        System.out.println(\"--- Adjacency List ---\");\n        for (int i = 0; i \u003c graph.adjencyList.size(); i++) {\n            System.out.println(\"Vertex \" + i + \": \" + graph.adjencyList.get(i));\n        }\n         System.out.println(\"----------------------\");\n\n        // --- Demonstrate Original Traversals ---\n        graph.performDFSTraversalIterative(0);\n        graph.performDFSTraversalRecursive(0);\n\n        // --- Find and Store Paths (Recursive) ---\n        graph.findAllPathsRecursive(0);\n        // Print the paths found by the recursive method\n        graph.printAllPaths();\n\n        // --- Find and Store Paths (Iterative) ---\n        graph.findAllPathsIterative(0);\n         // Print the paths found by the iterative method\n         // Note: The order and exact paths might differ slightly depending on implementation details\n         graph.printAllPaths();\n\n         // Example: Get paths and process them\n         System.out.println(\"\\nAccessing paths manually after iterative search:\");\n         List\u003cList\u003cInteger\u003e\u003e storedPaths = graph.getAllPaths();\n         if (storedPaths != null \u0026\u0026 !storedPaths.isEmpty()) {\n             System.out.println(\"Total paths found: \" + storedPaths.size());\n             System.out.println(\"First path found: \" + storedPaths.get(0));\n             System.out.println(\"Last path found: \" + storedPaths.get(storedPaths.size() - 1));\n         }\n    }\n}","position":{"start":{"line":11,"column":1},"end":{"line":343,"column":1}},"key":"VgeuOK5PsW"},{"type":"paragraph","position":{"start":{"line":347,"column":1},"end":{"line":347,"column":1}},"children":[{"type":"text","value":"This code defines a ","position":{"start":{"line":347,"column":1},"end":{"line":347,"column":1}},"key":"rsbSyZqs5u"},{"type":"inlineCode","value":"DFS","position":{"start":{"line":347,"column":1},"end":{"line":347,"column":1}},"key":"FXxRZ6oz5W"},{"type":"text","value":" class that represents a graph and provides methods for performing Depth-First Search (DFS) operations on it. It specifically includes implementations for:","position":{"start":{"line":347,"column":1},"end":{"line":347,"column":1}},"key":"ZBBD3ut7is"}],"key":"jqGUVXPiy4"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":349,"column":1},"end":{"line":351,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":349,"column":1},"end":{"line":349,"column":1}},"children":[{"type":"strong","position":{"start":{"line":349,"column":1},"end":{"line":349,"column":1}},"children":[{"type":"text","value":"Standard DFS Traversal (Recursive \u0026 Iterative):","position":{"start":{"line":349,"column":1},"end":{"line":349,"column":1}},"key":"hWglSVsHmQ"}],"key":"bUvqYN9XDJ"},{"type":"text","value":" These methods visit nodes in DFS order and typically print them, primarily demonstrating the traversal algorithm itself.","position":{"start":{"line":349,"column":1},"end":{"line":349,"column":1}},"key":"Toafn9WuOq"}],"key":"GwgBxAgnLy"},{"type":"listItem","spread":true,"position":{"start":{"line":350,"column":1},"end":{"line":351,"column":1}},"children":[{"type":"strong","position":{"start":{"line":350,"column":1},"end":{"line":350,"column":1}},"children":[{"type":"text","value":"Finding All Paths via DFS (Recursive \u0026 Iterative):","position":{"start":{"line":350,"column":1},"end":{"line":350,"column":1}},"key":"Raqy8nuakI"}],"key":"FHS7MMnKfl"},{"type":"text","value":" These are more complex methods designed to find and store ","position":{"start":{"line":350,"column":1},"end":{"line":350,"column":1}},"key":"VSP2853QTS"},{"type":"emphasis","position":{"start":{"line":350,"column":1},"end":{"line":350,"column":1}},"children":[{"type":"text","value":"all","position":{"start":{"line":350,"column":1},"end":{"line":350,"column":1}},"key":"Zcs5yvwARr"}],"key":"hLmUiPILEc"},{"type":"text","value":" possible paths starting from a given vertex that can be discovered through a DFS exploration.","position":{"start":{"line":350,"column":1},"end":{"line":350,"column":1}},"key":"I2ZM3EsI3U"}],"key":"RvIkzRxSDk"}],"key":"J8jWIFPIcz"},{"type":"paragraph","position":{"start":{"line":352,"column":1},"end":{"line":352,"column":1}},"children":[{"type":"text","value":"Here’s a breakdown of the components:","position":{"start":{"line":352,"column":1},"end":{"line":352,"column":1}},"key":"gPWhlMtwXj"}],"key":"MV47Hopbl6"},{"type":"paragraph","position":{"start":{"line":354,"column":1},"end":{"line":354,"column":1}},"children":[{"type":"strong","position":{"start":{"line":354,"column":1},"end":{"line":354,"column":1}},"children":[{"type":"inlineCode","value":"DFS","position":{"start":{"line":354,"column":1},"end":{"line":354,"column":1}},"key":"r5qvDKKJaT"},{"type":"text","value":" Class:","position":{"start":{"line":354,"column":1},"end":{"line":354,"column":1}},"key":"wM8qSXRhiD"}],"key":"LomrK92Izo"}],"key":"sinPanbsvP"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":356,"column":1},"end":{"line":445,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":356,"column":1},"end":{"line":361,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":356,"column":1},"end":{"line":356,"column":1}},"children":[{"type":"strong","position":{"start":{"line":356,"column":1},"end":{"line":356,"column":1}},"children":[{"type":"text","value":"Fields:","position":{"start":{"line":356,"column":1},"end":{"line":356,"column":1}},"key":"ga9WU829mp"}],"key":"YW7bsWiUz1"}],"key":"LXCkAh7KY3"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":358,"column":1},"end":{"line":361,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":358,"column":1},"end":{"line":358,"column":1}},"children":[{"type":"inlineCode","value":"numVertices","position":{"start":{"line":358,"column":1},"end":{"line":358,"column":1}},"key":"IGLrOkCj2e"},{"type":"text","value":": An integer storing the number of vertices in the graph.","position":{"start":{"line":358,"column":1},"end":{"line":358,"column":1}},"key":"fAdIovyLJY"}],"key":"p30dBpJfcB"},{"type":"listItem","spread":true,"position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"children":[{"type":"inlineCode","value":"adjencyList","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"Rziuh0qQRw"},{"type":"text","value":": A ","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"Mc6949qVBR"},{"type":"inlineCode","value":"List\u003cLinkedList\u003cInteger\u003e\u003e","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"fCam8w9tgo"},{"type":"text","value":". This is the core graph representation using an ","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"KAnqJBwiXq"},{"type":"strong","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"children":[{"type":"text","value":"adjacency list","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"keraBaSsaI"}],"key":"G7QUapVBuw"},{"type":"text","value":". The outer list has an index for each vertex (0 to ","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"wHxNtlgph0"},{"type":"inlineCode","value":"numVertices - 1","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"zxbcUJn8ZN"},{"type":"text","value":"). The ","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"hMaqhj349v"},{"type":"inlineCode","value":"LinkedList","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"dXSqx1wG0S"},{"type":"text","value":" at each index ","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"dTidhW2krG"},{"type":"inlineCode","value":"i","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"PIKY7ZqEOr"},{"type":"text","value":" stores the vertices directly connected (adjacent) to vertex ","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"TBxjpqk8ur"},{"type":"inlineCode","value":"i","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"pdMoyhls85"},{"type":"text","value":".","position":{"start":{"line":359,"column":1},"end":{"line":359,"column":1}},"key":"wemRtHiGIg"}],"key":"bGoWqwooY7"},{"type":"listItem","spread":true,"position":{"start":{"line":360,"column":1},"end":{"line":361,"column":1}},"children":[{"type":"inlineCode","value":"allPaths","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"p4RoRI1eLl"},{"type":"text","value":": A ","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"LwnHc5xjFH"},{"type":"inlineCode","value":"List\u003cList\u003cInteger\u003e\u003e","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"xQDYzGp7M9"},{"type":"text","value":". This list is used to store the results of the path-finding operations (","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"qUHowDTYw0"},{"type":"inlineCode","value":"findAllPathsRecursive","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"acEqqSv3vJ"},{"type":"text","value":" or ","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"qNay3yar9p"},{"type":"inlineCode","value":"findAllPathsIterative","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"g3Rx0R34iy"},{"type":"text","value":"). Each element within ","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"z9Wv0J8ym6"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"i5SxwEJgLG"},{"type":"text","value":" is itself a ","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"FKfXAwEd9w"},{"type":"inlineCode","value":"List\u003cInteger\u003e","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"mtuygRmQPQ"},{"type":"text","value":" representing a single path found.","position":{"start":{"line":360,"column":1},"end":{"line":360,"column":1}},"key":"kSO67K9KFo"}],"key":"eyNPoFcfFY"}],"key":"JdvbjBBmhM"}],"key":"LVSaF0VcFW"},{"type":"listItem","spread":true,"position":{"start":{"line":362,"column":1},"end":{"line":367,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":362,"column":1},"end":{"line":362,"column":1}},"children":[{"type":"strong","position":{"start":{"line":362,"column":1},"end":{"line":362,"column":1}},"children":[{"type":"text","value":"Constructor (","position":{"start":{"line":362,"column":1},"end":{"line":362,"column":1}},"key":"zY6cK6fAuj"},{"type":"inlineCode","value":"DFS(int vertices)","position":{"start":{"line":362,"column":1},"end":{"line":362,"column":1}},"key":"nq5tHgClEU"},{"type":"text","value":"):","position":{"start":{"line":362,"column":1},"end":{"line":362,"column":1}},"key":"YjYauVWD5m"}],"key":"TRJpfPRxsv"}],"key":"fMcBlfvc03"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":364,"column":1},"end":{"line":367,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":364,"column":1},"end":{"line":364,"column":1}},"children":[{"type":"text","value":"Initializes the graph with a specified number of vertices.","position":{"start":{"line":364,"column":1},"end":{"line":364,"column":1}},"key":"A5Eg6QOg3l"}],"key":"xvSAKJlaiG"},{"type":"listItem","spread":true,"position":{"start":{"line":365,"column":1},"end":{"line":365,"column":1}},"children":[{"type":"text","value":"Creates the ","position":{"start":{"line":365,"column":1},"end":{"line":365,"column":1}},"key":"qDGkPwrfYm"},{"type":"inlineCode","value":"adjencyList","position":{"start":{"line":365,"column":1},"end":{"line":365,"column":1}},"key":"DjFvahiVFn"},{"type":"text","value":" structure, adding an empty ","position":{"start":{"line":365,"column":1},"end":{"line":365,"column":1}},"key":"LCMcBRzy7P"},{"type":"inlineCode","value":"LinkedList","position":{"start":{"line":365,"column":1},"end":{"line":365,"column":1}},"key":"JDuPaeRo2P"},{"type":"text","value":" for each vertex.","position":{"start":{"line":365,"column":1},"end":{"line":365,"column":1}},"key":"y2elY4Kdgt"}],"key":"lxtHRsq8nW"},{"type":"listItem","spread":true,"position":{"start":{"line":366,"column":1},"end":{"line":367,"column":1}},"children":[{"type":"text","value":"Initializes the ","position":{"start":{"line":366,"column":1},"end":{"line":366,"column":1}},"key":"dx6kxel9m3"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":366,"column":1},"end":{"line":366,"column":1}},"key":"hPLz2VnY6X"},{"type":"text","value":" list.","position":{"start":{"line":366,"column":1},"end":{"line":366,"column":1}},"key":"CTTLb0gySE"}],"key":"NkQZ4geYBH"}],"key":"Tx2SwtOxy2"}],"key":"OZyY2nKubg"},{"type":"listItem","spread":true,"position":{"start":{"line":368,"column":1},"end":{"line":373,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":368,"column":1},"end":{"line":368,"column":1}},"children":[{"type":"strong","position":{"start":{"line":368,"column":1},"end":{"line":368,"column":1}},"children":[{"type":"inlineCode","value":"addEdge(int source, int destination)","position":{"start":{"line":368,"column":1},"end":{"line":368,"column":1}},"key":"vWl3fbx90T"},{"type":"text","value":":","position":{"start":{"line":368,"column":1},"end":{"line":368,"column":1}},"key":"Y5SpUxiivs"}],"key":"lL1Vq2vCqx"}],"key":"yyYcfonjr7"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":370,"column":1},"end":{"line":373,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":370,"column":1},"end":{"line":370,"column":1}},"children":[{"type":"text","value":"Adds an edge between the ","position":{"start":{"line":370,"column":1},"end":{"line":370,"column":1}},"key":"lZocwU1Spd"},{"type":"inlineCode","value":"source","position":{"start":{"line":370,"column":1},"end":{"line":370,"column":1}},"key":"TvPcThSaFM"},{"type":"text","value":" vertex and the ","position":{"start":{"line":370,"column":1},"end":{"line":370,"column":1}},"key":"p2jslLRCei"},{"type":"inlineCode","value":"destination","position":{"start":{"line":370,"column":1},"end":{"line":370,"column":1}},"key":"QYlxwSTN1i"},{"type":"text","value":" vertex.","position":{"start":{"line":370,"column":1},"end":{"line":370,"column":1}},"key":"BFvBgnufcf"}],"key":"FfaveMpajQ"},{"type":"listItem","spread":true,"position":{"start":{"line":371,"column":1},"end":{"line":371,"column":1}},"children":[{"type":"text","value":"Includes basic error checking to ensure vertex indices are valid.","position":{"start":{"line":371,"column":1},"end":{"line":371,"column":1}},"key":"rlCkpQVC7x"}],"key":"TGW6TYEQLA"},{"type":"listItem","spread":true,"position":{"start":{"line":372,"column":1},"end":{"line":373,"column":1}},"children":[{"type":"text","value":"Adds ","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"dEGAwJEhMC"},{"type":"inlineCode","value":"destination","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"oi77MDzG2d"},{"type":"text","value":" to ","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"lMQIFMcFnE"},{"type":"inlineCode","value":"source","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"bDxiCqfGKh"},{"type":"text","value":"’s list and ","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"TO1ioIiYHG"},{"type":"inlineCode","value":"source","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"QIoPJMjA0T"},{"type":"text","value":" to ","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"icxxJtQoRY"},{"type":"inlineCode","value":"destination","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"G40BTRHI8c"},{"type":"text","value":"’s list. This makes the graph ","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"MP5DEiRQSH"},{"type":"strong","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"children":[{"type":"text","value":"undirected","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"R8ReoRGgdz"}],"key":"L1nRsOawf1"},{"type":"text","value":" (an edge exists in both directions).","position":{"start":{"line":372,"column":1},"end":{"line":372,"column":1}},"key":"FjnNfGskgX"}],"key":"RD8HHg4Wx4"}],"key":"B9LB7awiZf"}],"key":"BTBVYlqkwl"},{"type":"listItem","spread":true,"position":{"start":{"line":374,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"children":[{"type":"strong","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"children":[{"type":"text","value":"Recursive Path Finding (","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"mdAipnMT31"},{"type":"inlineCode","value":"findAllPathsRecursive","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"bJtl9Stg5X"},{"type":"text","value":" and ","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"y2k97Bm9yX"},{"type":"inlineCode","value":"findAllPathsRecursiveUtil","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"AK9RqxO82R"},{"type":"text","value":"):","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"RYB9r3lZxS"}],"key":"wdmrpKR857"}],"key":"oUHO51w6k8"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":376,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":376,"column":1},"end":{"line":377,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"children":[{"type":"inlineCode","value":"findAllPathsRecursive(startVertex)","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"T3rm6JW6fv"},{"type":"text","value":": The public method to initiate the search. It sets up a ","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"SaHP4gA9j4"},{"type":"inlineCode","value":"visited","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"XO82uwRpnS"},{"type":"text","value":" array (local to the current path exploration) and resets the ","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"yDQY3uZ1Fa"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"p8zIFO012p"},{"type":"text","value":" list before calling the helper function.","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"DXpF2wtedE"}],"key":"qgeEYjkYYh"}],"key":"TekvnHBh4P"},{"type":"listItem","spread":true,"position":{"start":{"line":378,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"code","lang":"","value":"findAllPathsRecursiveUtil(vertex, visited, currentPath)","position":{"start":{"line":378,"column":1},"end":{"line":380,"column":1}},"key":"c59AKZc6fK"},{"type":"paragraph","position":{"start":{"line":382,"column":1},"end":{"line":382,"column":1}},"children":[{"type":"text","value":":","position":{"start":{"line":382,"column":1},"end":{"line":382,"column":1}},"key":"gzrEaI3CwJ"}],"key":"lQRRE9rGIK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":384,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":384,"column":1},"end":{"line":384,"column":1}},"children":[{"type":"text","value":"This is the core recursive logic.","position":{"start":{"line":384,"column":1},"end":{"line":384,"column":1}},"key":"uibYJtMe5O"}],"key":"RgfN2kOOva"},{"type":"listItem","spread":true,"position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"children":[{"type":"text","value":"It marks the current ","position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"key":"s7PhlhTGr7"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"key":"D5ZvSVhGnG"},{"type":"text","value":" as visited ","position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"key":"jm2Jup0xl8"},{"type":"emphasis","position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"children":[{"type":"text","value":"for the current path exploration","position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"key":"vbFgUR3ZNN"}],"key":"h2A6c1U4PQ"},{"type":"text","value":".","position":{"start":{"line":385,"column":1},"end":{"line":385,"column":1}},"key":"BFdrlcAMvN"}],"key":"Yz2RvxQ0JT"},{"type":"listItem","spread":true,"position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"children":[{"type":"text","value":"Adds the ","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"k8mdtUNUVI"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"BYHPozH7VB"},{"type":"text","value":" to the ","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"LsouheFWni"},{"type":"inlineCode","value":"currentPath","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"d8JZ7EUeWd"},{"type":"text","value":".","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"eDuRsUpVBc"}],"key":"qG5bSsLmpM"},{"type":"listItem","spread":true,"position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"children":[{"type":"strong","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"children":[{"type":"text","value":"Crucially:","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"UkY4OKHqBd"}],"key":"msxUKTM4ER"},{"type":"text","value":" It adds a ","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"bipETMRc8q"},{"type":"emphasis","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"children":[{"type":"text","value":"copy","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"S7YaPuNdde"}],"key":"IRFj2fqCTu"},{"type":"text","value":" of the ","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"xwzxAajsww"},{"type":"inlineCode","value":"currentPath","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"M935btHKgA"},{"type":"text","value":" (up to the current ","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"soAOVdTHff"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"kEMQGDdzKC"},{"type":"text","value":") to the ","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"dEzf9qPYlm"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"kQEXOjTka6"},{"type":"text","value":" list. This means every node encountered during the DFS becomes the end of a stored path.","position":{"start":{"line":387,"column":1},"end":{"line":387,"column":1}},"key":"wgVSGwxe8J"}],"key":"tqBEawBl1Z"},{"type":"listItem","spread":true,"position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"children":[{"type":"text","value":"It iterates through the neighbors of the current ","position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"key":"lZAa2e4y32"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"key":"LZonC7NdVA"},{"type":"text","value":". If a neighbor hasn’t been visited ","position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"key":"S2CBTLWqzU"},{"type":"emphasis","position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"children":[{"type":"text","value":"in the current recursive call stack","position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"key":"ovBh4Ri0Xu"}],"key":"o9wotrZub6"},{"type":"text","value":", it recursively calls itself for that neighbor.","position":{"start":{"line":388,"column":1},"end":{"line":388,"column":1}},"key":"L1SSvuvBPn"}],"key":"euMTa17KOs"},{"type":"listItem","spread":true,"position":{"start":{"line":389,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"strong","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"children":[{"type":"text","value":"Backtracking:","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"eyqAKf88Ja"}],"key":"Ih7J2Lkm10"},{"type":"text","value":" After exploring all paths stemming from the current ","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"GKO6fiRS5v"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"fk7fdG8snc"},{"type":"text","value":", it removes the ","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"uBWCns1RuS"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"wqpCldwa32"},{"type":"text","value":" from ","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"P3LD7liIgm"},{"type":"inlineCode","value":"currentPath","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"sW0AH4mAby"},{"type":"text","value":" and marks it as unvisited (","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"RTFqhXId0R"},{"type":"inlineCode","value":"visited[vertex] = false","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"oKqF9IwSwm"},{"type":"text","value":"). This is essential to allow the algorithm to explore ","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"N5d96HiPZB"},{"type":"emphasis","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"children":[{"type":"text","value":"other","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"OWsYFjnojw"}],"key":"iZO3um1UpE"},{"type":"text","value":" paths that might reach this ","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"WEKAnBPOpV"},{"type":"inlineCode","value":"vertex","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"rNlvMlCytQ"},{"type":"text","value":" through a different sequence.","position":{"start":{"line":389,"column":1},"end":{"line":389,"column":1}},"key":"LZKRy7EJs9"}],"key":"quJ6Gw8KsD"}],"key":"HuD8TyycKw"}],"key":"YyN6rhwgcc"}],"key":"bszutJka3u"}],"key":"JSMbaN1vSj"},{"type":"listItem","spread":true,"position":{"start":{"line":391,"column":1},"end":{"line":432,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":391,"column":1},"end":{"line":391,"column":1}},"children":[{"type":"strong","position":{"start":{"line":391,"column":1},"end":{"line":391,"column":1}},"children":[{"type":"text","value":"Iterative Path Finding (","position":{"start":{"line":391,"column":1},"end":{"line":391,"column":1}},"key":"oKZYdRgBYS"},{"type":"inlineCode","value":"findAllPathsIterative","position":{"start":{"line":391,"column":1},"end":{"line":391,"column":1}},"key":"ojbyimKq6V"},{"type":"text","value":"):","position":{"start":{"line":391,"column":1},"end":{"line":391,"column":1}},"key":"klqLpMNWqJ"}],"key":"O2pKoSvSm8"}],"key":"VDesVX9qqo"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":393,"column":1},"end":{"line":432,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":393,"column":1},"end":{"line":394,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"children":[{"type":"text","value":"This method attempts to find all paths using an iterative approach with a ","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"key":"qEGhfVj2y9"},{"type":"inlineCode","value":"Stack","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"key":"Ex0FUFPEz9"},{"type":"text","value":".","position":{"start":{"line":393,"column":1},"end":{"line":393,"column":1}},"key":"qVNq1I1c5h"}],"key":"hYoOYvyBDA"}],"key":"AdpS3Lz4OA"},{"type":"listItem","spread":true,"position":{"start":{"line":395,"column":1},"end":{"line":411,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":395,"column":1},"end":{"line":395,"column":1}},"children":[{"type":"text","value":"It uses a","position":{"start":{"line":395,"column":1},"end":{"line":395,"column":1}},"key":"jt0e8ZP8fN"}],"key":"SMrkZN9fvP"},{"type":"code","lang":"","value":"Stack","position":{"start":{"line":397,"column":1},"end":{"line":399,"column":1}},"key":"Nf1yZ0SxNQ"},{"type":"paragraph","position":{"start":{"line":401,"column":1},"end":{"line":401,"column":1}},"children":[{"type":"text","value":"where each element is a","position":{"start":{"line":401,"column":1},"end":{"line":401,"column":1}},"key":"xn5UTmHgx0"}],"key":"Qb5QCM8aP1"},{"type":"code","lang":"","value":"Pair","position":{"start":{"line":403,"column":1},"end":{"line":405,"column":1}},"key":"pnIT5cdSv3"},{"type":"paragraph","position":{"start":{"line":407,"column":1},"end":{"line":407,"column":1}},"children":[{"type":"text","value":"containing:","position":{"start":{"line":407,"column":1},"end":{"line":407,"column":1}},"key":"lXdmwXNbbv"}],"key":"uTFAGklC5r"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":409,"column":1},"end":{"line":411,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":409,"column":1},"end":{"line":409,"column":1}},"children":[{"type":"text","value":"The current vertex (","position":{"start":{"line":409,"column":1},"end":{"line":409,"column":1}},"key":"RI0l8QWcSR"},{"type":"inlineCode","value":"Integer","position":{"start":{"line":409,"column":1},"end":{"line":409,"column":1}},"key":"uZUOUQMZp9"},{"type":"text","value":").","position":{"start":{"line":409,"column":1},"end":{"line":409,"column":1}},"key":"pW6c9WhLIZ"}],"key":"h0XroMCiVN"},{"type":"listItem","spread":true,"position":{"start":{"line":410,"column":1},"end":{"line":411,"column":1}},"children":[{"type":"text","value":"The path (","position":{"start":{"line":410,"column":1},"end":{"line":410,"column":1}},"key":"jJh8wiyT46"},{"type":"inlineCode","value":"List\u003cInteger\u003e","position":{"start":{"line":410,"column":1},"end":{"line":410,"column":1}},"key":"amFHtQ1B8O"},{"type":"text","value":") taken to reach that vertex.","position":{"start":{"line":410,"column":1},"end":{"line":410,"column":1}},"key":"nGfnvRVjup"}],"key":"kVvrDpHzVk"}],"key":"t5b8AmvBQ9"}],"key":"SNxKimjiAl"},{"type":"listItem","spread":true,"position":{"start":{"line":412,"column":1},"end":{"line":430,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":412,"column":1},"end":{"line":412,"column":1}},"children":[{"type":"text","value":"It also uses a","position":{"start":{"line":412,"column":1},"end":{"line":412,"column":1}},"key":"mS9RVFpzXj"}],"key":"ojCQnLUI0Y"},{"type":"code","lang":"","value":"globallyVisited","position":{"start":{"line":414,"column":1},"end":{"line":416,"column":1}},"key":"wbERbWnBJp"},{"type":"paragraph","position":{"start":{"line":418,"column":1},"end":{"line":418,"column":1}},"children":[{"type":"text","value":"array. The logic here is slightly different from the recursive version’s","position":{"start":{"line":418,"column":1},"end":{"line":418,"column":1}},"key":"G4I9ECQs84"}],"key":"wETB1pwuTS"},{"type":"code","lang":"","value":"visited","position":{"start":{"line":420,"column":1},"end":{"line":422,"column":1}},"key":"wFGnHN44T8"},{"type":"paragraph","position":{"start":{"line":424,"column":1},"end":{"line":424,"column":1}},"children":[{"type":"text","value":"array:","position":{"start":{"line":424,"column":1},"end":{"line":424,"column":1}},"key":"ytva9vuMQ6"}],"key":"XOJBYWDJzA"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":426,"column":1},"end":{"line":430,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"children":[{"type":"text","value":"It adds the path to ","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"iQPaRFchmF"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"Z4BbIU99Ga"},{"type":"text","value":" ","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"bJ9GJBR9FE"},{"type":"emphasis","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"children":[{"type":"text","value":"when","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"VMZHanLgaQ"}],"key":"CJrSaYvweV"},{"type":"text","value":" a ","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"AZM8y4CLOL"},{"type":"inlineCode","value":"Pair","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"KYDNXnY9dm"},{"type":"text","value":" is popped from the stack.","position":{"start":{"line":426,"column":1},"end":{"line":426,"column":1}},"key":"cvPJ2y0IcM"}],"key":"p67UKoi1PX"},{"type":"listItem","spread":true,"position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"children":[{"type":"text","value":"It checks ","position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"key":"UubuX4Loqc"},{"type":"inlineCode","value":"globallyVisited","position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"key":"CdpCqIkTm3"},{"type":"text","value":" ","position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"key":"TLO637SHSn"},{"type":"emphasis","position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"children":[{"type":"text","value":"after","position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"key":"mtmXd3ODUw"}],"key":"yeECKZMktt"},{"type":"text","value":" storing the path. If the node hasn’t been globally visited yet, it marks it and explores its neighbors.","position":{"start":{"line":427,"column":1},"end":{"line":427,"column":1}},"key":"BBNvge27RB"}],"key":"ntZ6Ik6zl3"},{"type":"listItem","spread":true,"position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"children":[{"type":"text","value":"When exploring neighbors, it checks if the neighbor is already present in the ","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"h3Kmnde6c6"},{"type":"emphasis","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"children":[{"type":"text","value":"current specific path","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"RUJTKQhe8n"}],"key":"fycfx6V9u2"},{"type":"text","value":" (","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"gdJ7e2RblT"},{"type":"inlineCode","value":"visitedInCurrentPath","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"zMzRtAmH9I"},{"type":"text","value":" loop) to prevent cycles ","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"IRmLCj09YH"},{"type":"emphasis","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"children":[{"type":"text","value":"within that single path","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"RDzdfCupEe"}],"key":"nbqR8S51Kv"},{"type":"text","value":".","position":{"start":{"line":428,"column":1},"end":{"line":428,"column":1}},"key":"RW0rREsKQZ"}],"key":"TfN1RBHS9b"},{"type":"listItem","spread":true,"position":{"start":{"line":429,"column":1},"end":{"line":430,"column":1}},"children":[{"type":"text","value":"If a neighbor is valid (not creating a cycle in the current path), a new path is created by extending the current one, and a new ","position":{"start":{"line":429,"column":1},"end":{"line":429,"column":1}},"key":"ZZnuauPdgF"},{"type":"inlineCode","value":"Pair","position":{"start":{"line":429,"column":1},"end":{"line":429,"column":1}},"key":"XhZDUsI5ic"},{"type":"text","value":" is pushed onto the stack.","position":{"start":{"line":429,"column":1},"end":{"line":429,"column":1}},"key":"OueGJltXf8"}],"key":"Vbr6gijJAu"}],"key":"wMy5PM2JRW"}],"key":"K3aJ8eBe6q"},{"type":"listItem","spread":true,"position":{"start":{"line":431,"column":1},"end":{"line":432,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"children":[{"type":"strong","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"children":[{"type":"text","value":"Note:","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"aomuMUebLp"}],"key":"ymxIpXKG4m"},{"type":"text","value":" The use of ","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"XmZs18h39k"},{"type":"inlineCode","value":"globallyVisited","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"F4PgjJr5JY"},{"type":"text","value":" prevents re-exploring ","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"S3AmfSH6wM"},{"type":"emphasis","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"children":[{"type":"text","value":"from","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"xi2ZjCpFKN"}],"key":"ndxFSZRb6f"},{"type":"text","value":" a node once ","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"YcSr3cuAbb"},{"type":"emphasis","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"children":[{"type":"text","value":"any","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"OgOmgh9QFn"}],"key":"T7G62H15i7"},{"type":"text","value":" path ending there has been processed. This helps avoid infinite loops in cyclic graphs but might prune some paths compared to a pure recursive backtracking approach if the goal was ","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"jNmPFNyXpd"},{"type":"emphasis","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"children":[{"type":"text","value":"all simple paths","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"t4B1hSdr04"}],"key":"MzfkqIFpi3"},{"type":"text","value":". The order of paths found might also differ from the recursive version due to stack LIFO order and neighbor processing order.","position":{"start":{"line":431,"column":1},"end":{"line":431,"column":1}},"key":"xEeek6pFBP"}],"key":"ZD1FsYorCJ"}],"key":"OIyfW2ciyT"}],"key":"qyxgegOkf6"}],"key":"pHlA8t3pCX"},{"type":"listItem","spread":true,"position":{"start":{"line":433,"column":1},"end":{"line":439,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"children":[{"type":"strong","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"children":[{"type":"text","value":"Standard Traversal Methods (","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"o7fFE2R5Lc"},{"type":"inlineCode","value":"performDFSTraversalIterative","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"FDcONRG1Uo"},{"type":"text","value":", ","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"OwfG62Il6n"},{"type":"inlineCode","value":"performDFSTraversalRecursive","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"htYki0MTX8"},{"type":"text","value":", ","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"wi9EzDnyAV"},{"type":"inlineCode","value":"performDFSTraversalRecursiveUtil","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"ZVHjyvbGX0"},{"type":"text","value":"):","position":{"start":{"line":433,"column":1},"end":{"line":433,"column":1}},"key":"agsu6U3MIF"}],"key":"XW843TF1DS"}],"key":"xdBYySy9ys"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":435,"column":1},"end":{"line":439,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":435,"column":1},"end":{"line":435,"column":1}},"children":[{"type":"text","value":"These implement the more “standard” DFS algorithm where the goal is just to visit each reachable node once.","position":{"start":{"line":435,"column":1},"end":{"line":435,"column":1}},"key":"GmMFoXYEY8"}],"key":"KbQ6CNUlNB"},{"type":"listItem","spread":true,"position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"children":[{"type":"text","value":"They use a ","position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"key":"yQxpH7bKsd"},{"type":"inlineCode","value":"visited","position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"key":"u6CttiaVqb"},{"type":"text","value":" array to keep track of nodes already visited during the ","position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"key":"BwT2gAWX3D"},{"type":"emphasis","position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"children":[{"type":"text","value":"entire","position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"key":"MTajD3GUh9"}],"key":"ClfWPAZmkS"},{"type":"text","value":" traversal.","position":{"start":{"line":436,"column":1},"end":{"line":436,"column":1}},"key":"VO607IoXDt"}],"key":"voaiMPDvia"},{"type":"listItem","spread":true,"position":{"start":{"line":437,"column":1},"end":{"line":437,"column":1}},"children":[{"type":"text","value":"They print the vertex when it’s visited (recursive) or popped (iterative).","position":{"start":{"line":437,"column":1},"end":{"line":437,"column":1}},"key":"OtV57WVVoR"}],"key":"cfMa25Mxa2"},{"type":"listItem","spread":true,"position":{"start":{"line":438,"column":1},"end":{"line":439,"column":1}},"children":[{"type":"text","value":"They do ","position":{"start":{"line":438,"column":1},"end":{"line":438,"column":1}},"key":"VD9jKSReHR"},{"type":"strong","position":{"start":{"line":438,"column":1},"end":{"line":438,"column":1}},"children":[{"type":"text","value":"not","position":{"start":{"line":438,"column":1},"end":{"line":438,"column":1}},"key":"vrwV4oqzx4"}],"key":"bkjRKbH3PH"},{"type":"text","value":" store paths.","position":{"start":{"line":438,"column":1},"end":{"line":438,"column":1}},"key":"LJofgQI4bo"}],"key":"tkfO6MfyhN"}],"key":"y3VrTWexWD"}],"key":"UFDj4pwTML"},{"type":"listItem","spread":true,"position":{"start":{"line":440,"column":1},"end":{"line":445,"column":1}},"children":[{"type":"paragraph","position":{"start":{"line":440,"column":1},"end":{"line":440,"column":1}},"children":[{"type":"strong","position":{"start":{"line":440,"column":1},"end":{"line":440,"column":1}},"children":[{"type":"text","value":"Utility Methods:","position":{"start":{"line":440,"column":1},"end":{"line":440,"column":1}},"key":"nTY2K4Km2Y"}],"key":"znntYzq0IZ"}],"key":"kbnnb8YTR1"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":442,"column":1},"end":{"line":445,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":442,"column":1},"end":{"line":442,"column":1}},"children":[{"type":"inlineCode","value":"getAllPaths()","position":{"start":{"line":442,"column":1},"end":{"line":442,"column":1}},"key":"u67H9H2aKP"},{"type":"text","value":": Returns the ","position":{"start":{"line":442,"column":1},"end":{"line":442,"column":1}},"key":"Uf4FLPgLH9"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":442,"column":1},"end":{"line":442,"column":1}},"key":"xkx3OeN7zk"},{"type":"text","value":" list (containing results from the last path-finding call).","position":{"start":{"line":442,"column":1},"end":{"line":442,"column":1}},"key":"M4z09uLohc"}],"key":"Ujynkg5zjC"},{"type":"listItem","spread":true,"position":{"start":{"line":443,"column":1},"end":{"line":443,"column":1}},"children":[{"type":"inlineCode","value":"printAllPaths()","position":{"start":{"line":443,"column":1},"end":{"line":443,"column":1}},"key":"hodqwEU2nM"},{"type":"text","value":": Prints all the paths currently stored in the ","position":{"start":{"line":443,"column":1},"end":{"line":443,"column":1}},"key":"M6emhBPXH3"},{"type":"inlineCode","value":"allPaths","position":{"start":{"line":443,"column":1},"end":{"line":443,"column":1}},"key":"BQi9dUqiR9"},{"type":"text","value":" list in a readable format.","position":{"start":{"line":443,"column":1},"end":{"line":443,"column":1}},"key":"QpWVuYgWPX"}],"key":"jjbd38EpXC"},{"type":"listItem","spread":true,"position":{"start":{"line":444,"column":1},"end":{"line":445,"column":1}},"children":[{"type":"inlineCode","value":"Pair\u003cK, V\u003e","position":{"start":{"line":444,"column":1},"end":{"line":444,"column":1}},"key":"skEbj8RRGM"},{"type":"text","value":": A simple private static inner class to hold pairs of objects (used in the iterative path finding).","position":{"start":{"line":444,"column":1},"end":{"line":444,"column":1}},"key":"u5JH69uv9i"}],"key":"Synxow9HXv"}],"key":"dJfqXA7n0V"}],"key":"vqSiMiKfRr"}],"key":"t8huE88JT7"},{"type":"paragraph","position":{"start":{"line":446,"column":1},"end":{"line":446,"column":1}},"children":[{"type":"strong","position":{"start":{"line":446,"column":1},"end":{"line":446,"column":1}},"children":[{"type":"inlineCode","value":"Main","position":{"start":{"line":446,"column":1},"end":{"line":446,"column":1}},"key":"NPZKTNBYL8"},{"type":"text","value":" Class:","position":{"start":{"line":446,"column":1},"end":{"line":446,"column":1}},"key":"gqepOPHN8z"}],"key":"ZyqO4jBxqN"}],"key":"tD3pokLq25"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":448,"column":1},"end":{"line":455,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":448,"column":1},"end":{"line":448,"column":1}},"children":[{"type":"text","value":"Creates an instance of the ","position":{"start":{"line":448,"column":1},"end":{"line":448,"column":1}},"key":"vDsmsLMvMS"},{"type":"inlineCode","value":"DFS","position":{"start":{"line":448,"column":1},"end":{"line":448,"column":1}},"key":"HMisNO228b"},{"type":"text","value":" graph with 12 vertices.","position":{"start":{"line":448,"column":1},"end":{"line":448,"column":1}},"key":"R49RImRSYF"}],"key":"W3aeH7lyvm"},{"type":"listItem","spread":true,"position":{"start":{"line":449,"column":1},"end":{"line":449,"column":1}},"children":[{"type":"text","value":"Adds edges to define the graph structure.","position":{"start":{"line":449,"column":1},"end":{"line":449,"column":1}},"key":"vJrPY45Ctx"}],"key":"wEwr00M37W"},{"type":"listItem","spread":true,"position":{"start":{"line":450,"column":1},"end":{"line":450,"column":1}},"children":[{"type":"text","value":"Prints the adjacency list to show the graph’s structure.","position":{"start":{"line":450,"column":1},"end":{"line":450,"column":1}},"key":"BQK9zdx4KK"}],"key":"RIY8eFyqFH"},{"type":"listItem","spread":true,"position":{"start":{"line":451,"column":1},"end":{"line":451,"column":1}},"children":[{"type":"text","value":"Demonstrates the standard iterative and recursive DFS ","position":{"start":{"line":451,"column":1},"end":{"line":451,"column":1}},"key":"rbrIORWbJ5"},{"type":"emphasis","position":{"start":{"line":451,"column":1},"end":{"line":451,"column":1}},"children":[{"type":"text","value":"traversals","position":{"start":{"line":451,"column":1},"end":{"line":451,"column":1}},"key":"iI5tovYuik"}],"key":"MYFCSfzcst"},{"type":"text","value":", printing the order nodes are visited.","position":{"start":{"line":451,"column":1},"end":{"line":451,"column":1}},"key":"z432ZwvN9l"}],"key":"cTFIWvpjdg"},{"type":"listItem","spread":true,"position":{"start":{"line":452,"column":1},"end":{"line":452,"column":1}},"children":[{"type":"text","value":"Calls ","position":{"start":{"line":452,"column":1},"end":{"line":452,"column":1}},"key":"K9DLMI16dB"},{"type":"inlineCode","value":"findAllPathsRecursive(0)","position":{"start":{"line":452,"column":1},"end":{"line":452,"column":1}},"key":"HmwBqlCN0m"},{"type":"text","value":" to find paths starting from vertex 0 using recursion and prints the results.","position":{"start":{"line":452,"column":1},"end":{"line":452,"column":1}},"key":"Npc12klS5R"}],"key":"c3txYbmHaB"},{"type":"listItem","spread":true,"position":{"start":{"line":453,"column":1},"end":{"line":453,"column":1}},"children":[{"type":"text","value":"Calls ","position":{"start":{"line":453,"column":1},"end":{"line":453,"column":1}},"key":"Zv6gzZEruT"},{"type":"inlineCode","value":"findAllPathsIterative(0)","position":{"start":{"line":453,"column":1},"end":{"line":453,"column":1}},"key":"ezpvPjxhZI"},{"type":"text","value":" to find paths starting from vertex 0 using iteration and prints those results.","position":{"start":{"line":453,"column":1},"end":{"line":453,"column":1}},"key":"c9cP6QO7ug"}],"key":"DpQFOmNyqX"},{"type":"listItem","spread":true,"position":{"start":{"line":454,"column":1},"end":{"line":455,"column":1}},"children":[{"type":"text","value":"Shows how to retrieve the list of paths using ","position":{"start":{"line":454,"column":1},"end":{"line":454,"column":1}},"key":"n6qAk8gGFk"},{"type":"inlineCode","value":"getAllPaths()","position":{"start":{"line":454,"column":1},"end":{"line":454,"column":1}},"key":"XIbSXdSQnz"},{"type":"text","value":" after a search.","position":{"start":{"line":454,"column":1},"end":{"line":454,"column":1}},"key":"OOzUaXpSof"}],"key":"H7JdEnRkUO"}],"key":"D8rJd0qQ9I"},{"type":"paragraph","position":{"start":{"line":456,"column":1},"end":{"line":456,"column":1}},"children":[{"type":"text","value":"In essence, this code provides a robust ","position":{"start":{"line":456,"column":1},"end":{"line":456,"column":1}},"key":"JF2ccs6byN"},{"type":"inlineCode","value":"DFS","position":{"start":{"line":456,"column":1},"end":{"line":456,"column":1}},"key":"eaBpFYodFo"},{"type":"text","value":" class for undirected graphs, offering both standard traversal and more complex path-finding capabilities, implemented recursively and iteratively.","position":{"start":{"line":456,"column":1},"end":{"line":456,"column":1}},"key":"QjgOngQ5cS"}],"key":"kVEIKV4O70"}],"key":"VN0V7P1dD1"}],"key":"tEl6MRqPJp"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Breadth First","url":"/xgraphsbfs","group":"Algorithms"},"next":{"title":"DSF - Maze Solving","url":"/xgraphsmazesolverdfs","group":"Algorithms"}}},"domain":"http://localhost:3002"},"project":{"bibliography":["C:\\a_books\\CSCI232_algobook\\references.bib"],"exports":[],"title":"Algorithms","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","toc":[{"file":"intro.md"},{"file":"xCSCI232_Intro.md"},{"children":[{"file":"xTerms_Radix.md"},{"file":"xTerms_Serializable.md"},{"file":"xTerms_Iterator.md"}],"file":"xTerms.md"},{"children":[{"file":"xBST_Applications.md"},{"file":"xBST_Comparisons.md"},{"file":"xBST_TreeTraversal.md"},{"file":"xBST_Iterative_Recursion_Search.md"},{"file":"xBST_BinarySearchTree.md"},{"file":"xBST_AVLTree.md"},{"file":"xBST_RedBlack.md"},{"file":"xBST_ComparisionTable.md"},{"file":"xBST_SplayTrees_2025.md"}],"file":"xBST_Intro.md"},{"children":[{"file":"xHashing_UnderstandingHashTables.md"},{"file":"xHashing_ModulusHashFunction.md"},{"file":"xHashing_Chaining.md"},{"file":"xHashing_OpenAddressing.md"},{"file":"xHashing_OpenAddressingHashingCodeExamples.md"}],"file":"xHashing_HashTable.md"},{"file":"xSkipList.md"},{"children":[{"file":"xGraphsAnalysisOfBFSandDFS.md"},{"file":"xUnderstandingBFS_202504.md"},{"file":"xUnderstandingDFS_202504.md"},{"file":"xGraphsSevenBridges.md"},{"file":"xGraphsDFS.md"},{"file":"xGraphsBFS.md"},{"file":"xDFSStoredPaths.md"},{"file":"xGraphsMazeSolverDFS.md"},{"file":"xGraphsDijkstra.md"}],"file":"xGraphs.md"},{"file":"xHuffmanCode.md"},{"file":"xSerializable.md"},{"children":[{"file":"xJavaHashMapTreeMapLinkedHashMap.md"},{"file":"xHashSetLinkedHashSetTreeSetComparision.md"},{"file":"xProgrammingToTheInterfacemd.md"}],"file":"xJAVATechniques.md"},{"file":"xEnd.md"}],"index":"index","pages":[{"slug":"xcsci232-intro","title":"CSCI 232 Data Structures and Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms","title":"Terms and Concepts","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms-radix","title":"Radix - Number Bases","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-serializable","title":"Serializable","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-iterator","title":"Iterator","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-intro","title":"Binary Search Tree - Intro","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbst-applications","title":"Applications That Use Binary Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisons","title":"Binary Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-treetraversal","title":"Tree Traversal","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-iterative-recursion-search","title":"Demonstrate BST using iterative looping and recursion","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-binarysearchtree","title":"Binary Search Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-avltree","title":"AVL Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-redblack","title":"Red Black Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisiontable","title":"BST AVL Red Black Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-splaytrees-2025","title":"Splay Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-hashtable","title":"Hash Table","description":"","date":"","thumbnail":"/CSCI232/build/f694c399ae1cdea2e011d1ecd6ed8d9d.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xhashing-understandinghashtables","title":"Understanding Hash Tables and Hash Functions*","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-modulushashfunction","title":"Modulus Hash Function","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-chaining","title":"Hash Tables - Chaining","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressing","title":"Hash Table - Open Addressing","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressinghashingcodeexamples","title":"Java code for double hashing in a hash table:","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xskiplist","title":"Skip List","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphs","title":"Graphs","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphsanalysisofbfsanddfs","title":"A Comparative Analysis of Breadth-First Search and Depth-First Search Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingbfs-202504","title":"Understanding Breadth-First Search (BFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingdfs-202504","title":"Understanding Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphssevenbridges","title":"Seven Bridges of Königsberg","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdfs","title":"Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsbfs","title":"Breadth First","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdfsstoredpaths","title":"DFS - Stored Paths","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsmazesolverdfs","title":"DSF - Maze Solving","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdijkstra","title":"Dijkstra’s Algorithm","description":"","date":"","thumbnail":"/CSCI232/build/dijkstra_example-8cca3c2c620cd1d44d2c9745b698d02d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhuffmancode","title":"Huffman Code","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xserializable","title":"Serialization","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavatechniques","title":"JAVA Techniques","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavahashmaptreemaplinkedhashmap","title":"Examples of Java’s HashMap, TreeMap, and LinkedHashMap","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashsetlinkedhashsettreesetcomparision","title":"HashSet, LinkedHashSet, and TreeSet Comparision","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xprogrammingtotheinterfacemd","title":"Programming To The Interface, Not The Implementation\"","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}}},"actionData":null,"errors":null},"future":{"unstable_dev":false,"unstable_postcss":false,"unstable_tailwind":false,"v2_errorBoundary":true,"v2_headers":true,"v2_meta":true,"v2_normalizeFormMethod":true,"v2_routeConvention":true}};</script><script type="module" async="">import "/CSCI232/build/manifest-54BD5942.js";
import * as route0 from "/CSCI232/build/root-PMP5BIHC.js";
import * as route1 from "/CSCI232/build/routes/$-5ZLZ2O3Y.js";
window.__remixRouteModules = {"root":route0,"routes/$":route1};

import("/CSCI232/build/entry.client-PCJPW7TK.js");</script></body></html>