{"version":3,"kind":"Article","sha256":"dd50a1de23b9af6892da94efb00689df40c9b21d97f4f5167f64c4212eca6ad7","slug":"xgraphsmazesolverdfs","location":"/xGraphsMazeSolverDFS.md","dependencies":[],"frontmatter":{"title":"DSF - Maze Solving","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xGraphsMazeSolverDFS.md","url":"/CSCI232/build/xGraphsMazeSolverDFS-94685893cabb020a38744bfaf43db03f.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"This program defines constants for different characters in the maze and implements two methods:","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"ThwtYTwElM"}],"key":"qRuvX6gGk0"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":7,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"solveMaze","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"OD8kRHkKVf"}],"key":"EEyfh8xbP3"},{"type":"text","value":": Finds the starting point and calls the recursive solveMazeDFS method.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"JJ207xgjcH"}],"key":"PtRoUcPSs4"},{"type":"listItem","spread":true,"position":{"start":{"line":8,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"strong","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"children":[{"type":"text","value":"solveMazeDFS","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"ypzNSHIdbt"}],"key":"FWIq3IbBYr"},{"type":"text","value":": Uses depth-first search to explore the maze. It marks visited cells, checks all four directions (up, down, left, right) for a solution, and backtracks if necessary.","position":{"start":{"line":8,"column":1},"end":{"line":8,"column":1}},"key":"sRdQQwLQYO"}],"key":"Drq2INhZQV"}],"key":"jU7aoaaK8v"},{"type":"paragraph","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"The main method demonstrates how to use the program with a sample maze.","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"ncokmfjrAg"}],"key":"y5mQWd5s23"},{"type":"heading","depth":3,"position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Lecture Code","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"EwqSsxq2Yp"}],"identifier":"lecture-code","label":"Lecture Code","html_id":"lecture-code","implicit":true,"key":"W8RrJa2YYk"},{"type":"code","lang":"java","value":"/*\nProgrammer: James Goudy with JGEM\n */\npackage mazesolver;\n\nimport java.util.Scanner;\n\npublic class MazeSolver {\n\n    public static final char START = 'S';\n    public static final char END = 'E';\n    public static final char WALL = 'W';\n    public static final char OPEN = '.';\n    public static final char VISITED = 'V';\n    public static final char ROUTE = '*'; // New character to mark the route\n\n    public static boolean solveMaze(char[][] maze) {\n        int startRow = -1;\n        int startCol = -1;\n\n        // Find the starting point\n        for (int row = 0; row < maze.length; row++) {\n            for (int col = 0; col < maze[row].length; col++) {\n                if (maze[row][col] == START) {\n                    startRow = row;\n                    startCol = col;\n                    break;\n                }\n            }\n        }\n\n        if (startRow == -1 || startCol == -1) {\n            System.out.println(\"Error: Starting point not found in maze\");\n            return false;\n        }\n\n        return solveMazeDFS(maze, startRow, startCol);\n    }\n\n    private static boolean solveMazeDFS(char[][] maze, int row, int col) {\n        // Check if we reached the end or hit a wall/visited cell\n        if (maze[row][col] == END) {\n            return true;\n        } else if (maze[row][col] == WALL || maze[row][col] == VISITED) {\n            return false;\n        }\n\n        // Mark current cell as visited\n        maze[row][col] = VISITED;\n\n        // Try all four directions (up, down, left, right)\n        if (row > 0 && solveMazeDFS(maze, row - 1, col)) {\n            maze[row][col] = ROUTE; // Mark as part of the route on successful return\n            return true; // Found solution going up\n        }\n        if (row < maze.length - 1 && solveMazeDFS(maze, row + 1, col)) {\n            maze[row][col] = ROUTE;\n            return true; // Found solution going down\n        }\n        if (col > 0 && solveMazeDFS(maze, row, col - 1)) {\n            maze[row][col] = ROUTE;\n            return true; // Found solution going left\n        }\n        if (col < maze[row].length - 1 && solveMazeDFS(maze, row, col + 1)) {\n            maze[row][col] = ROUTE;\n            return true; // Found solution going right\n        }\n\n        // Backtrack if no solution found in any direction\n        maze[row][col] = OPEN; // Unmark cell as visited (backtracking)\n        return false;\n    }\n\n    public static void printMaze(char[][] maze) {\n        for (char[] row : maze) {\n            for (char c : row) {\n                System.out.print(c + \" \");\n            }\n            System.out.println();\n        }\n    }\n    \n    public static void main(String[] args) {\n        \n        char[][] maze = new char[1][1];\n        \n        char[][] maze1 = {\n            {'W', 'W', 'W', '.'},\n            {'.', '.', 'S', '.'},\n            {'W', 'W', 'W', '.'},\n            {'W', '.', '.', 'E'}\n        };\n\n        char[][] maze2 = {\n            {'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W'},\n            {'.', '.', '.', '.', 'W', '.', '.', '.', '.', '.'},\n            {'W', 'W', '.', 'W', 'W', '.', 'W', 'W', 'W', 'W'},\n            {'.', '.', 'S', '.', '.', '.', '.', '.', '.', '.'},\n            {'W', 'W', '.', 'W', 'W', 'W', 'W', '.', 'W', 'W'},\n            {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},\n            {'W', 'W', 'W', 'W', '.', 'W', 'W', 'W', 'W', 'W'},\n            {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.'},\n            {'W', 'W', '.', 'W', '.', 'W', '.', 'W', 'W', 'W'},\n            {'.', '.', '.', 'W', '.', '.', '.', '.', '.', '.'},\n            {'.', 'W', 'W', '.', 'W', '.', '.', '.', '.', '.'},\n            {'.', '.', '.', '.', '.', 'W', '.', '.', '.', '.'},\n            {'.', '.', '.', '.', '.', 'W', 'E', 'W', '.', '.'}\n        };\n        \n        char[][] maze3 = {\n            {'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W', 'W'},\n            {'.', '.', '.', '.', 'W', '.', '.', '.', '.', '.'},\n            {'W', 'W', '.', 'W', 'W', '.', 'W', 'W', 'W', 'W'},\n            {'.', '.', 'S', '.', '.', '.', '.', 'W', '.', '.'},\n            {'W', 'W', '.', 'W', 'W', 'W', 'W', 'W', 'W', 'W'},\n            {'.', '.', '.', '.', '.', '.', '.', 'W', '.', 'E'},\n            {'W', 'W', 'W', 'W', '.', 'W', 'W', 'W', '.', 'W'},\n            {'.', '.', '.', '.', '.', '.', '.', 'W', '.', 'W'},\n            {'W', 'W', '.', 'W', '.', 'W', '.', 'W', '.', 'W'},\n            {'.', '.', '.', 'W', '.', '.', '.', 'W', '.', 'W'},\n            {'.', 'W', 'W', '.', 'W', '.', '.', '.', '.', 'W'},\n            {'.', '.', '.', '.', '.', 'W', '.', '.', '.', 'W'},\n            {'.', '.', '.', '.', '.', 'W', 'W', 'W', 'W', 'W'}\n        };\n        \n        char[][] maze4 = {\n            {'W', 'W', 'W', 'W'},\n            {'.', '.', 'S', '.'},\n            {'W', 'W', 'W', '.'},\n            {'W', 'W', '.', '.'},\n            {'W', 'W', '.', '.'},\n            {'W', 'W', 'W', 'W'},\n            {'W', '.', '.', 'E'}\n        };\n\n        String choice;\n        Scanner myScan = new Scanner(System.in);\n        \n        System.out.println(\"Choose maze 1,2 3 or 4\");\n        choice = myScan.nextLine();\n        \n        switch(choice){\n           case \"1\" -> maze = maze1;\n           case \"2\" -> maze = maze2;\n           case \"3\" -> maze = maze3;\n           case \"4\" -> maze = maze4;\n           default ->  {System.out.println(\"Not a choice\");}\n        }\n        \n        \n        printMaze(maze);\n        System.out.println(\"\\n\");\n        \n        if (solveMaze(maze)) {\n            System.out.println(\"Maze solved!\");\n            printMaze(maze); // Print the maze with the solved route\n        } else {\n            System.out.println(\"No solution found for the maze\");\n        }\n    }\n}","position":{"start":{"line":16,"column":1},"end":{"line":178,"column":1}},"key":"Uy673FoYz0"},{"type":"heading","depth":2,"position":{"start":{"line":184,"column":1},"end":{"line":184,"column":1}},"children":[{"type":"text","value":"Sample Output","position":{"start":{"line":184,"column":1},"end":{"line":184,"column":1}},"key":"km057HpukO"}],"identifier":"sample-output","label":"Sample Output","html_id":"sample-output","implicit":true,"key":"vhSZn7Ft56"},{"type":"code","lang":"","value":"Choose maze 1,2 3 or 4\n3\nW W W W W W W W W W \n. . . . W . . . . . \nW W . W W . W W W W \n. . S . . . . W . . \nW W . W W W W W W W \n. . . . . . . W . E \nW W W W . W W W . W \n. . . . . . . W . W \nW W . W . W . W . W \n. . . W . . . W . W \n. W W . W . . . . W \n. . . . . W . . . W \n. . . . . W W W W W \n\n\nMaze solved!\nW W W W W W W W W W \n. . . . W . . . . . \nW W . W W . W W W W \n. . * . . . . W . . \nW W * W W W W W W W \n. . * * * . . W * E \nW W W W * W W W * W \n. . . . * . . W * W \nW W . W * W . W * W \n. . . W * * . W * W \n. W W . W * * * * W \n. . . . . W * * . W \n. . . . . W W W W W ","position":{"start":{"line":186,"column":1},"end":{"line":218,"column":1}},"key":"FW43UQCfjM"}],"key":"qg8z4fyyPQ"}],"key":"qvAZ32pWVP"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"DFS - Stored Paths","url":"/xdfsstoredpaths","group":"Algorithms"},"next":{"title":"Dijkstraâ€™s Algorithm","url":"/xgraphsdijkstra","group":"Algorithms"}}},"domain":"http://localhost:3002"}