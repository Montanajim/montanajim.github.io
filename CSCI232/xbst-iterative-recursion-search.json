{"version":3,"kind":"Article","sha256":"96ec3c3ceee9e082cbd633cf26ac7501471ff2134981c840934a2bf77b0460e2","slug":"xbst-iterative-recursion-search","location":"/xBST_Iterative_Recursion_Search.md","dependencies":[],"frontmatter":{"title":"Demonstrate BST using iterative looping and recursion","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xBST_Iterative_Recursion_Search.md","url":"/CSCI232/build/xBST_Iterative_Recur-4327b51d8ee4c3c79a5c9237d17165a9.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"This Java program implements a ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"f7YNCzRzv2"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Binary Search Tree (BST)","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"M0UOt3kcNQ"}],"key":"j4iISrSmss"},{"type":"text","value":" that supports insertion, searching, and in-order traversal. It generates unique random numbers, inserts them into the BST, and allows the user to search for a specific number using both recursive and iterative approaches.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"nZ9tRdVBXe"}],"key":"J4vm1gHJeV"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"The ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"SW34QygC0A"},{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"inlineCode","value":"Node","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"Qoqte0bPwK"},{"type":"text","value":" class","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"OW0zuPGNEY"}],"key":"dTaTIML7Qs"},{"type":"text","value":" defines a BST node with an integer value and left and right child references. The ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"i5qHFIOg1f"},{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"inlineCode","value":"BST","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"ZDSFQV93MN"},{"type":"text","value":" class","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"i0RTVdZPwh"}],"key":"qQMzd3FBnP"},{"type":"text","value":" manages the BST operations, including inserting new values, searching for values recursively and iteratively, and performing an in-order traversal to display elements in sorted order.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"godtRUaWTZ"}],"key":"VsyTWb7XnH"},{"type":"paragraph","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"In the ","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"lG0dIZOEm3"},{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"main method (","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"pu62DmXOap"},{"type":"inlineCode","value":"BST_Recursion_Loops","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"ew3WaH6YkS"},{"type":"text","value":")","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"Cc3VEmT0m1"}],"key":"EeC321BrFL"},{"type":"text","value":", the program first generates an array of 50 unique random numbers using a ","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"Gtlm1Zd2Q0"},{"type":"inlineCode","value":"HashSet","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"tYjtqxt5AZ"},{"type":"text","value":", ensuring all values are distinct. These numbers are inserted into the BST, and an in-order traversal is performed to display the sorted tree contents. The program then prompts the user to enter a search key and performs both iterative and recursive searches to check for its presence, displaying whether the key was found or not.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"yOwwslRDGY"}],"key":"Dzbm9tEKWp"},{"type":"paragraph","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"This implementation highlights key BST operations and provides a practical demonstration of recursion, loops, and tree traversal techniques in Java.","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"MdIay52oK8"}],"key":"fjq0hhbuec"},{"type":"thematicBreak","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"ycDXUUxpdE"},{"type":"heading","depth":2,"position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"HashSet","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"uOJtNH3vbg"}],"identifier":"hashset","label":"HashSet","html_id":"hashset","implicit":true,"key":"BffGDz6RIE"},{"type":"paragraph","position":{"start":{"line":17,"column":1},"end":{"line":22,"column":1}},"children":[{"type":"text","value":"A HashSet in Java is a part of the java.util package and implements\nthe Set interface. It is used to store a collection of unique elements,\nmeaning it does not allow duplicate values. It is backed by a HashMap,\nwhich makes its operations fast, typically running in O(1) time complexity\nfor basic operations like add, remove, and contains.\nKey Features of HashSet","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"ksqUHEzW4k"}],"key":"CLGRzvC7TT"},{"type":"code","lang":"","value":"No Duplicates –         It does not allow duplicate elements.\nUnordered Collection –  It does not maintain the order of elements.\nAllows Null Values –    It permits a single null value.\nFast Operations –       Add, remove, and search operations are \n                        generally O(1) due to hashing.\nNo Indexing –           Unlike lists,you cannot access elements by an index.","position":{"start":{"line":24,"column":1},"end":{"line":29,"column":1}},"key":"TmWJ4me866"},{"type":"heading","depth":2,"position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"children":[{"type":"text","value":"Demo Code","position":{"start":{"line":33,"column":1},"end":{"line":33,"column":1}},"key":"d7LTtec7SI"}],"identifier":"demo-code","label":"Demo Code","html_id":"demo-code","implicit":true,"key":"jLefYtbCtE"},{"type":"code","lang":"java","value":"/*\n\nDemonstrate iterative and recursive searching\nDeveloper: James Goudy\n */\npackage bst_recursion_loops;\n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Scanner;\nimport org.w3c.dom.css.Counter;\n\n// Class for a Binary Search Tree Node\nclass Node {\n\n    int value;\n    Node left, right;\n\n    public Node(int item) {\n        value = item;\n        left = right = null;\n    }\n}\n\nclass BST {\n\n    int cntr = 1;\n    Node root;\n\n    // Constructor\n    public BST() {\n        root = null;\n    }\n\n    // Recursive Search Function\n    public boolean searchRecursive(Node root, int key) {\n        // Base case: root is null or key is found\n        if (root == null) {\n            return false;\n        }\n        if (root.value == key) {\n            return true;\n        }\n\n        // If the key is smaller, search in the left subtree\n        if (key < root.value) {\n            return searchRecursive(root.left, key);\n        } else {\n            // If the key is larger, search in the right subtree\n            return searchRecursive(root.right, key);\n        }\n    }\n\n    // Iterative Search Function\n    public boolean searchIterative(Node root, int key) {\n        while (root != null) {\n            if (root.value == key) {\n                return true;\n            } else if (key < root.value) {\n                root = root.left;  // Move to left subtree\n            } else {\n                root = root.right; // Move to right subtree\n            }\n        }\n        return false; // Key not found\n    }\n\n    // Insert function to add nodes to the BST\n    public void insert(int key) {\n        root = insertData(root, key);\n    }\n\n    private Node insertData(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n\n        if (key < root.value) {\n            root.left = insertData(root.left, key);\n        } else if (key > root.value) {\n            root.right = insertData(root.right, key);\n        }\n\n        return root;\n    }\n\n    // Helper function to start recursive search from the root\n    public boolean searchRecursive(int key) {\n        return searchRecursive(root, key);\n    }\n\n    // Helper function to start iterative search from the root\n    public boolean searchIterative(int key) {\n        return searchIterative(root, key);\n    }\n\n    // Inorder Traversal to print the BST\n    public void inorder() {\n        cntr = 1;\n        inorderData(root);\n        System.out.println();\n    }\n\n    private void inorderData(Node root) {\n\n        if (root != null) {\n            cntr++;\n\n            if (cntr % 10 == 0 && cntr > 1) {\n                System.out.println(\"\");\n            }\n\n            \n\n            inorderData(root.left);\n            System.out.print(root.value + \" \");\n            inorderData(root.right);\n\n        }\n\n    }\n\n}\n\npublic class BST_Recursion_Loops {\n\n    public static int[] generateUniqueArray(int size) {\n\n        // create new HashSet\n        HashSet<Integer> uniqueNumbers = new HashSet<>();\n\n        Random rng = new Random();\n\n        // Fill the set with unique random numbers\n        while (uniqueNumbers.size() < size) {\n            // Generates numbers from 0 to 999\n            uniqueNumbers.add(rng.nextInt(1000));\n        }\n\n        // Convert HashSet to an array\n        int[] result = new int[size];\n        int index = 0;\n        for (int num : uniqueNumbers) {\n            result[index++] = num;\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n\n        // create sample data\n        int[] sampleKeys;\n        int numOfKeys = 50;\n        int searchKey = 0;\n        String status;\n        \n        \n        \n        Scanner myScan = new Scanner(System.in);\n        BST myBST = new BST();\n\n        sampleKeys = generateUniqueArray(numOfKeys);\n\n        System.out.println(\"\\nInput Data\\n\");\n        for (int i = 0; i < sampleKeys.length; i++) {\n            myBST.insert(sampleKeys[i]);\n            System.out.print(sampleKeys[i] + \" \");\n\n            if (i % 10 == 0 && i > 0) {\n                System.out.println(\"\");\n            }\n        }\n\n        System.out.println(\"\\n-----------------------------\\n\");\n\n        myBST.inorder();\n        \n        System.out.print(\" Enter Search Key: \");\n        searchKey = Integer.parseInt(myScan.nextLine());\n        \n        System.out.println(\"\\nSearch Iteratively\");\n        status = myBST.searchIterative(searchKey)? \"Found\" : \"Not Found\";\n        System.out.println(\"The items was - \" + status);\n        \n        System.out.println(\"\\nSearch Recursively\");\n        status = myBST.searchRecursive(searchKey)? \"Found\" : \"Not Found\";\n        System.out.println(\"The items was - \" + status);\n        \n\n    }\n\n}","position":{"start":{"line":35,"column":1},"end":{"line":230,"column":1}},"key":"CYXzM3hFqJ"}],"key":"zml33sQi76"}],"key":"cxJnp3dhrv"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Tree Traversal","url":"/xbst-treetraversal","group":"Algorithms"},"next":{"title":"Binary Search Tree","url":"/xbst-binarysearchtree","group":"Algorithms"}}},"domain":"http://localhost:3002"}