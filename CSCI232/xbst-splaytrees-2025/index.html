<!DOCTYPE html><html lang="en" class="" style="scroll-padding:60px"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Splay Trees - Algorithms</title><meta property="og:title" content="Splay Trees - Algorithms"/><meta name="generator" content="mystmd"/><meta name="keywords" content=""/><link rel="stylesheet" href="/CSCI232/build/_assets/app-2K3KGISG.css"/><link rel="stylesheet" href="/CSCI232/build/_assets/thebe-core-VKVHG5VY.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jupyter-matplotlib@0.11.3/css/mpl_widget.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"/><link rel="icon" href="/CSCI232/favicon.ico"/><link rel="stylesheet" href="/CSCI232/myst-theme.css"/><script>
  const savedTheme = localStorage.getItem("myst:theme");
  const theme = window.matchMedia("(prefers-color-scheme: light)").matches ? 'light' : 'dark';
  const classes = document.documentElement.classList;
  const hasAnyTheme = classes.contains('light') || classes.contains('dark');
  if (!hasAnyTheme) classes.add(savedTheme ?? theme);
</script></head><body class="m-0 transition-colors duration-500 bg-white dark:bg-stone-900"><div class="myst-skip-to-article fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1" aria-label="skip to content options"><a href="#skip-to-frontmatter" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article frontmatter</a><a href="#skip-to-article" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article content</a></div><dialog id="myst-no-css" style="position:fixed;left:0px;top:0px;width:100%;height:100vh;font-size:4rem;padding:1rem;color:black;background:white"><strong>Site not loading correctly?</strong><p>This may be due to an incorrect <code>BASE_URL</code> configuration. See<!-- --> <a href="https://mystmd.org/guide/deployment#deploy-base-url">the MyST Documentation</a> <!-- -->for reference.</p><script>
    (() => {
            // Test for has-styling variable set by the MyST stylesheet
            const node = document.currentScript.parentNode;
            const hasCSS = window.getComputedStyle(node).getPropertyValue("--has-styling");
            if (hasCSS === ""){
                    node.showModal();
            }

    })()
</script></dialog><div class="myst-top-nav bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 sticky w-full top-0 z-30 h-[60px]"><nav class="myst-top-nav-bar flex items-center justify-between flex-nowrap max-w-[1440px] mx-auto"><div class="flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center shrink-0"><div class="block xl:hidden"><button class="myst-top-nav-menu-button flex items-center justify-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100 w-10 h-10"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem"><path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd"></path></svg><span class="sr-only">Open Menu</span></button></div><a class="myst-home-link flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7" href="/CSCI232/"><span class="text-md sm:text-xl tracking-tight sm:mr-5">CSCI 211</span></a></div><div class="flex items-center flex-grow w-auto"><div class="flex-grow hidden text-md lg:block"></div><div class="flex-grow block"></div><button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R75cp:" data-state="closed" class="myst-search-bar flex items-center h-10 aspect-square sm:w-64 text-left text-gray-600 dark:text-gray-300 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 myst-search-bar-disabled hover:ring-blue-500 dark:hover:ring-blue-500 hover:border-blue-500 dark:hover:border-blue-500"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="p-2.5 h-10 w-10 aspect-square"><path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd"></path></svg><span class="myst-search-text-placeholder hidden sm:block grow">Search</span><div aria-hidden="true" class="myst-search-shortcut items-center hidden mx-1 font-mono text-sm text-gray-600 dark:text-gray-300 sm:flex gap-x-1"><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none hide-mac">CTRL</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none show-mac">⌘</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none ">K</kbd><script>
;(() => {
const script = document.currentScript;
const root = script.parentElement;

const isMac = /mac/i.test(
      window.navigator.userAgentData?.platform ?? window.navigator.userAgent,
    );
root.querySelectorAll(".hide-mac").forEach(node => {node.classList.add(isMac ? "hidden" : "block")});
root.querySelectorAll(".show-mac").forEach(node => {node.classList.add(!isMac ? "hidden" : "block")});
})()</script></div></button><button class="myst-theme-button theme rounded-full aspect-square border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 w-10 h-10 mx-3" title="Toggle theme between light and dark mode" aria-label="Toggle theme between light and dark mode"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-moon-icon h-full w-full p-0.5 hidden dark:block"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z" clip-rule="evenodd"></path></svg><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-sun-icon h-full w-full p-0.5 dark:hidden"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"></path></svg></button><div class="block sm:hidden"></div><div class="hidden sm:block"></div></div></nav></div><div class="myst-primary-sidebar fixed xl:article-grid grid-gap xl:w-full xl:pointer-events-none overflow-auto max-xl:w-[75vw] max-xl:max-w-[350px] max-xl:!top-0 max-xl:h-screen hidden z-10" style="top:60px"><div class="myst-primary-sidebar-pointer pointer-events-auto xl:col-margin-left flex-col overflow-hidden max-xl:h-full hidden xl:flex"><div class="myst-primary-sidebar-nav flex-grow py-6 overflow-y-auto primary-scrollbar"><nav aria-label="Navigation" class="myst-primary-sidebar-topnav overflow-y-hidden transition-opacity lg:hidden ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="w-full px-1 dark:text-white font-medium"></div></nav><div class="my-3 border-b-2 lg:hidden"></div><nav aria-label="Table of Contents" class="myst-primary-sidebar-toc flex-grow overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="myst-toc w-full px-1 dark:text-white"><a title="Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30 font-bold" href="/CSCI232/">Algorithms</a><a title="CSCI 232 Data Structures and Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xcsci232-intro">CSCI 232 Data Structures and Algorithms</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Terms and Concepts" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xterms">Terms and Concepts</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:Rupsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:Rupsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Binary Search Tree - Intro" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xbst-intro">Binary Search Tree - Intro</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R16psp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R16psp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Hash Table" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xhashing-hashtable">Hash Table</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1epsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1epsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="Skip List" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xskiplist">Skip List</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Graphs" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xgraphs">Graphs</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1upsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1upsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="Huffman Code" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xhuffmancode">Huffman Code</a><a title="Serialization" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xserializable">Serialization</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 pl-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="JAVA Techniques" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/CSCI232/xjavatechniques">JAVA Techniques</a><button class="self-stretch flex items-center flex-none px-1 rounded-l-md group hover:bg-slate-300/30 focus-visible:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R2mpsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R2mpsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="End" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/CSCI232/xend">End</a></div></nav></div><div class="myst-primary-sidebar-footer flex-none py-6 transition-all duration-700 translate-y-6 opacity-0 ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="article footer myst-primary-sidebar-footer"><p>© 2026 by James Goudy</p></div></div></div></div><main class="article-grid grid-gap"><article class="article-grid subgrid-gap col-screen article content"><div class="hidden"></div><div id="skip-to-frontmatter" aria-label="article frontmatter" class="myst-fm-block mb-8 pt-9"><div class="myst-fm-block-header flex items-center mb-5 h-6 text-sm font-light"><div class="flex-grow"></div><div class="myst-fm-block-badges"><a href="https://github.com/executablebooks/jupyter-book" title="GitHub Repository: executablebooks/jupyter-book" target="_blank" rel="noopener noreferrer" class="myst-fm-github-link text-inherit hover:text-inherit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" width="1.25rem" height="1.25rem" class="myst-fm-github-icon inline-block mr-1 opacity-60 hover:opacity-100"><path d="M12 2.5c-5.4 0-9.8 4.4-9.8 9.7 0 4.3 2.8 8 6.7 9.2.5.1.7-.2.7-.5v-1.8c-2.4.5-3.1-.6-3.3-1.1-.1-.3-.6-1.1-1-1.4-.3-.2-.8-.6 0-.6s1.3.7 1.5 1c.9 1.5 2.3 1.1 2.8.8.1-.6.3-1.1.6-1.3-2.2-.2-4.4-1.1-4.4-4.8 0-1.1.4-1.9 1-2.6-.1-.2-.4-1.2.1-2.6 0 0 .8-.3 2.7 1 .8-.2 1.6-.3 2.4-.3.8 0 1.7.1 2.4.3 1.9-1.3 2.7-1 2.7-1 .5 1.3.2 2.3.1 2.6.6.7 1 1.5 1 2.6 0 3.7-2.3 4.6-4.4 4.8.4.3.7.9.7 1.8V21c0 .3.2.6.7.5 3.9-1.3 6.6-4.9 6.6-9.2 0-5.4-4.4-9.8-9.8-9.8z"></path></svg></a></div><div class="myst-fm-downloads-dropdown relative flex inline-block mx-1 grow-0" data-headlessui-state=""><button class="myst-fm-downloads-button relative ml-2 -mr-1" id="headlessui-menu-button-:Rs8ucp:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Downloads</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.25rem" height="1.25rem" class="myst-fm-downloads-icon"><title>Download</title><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"></path></svg></button></div></div><h1 class="myst-fm-block-title mb-0">Splay Trees</h1><header class="myst-fm-authors-affiliations mt-4 not-prose"><div class="myst-fm-authors-list"><span class="myst-fm-author font-semibold text-sm myst-fm-author-item inline-block"><button class="myst-fm-author-popover focus:shadow-[0_0_0_2px] focus:shadow-black outline-none hover:underline" aria-label="Author Details" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R78ucp:" data-state="closed"><span class="myst-fm-author-name">James Goudy</span></button></span></div></header></div><div class="block my-10 lg:sticky lg:z-10 lg:h-0 lg:pt-0 lg:my-0 lg:ml-10 lg:col-margin-right" style="top:60px"><nav></nav></div><div id="skip-to-article"></div><h2 id="splay-trees" class="relative group"><span class="heading-text">Splay Trees</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#splay-trees" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><p>A <strong>splay tree</strong> is a type of self-adjusting binary search tree (BST) where recently accessed elements are moved to the root of the tree using a process called <em>splaying</em>. This helps ensure that frequently accessed elements are quicker to access.</p><h2 id="who-invented-it" class="relative group"><span class="heading-text">Who Invented It:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#who-invented-it" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li>Splay trees were invented by <strong>Daniel Sleator</strong> and <strong>Robert Tarjan</strong> in 1985. The invention was part of their research on self-adjusting data structures.</li></ul><h3 id="when-was-it-invented" class="relative group"><span class="heading-text">When Was It Invented:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#when-was-it-invented" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><ul><li>The splay tree was introduced in <strong>1985</strong>.</li></ul><h2 id="major-uses" class="relative group"><span class="heading-text">Major Uses:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#major-uses" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li><strong>Dynamic sets</strong>: Splay trees are used to maintain a dynamic set of elements that can support a variety of search and update operations.</li><li><strong>Memory-efficient</strong>: Since splay trees do not require additional space for balancing data like AVL trees or Red-Black trees, they can be more memory-efficient.</li><li><strong>Efficient in practice for certain workloads</strong>: Splay trees perform well when there are repeated accesses to a small subset of elements (i.e., the access pattern exhibits locality).</li></ul><h2 id="typical-applications" class="relative group"><span class="heading-text">Typical Applications:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#typical-applications" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li><strong>Cache systems</strong>: Frequently accessed items bubble to the front.</li><li><strong>Text editors</strong>: Recently opened files or commands can be organized in a splay list.</li><li><strong>Autocomplete lists</strong>: Recently or frequently used search terms are moved to the front.</li></ul><h2 id="insert-function" class="relative group"><span class="heading-text">Insert Function:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#insert-function" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li><strong>Insertion in a splay tree</strong> is similar to that in a regular binary search tree. The node is inserted following the normal BST rules. However, after insertion, the tree is “splayed” to bring the newly inserted node to the root.</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">public void insert(int value) {
    root = insertRec(root, value);
    splay(root, value);
}

private Node insertRec(Node root, int value) {
    if (root == null) {
        root = new Node(value);
        return root;
    }

    if (value &lt; root.data) {
        root.left = insertRec(root.left, value);
    } else if (value &gt; root.data) {
        root.right = insertRec(root.right, value);
    }

    return root;
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="delete-function" class="relative group"><span class="heading-text">Delete Function:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#delete-function" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li><strong>Deletion</strong> is performed in the same way as in a normal binary search tree. After finding the node to delete, it is removed, and then the tree is splayed to restore the tree’s structure.</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">public void delete(int value) {
    root = deleteRec(root, value);
}

private Node deleteRec(Node root, int value) {
    if (root == null) return root;

    if (value &lt; root.data) {
        root.left = deleteRec(root.left, value);
    } else if (value &gt; root.data) {
        root.right = deleteRec(root.right, value);
    } else {
        // node with value found
        if (root.left == null) return root.right;
        else if (root.right == null) return root.left;
    }

    return root;
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="find-function" class="relative group"><span class="heading-text">Find Function:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#find-function" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li>The <strong>find function</strong> searches for a value in the tree, and if the value is found, it performs a splay operation to bring that value to the root. If the value is not found, the tree remains unchanged.</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">public boolean find(int value) {
    root = splay(root, value);
    return (root != null &amp;&amp; root.data == value);
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="rules-for-rotations" class="relative group"><span class="heading-text">Rules for Rotations:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#rules-for-rotations" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li>Splay trees use three types of rotations to adjust the tree during splaying:<ol start="1"><li><strong>Zig</strong>: When the node is the child of the root.</li><li><strong>Zig-Zig</strong>: When the node is the left or right child of a left or right child (two-level deep).</li><li><strong>Zig-Zag</strong>: When the node is the left child of the right child or the right child of the left child.</li></ol></li></ul><h2 id="rotations" class="relative group"><span class="heading-text">Rotations:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#rotations" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ul><li><strong>Single Rotation (Zig)</strong>: If the node is the child of the root, perform a single rotation (right or left depending on the situation).</li><li><strong>Double Rotation (Zig-Zig or Zig-Zag)</strong>: In these cases, two rotations are needed. They help in cases where the tree has more than one level to adjust.</li></ul><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">private Node splay(Node root, int value) {
    if (root == null || root.data == value) return root;

    if (value &lt; root.data) {
        if (root.left == null) return root;
        if (value &lt; root.left.data) {
            root.left.left = splay(root.left.left, value);
            root = rotateRight(root);
        } else if (value &gt; root.left.data) {
            root.left.right = splay(root.left.right, value);
            if (root.left.right != null) {
                root.left = rotateLeft(root.left);
            }
        }
        return (root.left == null) ? root : rotateRight(root);
    } else {
        if (root.right == null) return root;
        if (value &gt; root.right.data) {
            root.right.right = splay(root.right.right, value);
            root = rotateLeft(root);
        } else if (value &lt; root.right.data) {
            root.right.left = splay(root.right.left, value);
            if (root.right.left != null) {
                root.right = rotateRight(root.right);
            }
        }
        return (root.right == null) ? root : rotateLeft(root);
    }
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="java-program-demonstrating-insert-find-delete-and-pretty-print" class="relative group"><span class="heading-text">Java Program Demonstrating Insert, Find, Delete, and Pretty Print:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#java-program-demonstrating-insert-find-delete-and-pretty-print" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">package inst_splay_2025;

class SplayTree {

    private Node root;

    // Inner class representing a node in the splay tree
    class Node {

        int data;
        Node left, right;

        public Node(int item)
        {
            data = item;
            left = right = null;
        }
    }

    // Inserts a value into the tree
    public void insert(int value)
    {
        if (root == null) {
            root = new Node(value);
            return;
        }

        // Splay the tree to bring the value (or closest) to the root
        root = splay(root, value);

        // If the value already exists, no need to insert
        if (root.data == value) {
            return;
        }

        Node newNode = new Node(value);

        // If the new value is smaller, make the new node root and adjust pointers
        if (value &lt; root.data) {
            newNode.right = root;
            newNode.left = root.left;
            root.left = null;
        } else { // If the new value is greater
            newNode.left = root;
            newNode.right = root.right;
            root.right = null;
        }

        root = newNode; // Update root
    }

    // Searches for a value in the tree
    public boolean find(int value)
    {
        root = splay(root, value);
        return (root != null &amp;&amp; root.data == value);
    }

    // Deletes a node with the given value
    public void delete(int value)
    {
        if (root == null) {
            return;
        }

        // Splay the tree so that the value (or closest) is at the root
        root = splay(root, value);

        if (root.data != value) {
            return; // If not found, do nothing
        }
        if (root.left == null) {
            root = root.right;
        } else {
            Node temp = root;
            // Splay the largest node in the left subtree to make it new root
            root = splay(root.left, value);
            root.right = temp.right;
        }
    }

    // Right rotation (Zig rotation)
    private Node rotateRight(Node root)
    {
        if (root == null || root.left == null) {
            return root;
        }
        Node newRoot = root.left;
        root.left = newRoot.right;
        newRoot.right = root;
        return newRoot;
    }

    // Left rotation (Zag rotation)
    private Node rotateLeft(Node root)
    {
        if (root == null || root.right == null) {
            return root;
        }
        Node newRoot = root.right;
        root.right = newRoot.left;
        newRoot.left = root;
        return newRoot;
    }

    /*
     * Splay Operation: Moves the given value to the root if present, or the closest value.
     * 
     * Splay tree follows these rules for rotations:
     * 
     * - Zig Rotation (Single Right): When the value is in the left child of the root.
     * - Zag Rotation (Single Left): When the value is in the right child of the root.
     * - Zig-Zig (Double Right Rotation): When the value is in the left child of the left child.
     * - Zag-Zag (Double Left Rotation): When the value is in the right child of the right child.
     * - Zig-Zag (Left-Right Rotation): When the value is in the right child of the left child.
     * - Zag-Zig (Right-Left Rotation): When the value is in the left child of the right child.
     */
    private Node splay(Node root, int value)
    {
        if (root == null || root.data == value) {
            return root;
        }

        if (value &lt; root.data) {
            if (root.left == null) {
                return root;
            }

            // Zig-Zig case (left-left)
            if (value &lt; root.left.data) {
                root.left.left = splay(root.left.left, value);
                root = rotateRight(root);
            } // Zig-Zag case (left-right)
            else if (value &gt; root.left.data) {
                root.left.right = splay(root.left.right, value);
                if (root.left.right != null) {
                    root.left = rotateLeft(root.left);
                }
            }

            // Perform a final Zig rotation
            return (root.left == null) ? root : rotateRight(root);
        } else {
            if (root.right == null) {
                return root;
            }

            // Zag-Zag case (right-right)
            if (value &gt; root.right.data) {
                root.right.right = splay(root.right.right, value);
                root = rotateLeft(root);
            } // Zag-Zig case (right-left)
            else if (value &lt; root.right.data) {
                root.right.left = splay(root.right.left, value);
                if (root.right.left != null) {
                    root.right = rotateRight(root.right);
                }
            }

            // Perform a final Zag rotation
            return (root.right == null) ? root : rotateLeft(root);
        }
    }

    // Prints the tree structure
    public void prettyPrint(Node root, String indent)
    {
        if (root == null) {
            return;
        }
        prettyPrint(root.right, indent + &quot;   &quot;);
        System.out.println(indent + root.data);
        prettyPrint(root.left, indent + &quot;   &quot;);
    }

    // Initiates tree printing
    public void printTree()
    {
        prettyPrint(root, &quot;&quot;);
    }
}

// Driver class to test the Splay Tree implementation
public class Inst_splay_2025 {

    public static void main(String[] args)
    {
        SplayTree tree = new SplayTree();

        tree.insert(10);
        tree.insert(20);
        tree.insert(5);
        tree.insert(55);
        tree.insert(60);
        tree.insert(65);
        tree.insert(70);
        tree.insert(75);
        tree.insert(30);
        tree.insert(15);
        tree.insert(25);

        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.find(20);
        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.find(5);
        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.find(65);
        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.delete(10);
        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.delete(30);
        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.delete(15);
        tree.printTree();
        System.out.println(&quot;\n----------------\n&quot;);

        tree.delete(5);
        tree.printTree();
    }
}

</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="explanation-of-rotation-rules" class="relative group"><span class="heading-text">Explanation of Rotation Rules:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#explanation-of-rotation-rules" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ol start="1"><li><strong>Zig (Single Rotation)</strong>: If the node to be accessed is the left or right child of the root, perform a single rotation (either left or right).</li><li><strong>Zig-Zig (Double Rotation)</strong>: If the node is the left or right child of a left or right child (two levels deep), perform two rotations. This optimizes the tree by rotating both the node and its parent.</li><li><strong>Zig-Zag (Double Rotation)</strong>: If the node is the left child of the right child, or the right child of the left child (mixed child directions), perform a rotation on the child followed by a rotation on the node itself.</li></ol><p>This program demonstrates how to use splay tree operations and includes helpful comments and explanations of the rotation rules. Each rotation helps ensure the tree remains balanced by moving frequently accessed nodes towards the root.</p><hr class="py-2 my-5 translate-y-2"/><h2 id="splay-using-for-loops" class="relative group"><span class="heading-text">Splay using for loops</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#splay-using-for-loops" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><p>This version avoids the recursive calls and uses loops to handle the tree traversal and adjustments.</p><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">class SplayTree {
    private Node root;

    // Node class to represent each node in the tree
    class Node {
        int data;  // Data stored in the node
        Node left, right;  // Left and right child nodes

        // Constructor to create a new node with the given value
        public Node(int item) {
            data = item;
            left = right = null;
        }
    }

    // Insert function to add a new value into the splay tree
    public void insert(int value) {
        if (root == null) {
            root = new Node(value);  // If tree is empty, create a new node as root
            return;
        }

        Node node = root;
        Node parent = null;

        // Loop to find the correct position for insertion
        while (node != null) {
            parent = node;
            if (value &lt; node.data) {
                node = node.left;
            } else if (value &gt; node.data) {
                node = node.right;
            } else {
                return;  // If the value is already present, do nothing
            }
        }

        // Create a new node and attach it to the parent
        node = new Node(value);
        if (value &lt; parent.data) {
            parent.left = node;
        } else {
            parent.right = node;
        }

        // After insertion, splay the tree to bring the inserted node to the root
        root = splay(root, value);
    }

    // Delete function to remove a node from the splay tree
    public void delete(int value) {
        if (root == null) return;

        // Splay the tree to bring the node to be deleted to the root
        root = splay(root, value);

        if (root == null || root.data != value) return;  // Node not found

        // Node to be deleted is at the root
        if (root.left == null) {
            root = root.right;  // If left child is null, replace root with right child
        } else {
            Node rightSubtree = root.right;
            root = root.left;
            root = splay(root, value);  // Splay the left subtree to bring the max element to the root
            root.right = rightSubtree;  // Attach the right subtree to the new root
        }
    }

    // Find function to search for a value in the splay tree
    public boolean find(int value) {
        if (root == null) return false;

        // Splay the tree to bring the searched node to the root
        root = splay(root, value);

        return (root != null &amp;&amp; root.data == value);
    }

    // Function to perform a right rotation on the tree (used during splaying)
    private Node rotateRight(Node root) {
        Node newRoot = root.left;  // Make the left child the new root
        root.left = newRoot.right;  // Make the right child of the new root the left child of the old root
        newRoot.right = root;  // Make the old root the right child of the new root
        return newRoot;  // Return the new root
    }

    // Function to perform a left rotation on the tree (used during splaying)
    private Node rotateLeft(Node root) {
        Node newRoot = root.right;  // Make the right child the new root
        root.right = newRoot.left;  // Make the left child of the new root the right child of the old root
        newRoot.left = root;  // Make the old root the left child of the new root
        return newRoot;  // Return the new root
    }

    // Splay function to bring the node with the given value to the root
    private Node splay(Node root, int value) {
        while (root != null) {
            // Base case: if the node is found or we reach the leaf, break out of the loop
            if (root.data == value) return root;

            // Zig (single rotation): If the node is the left child or right child of the root
            if (value &lt; root.data) {
                if (root.left == null) break;  // If there&#x27;s no left child, stop

                // Zig-Zig (double rotation): If node&#x27;s value is in the left subtree of left child
                if (value &lt; root.left.data) {
                    root = rotateRight(root);
                } else if (value &gt; root.left.data) {
                    // Zig-Zag (double rotation): If node&#x27;s value is in the right subtree of left child
                    root.left = rotateLeft(root.left);
                    root = rotateRight(root);
                }
            } else {
                if (root.right == null) break;  // If there&#x27;s no right child, stop

                // Zig-Zig (double rotation): If node&#x27;s value is in the right subtree of right child
                if (value &gt; root.right.data) {
                    root = rotateLeft(root);
                } else if (value &lt; root.right.data) {
                    // Zig-Zag (double rotation): If node&#x27;s value is in the left subtree of right child
                    root.right = rotateRight(root.right);
                    root = rotateLeft(root);
                }
            }
        }
        return root;
    }

    // Pretty print function to display the tree visually
    public void prettyPrint(Node root, String indent) {
        if (root == null) return;  // If the root is null, return

        // Print the right subtree first with increased indentation
        prettyPrint(root.right, indent + &quot;   &quot;);
        System.out.println(indent + root.data);  // Print the current node
        // Print the left subtree with increased indentation
        prettyPrint(root.left, indent + &quot;   &quot;);
    }

    // Wrapper function to print the tree
    public void printTree() {
        prettyPrint(root, &quot;&quot;);  // Call the prettyPrint function starting from the root
    }

    public static void main(String[] args) {
        SplayTree tree = new SplayTree();

        // Inserting values into the tree
        tree.insert(10);
        tree.insert(20);
        tree.insert(30);
        tree.insert(15);

        // Pretty print the tree after insertion
        System.out.println(&quot;Tree after insertion:&quot;);
        tree.printTree();

        // Find a value in the tree and bring it to the root
        tree.find(20);
        System.out.println(&quot;\nTree after finding 20:&quot;);
        tree.printTree();

        // Delete a value from the tree
        tree.delete(10);
        System.out.println(&quot;\nTree after deleting 10:&quot;);
        tree.printTree();
    }
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="explanation-of-changes" class="relative group"><span class="heading-text">Explanation of Changes:</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#explanation-of-changes" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><ol start="1"><li><strong>Insert Method</strong>: The insertion now uses a loop to traverse the tree and find the correct position to insert the new node. The insertion process is followed by a splay operation to move the newly inserted node to the root.</li><li><strong>Delete Method</strong>: Similar to insertion, the delete method now uses a loop to traverse the tree and delete the node. It also includes a splay operation to move the necessary nodes after deletion.</li><li><strong>Splay Method</strong>: The splay function has been rewritten to use a loop instead of recursion. It continuously adjusts the tree until the target node is either found or no further adjustments are necessary.</li><li><strong>Rotation Methods</strong>: The left and right rotations remain the same, as these are simple tree manipulations that don’t depend on recursion.</li></ol><p>This approach eliminates recursion in favor of iterative methods using loops, which may help avoid potential stack overflow issues with deep trees, though it may still be less efficient compared to a more balanced tree like an AVL or Red-Black tree. However, the splay tree performs well with specific access patterns, especially when there is locality of reference.</p><div class="myst-backmatter-parts"></div><div class="myst-footer-links flex pt-10 mb-10 space-x-4"><a class="myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700 myst-footer-link-prev" href="/CSCI232/xbst-comparisiontable"><div class="flex h-full align-middle"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="myst-footer-link-icon self-center transition-transform group-hover:-translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"></path></svg><div class="flex-grow text-right"><div class="myst-footer-link-group text-xs text-gray-500 dark:text-gray-400">Algorithms</div>BST AVL Red Black Tree Comparisons</div></div></a><a class="myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700 myst-footer-link-next" href="/CSCI232/xhashing-hashtable"><div class="flex h-full align-middle"><div class="flex-grow"><div class="myst-footer-link-group text-xs text-gray-500 dark:text-gray-400">Algorithms</div>Hash Table</div><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="myst-footer-link-icon self-center transition-transform group-hover:translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"></path></svg></div></a></div></article></main><script>((a,l)=>{if(!window.history.state||!window.history.state.key){let u=Math.random().toString(32).slice(2);window.history.replaceState({key:u},"")}try{let d=JSON.parse(sessionStorage.getItem(a)||"{}")[l||window.history.state.key];typeof d=="number"&&window.scrollTo(0,d)}catch(u){console.error(u),sessionStorage.removeItem(a)}})("positions", null)</script><link rel="modulepreload" href="/CSCI232/build/entry.client-PCJPW7TK.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-AQ2CODAG.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-JJXTQVMA.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-OZE3FFNP.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-G62B6HZR.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-C4DFGG5C.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-J7TUH54J.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-FZ2S7OYD.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-JEM6JXYA.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-34XIY2DH.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-KQM5FBHR.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-OCWQY3HK.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-7HNKBP4B.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-CUKUDK3R.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-3EBOCCHJ.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-O4VQNZ62.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-4OEDG4JQ.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-GUCIBHGO.js"/><link rel="modulepreload" href="/CSCI232/build/root-PMP5BIHC.js"/><link rel="modulepreload" href="/CSCI232/build/_shared/chunk-IX5KPAHP.js"/><link rel="modulepreload" href="/CSCI232/build/routes/$-5ZLZ2O3Y.js"/><script>window.__remixContext = {"url":"/xbst-splaytrees-2025","state":{"loaderData":{"root":{"config":{"version":2,"myst":"1.6.0","options":{"logo_text":"CSCI 211","folders":true},"parts":{"primary_sidebar_footer":{"mdast":{"type":"root","children":[{"type":"block","data":{"part":"primary_sidebar_footer"},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"© 2026 by James Goudy","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JNqyZV4dE3"}],"key":"rHtYhRJkF4"}],"key":"Q6hsjbFdwJ"}],"key":"bEhouLfs9N"},"frontmatter":{"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024"}}},"nav":[],"actions":[],"projects":[{"bibliography":["C:\\a_books\\CSCI232_algobook\\references.bib"],"exports":[],"title":"Algorithms","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","toc":[{"file":"intro.md"},{"file":"xCSCI232_Intro.md"},{"children":[{"file":"xTerms_Radix.md"},{"file":"xTerms_Serializable.md"},{"file":"xTerms_Iterator.md"}],"file":"xTerms.md"},{"children":[{"file":"xBST_Applications.md"},{"file":"xBST_Comparisons.md"},{"file":"xBST_TreeTraversal.md"},{"file":"xBST_Iterative_Recursion_Search.md"},{"file":"xBST_BinarySearchTree.md"},{"file":"xBST_AVLTree.md"},{"file":"xBST_RedBlack.md"},{"file":"xBST_ComparisionTable.md"},{"file":"xBST_SplayTrees_2025.md"}],"file":"xBST_Intro.md"},{"children":[{"file":"xHashing_UnderstandingHashTables.md"},{"file":"xHashing_ModulusHashFunction.md"},{"file":"xHashing_Chaining.md"},{"file":"xHashing_OpenAddressing.md"},{"file":"xHashing_OpenAddressingHashingCodeExamples.md"}],"file":"xHashing_HashTable.md"},{"file":"xSkipList.md"},{"children":[{"file":"xGraphsAnalysisOfBFSandDFS.md"},{"file":"xUnderstandingBFS_202504.md"},{"file":"xUnderstandingDFS_202504.md"},{"file":"xGraphsSevenBridges.md"},{"file":"xGraphsDFS.md"},{"file":"xGraphsBFS.md"},{"file":"xDFSStoredPaths.md"},{"file":"xGraphsMazeSolverDFS.md"},{"file":"xGraphsDijkstra.md"}],"file":"xGraphs.md"},{"file":"xHuffmanCode.md"},{"file":"xSerializable.md"},{"children":[{"file":"xJavaHashMapTreeMapLinkedHashMap.md"},{"file":"xHashSetLinkedHashSetTreeSetComparision.md"},{"file":"xProgrammingToTheInterfacemd.md"}],"file":"xJAVATechniques.md"},{"file":"xEnd.md"}],"index":"index","pages":[{"slug":"xcsci232-intro","title":"CSCI 232 Data Structures and Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms","title":"Terms and Concepts","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms-radix","title":"Radix - Number Bases","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-serializable","title":"Serializable","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-iterator","title":"Iterator","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-intro","title":"Binary Search Tree - Intro","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbst-applications","title":"Applications That Use Binary Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisons","title":"Binary Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-treetraversal","title":"Tree Traversal","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-iterative-recursion-search","title":"Demonstrate BST using iterative looping and recursion","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-binarysearchtree","title":"Binary Search Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-avltree","title":"AVL Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-redblack","title":"Red Black Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisiontable","title":"BST AVL Red Black Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-splaytrees-2025","title":"Splay Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-hashtable","title":"Hash Table","description":"","date":"","thumbnail":"/CSCI232/build/f694c399ae1cdea2e011d1ecd6ed8d9d.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xhashing-understandinghashtables","title":"Understanding Hash Tables and Hash Functions*","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-modulushashfunction","title":"Modulus Hash Function","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-chaining","title":"Hash Tables - Chaining","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressing","title":"Hash Table - Open Addressing","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressinghashingcodeexamples","title":"Java code for double hashing in a hash table:","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xskiplist","title":"Skip List","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphs","title":"Graphs","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphsanalysisofbfsanddfs","title":"A Comparative Analysis of Breadth-First Search and Depth-First Search Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingbfs-202504","title":"Understanding Breadth-First Search (BFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingdfs-202504","title":"Understanding Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphssevenbridges","title":"Seven Bridges of Königsberg","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdfs","title":"Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsbfs","title":"Breadth First","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdfsstoredpaths","title":"DFS - Stored Paths","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsmazesolverdfs","title":"DSF - Maze Solving","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdijkstra","title":"Dijkstra’s Algorithm","description":"","date":"","thumbnail":"/CSCI232/build/dijkstra_example-8cca3c2c620cd1d44d2c9745b698d02d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhuffmancode","title":"Huffman Code","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xserializable","title":"Serialization","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavatechniques","title":"JAVA Techniques","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavahashmaptreemaplinkedhashmap","title":"Examples of Java’s HashMap, TreeMap, and LinkedHashMap","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashsetlinkedhashsettreesetcomparision","title":"HashSet, LinkedHashSet, and TreeSet Comparision","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xprogrammingtotheinterfacemd","title":"Programming To The Interface, Not The Implementation\"","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}]},"CONTENT_CDN_PORT":"3100","MODE":"static","BASE_URL":"/CSCI232"},"routes/$":{"config":{"version":2,"myst":"1.6.0","options":{"logo_text":"CSCI 211","folders":true},"parts":{"primary_sidebar_footer":{"mdast":{"type":"root","children":[{"type":"block","data":{"part":"primary_sidebar_footer"},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"© 2026 by James Goudy","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JNqyZV4dE3"}],"key":"rHtYhRJkF4"}],"key":"Q6hsjbFdwJ"}],"key":"bEhouLfs9N"},"frontmatter":{"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024"}}},"nav":[],"actions":[],"projects":[{"bibliography":["C:\\a_books\\CSCI232_algobook\\references.bib"],"exports":[],"title":"Algorithms","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","toc":[{"file":"intro.md"},{"file":"xCSCI232_Intro.md"},{"children":[{"file":"xTerms_Radix.md"},{"file":"xTerms_Serializable.md"},{"file":"xTerms_Iterator.md"}],"file":"xTerms.md"},{"children":[{"file":"xBST_Applications.md"},{"file":"xBST_Comparisons.md"},{"file":"xBST_TreeTraversal.md"},{"file":"xBST_Iterative_Recursion_Search.md"},{"file":"xBST_BinarySearchTree.md"},{"file":"xBST_AVLTree.md"},{"file":"xBST_RedBlack.md"},{"file":"xBST_ComparisionTable.md"},{"file":"xBST_SplayTrees_2025.md"}],"file":"xBST_Intro.md"},{"children":[{"file":"xHashing_UnderstandingHashTables.md"},{"file":"xHashing_ModulusHashFunction.md"},{"file":"xHashing_Chaining.md"},{"file":"xHashing_OpenAddressing.md"},{"file":"xHashing_OpenAddressingHashingCodeExamples.md"}],"file":"xHashing_HashTable.md"},{"file":"xSkipList.md"},{"children":[{"file":"xGraphsAnalysisOfBFSandDFS.md"},{"file":"xUnderstandingBFS_202504.md"},{"file":"xUnderstandingDFS_202504.md"},{"file":"xGraphsSevenBridges.md"},{"file":"xGraphsDFS.md"},{"file":"xGraphsBFS.md"},{"file":"xDFSStoredPaths.md"},{"file":"xGraphsMazeSolverDFS.md"},{"file":"xGraphsDijkstra.md"}],"file":"xGraphs.md"},{"file":"xHuffmanCode.md"},{"file":"xSerializable.md"},{"children":[{"file":"xJavaHashMapTreeMapLinkedHashMap.md"},{"file":"xHashSetLinkedHashSetTreeSetComparision.md"},{"file":"xProgrammingToTheInterfacemd.md"}],"file":"xJAVATechniques.md"},{"file":"xEnd.md"}],"index":"index","pages":[{"slug":"xcsci232-intro","title":"CSCI 232 Data Structures and Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms","title":"Terms and Concepts","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms-radix","title":"Radix - Number Bases","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-serializable","title":"Serializable","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-iterator","title":"Iterator","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-intro","title":"Binary Search Tree - Intro","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbst-applications","title":"Applications That Use Binary Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisons","title":"Binary Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-treetraversal","title":"Tree Traversal","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-iterative-recursion-search","title":"Demonstrate BST using iterative looping and recursion","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-binarysearchtree","title":"Binary Search Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-avltree","title":"AVL Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-redblack","title":"Red Black Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisiontable","title":"BST AVL Red Black Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-splaytrees-2025","title":"Splay Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-hashtable","title":"Hash Table","description":"","date":"","thumbnail":"/CSCI232/build/f694c399ae1cdea2e011d1ecd6ed8d9d.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xhashing-understandinghashtables","title":"Understanding Hash Tables and Hash Functions*","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-modulushashfunction","title":"Modulus Hash Function","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-chaining","title":"Hash Tables - Chaining","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressing","title":"Hash Table - Open Addressing","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressinghashingcodeexamples","title":"Java code for double hashing in a hash table:","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xskiplist","title":"Skip List","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphs","title":"Graphs","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphsanalysisofbfsanddfs","title":"A Comparative Analysis of Breadth-First Search and Depth-First Search Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingbfs-202504","title":"Understanding Breadth-First Search (BFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingdfs-202504","title":"Understanding Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphssevenbridges","title":"Seven Bridges of Königsberg","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdfs","title":"Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsbfs","title":"Breadth First","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdfsstoredpaths","title":"DFS - Stored Paths","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsmazesolverdfs","title":"DSF - Maze Solving","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdijkstra","title":"Dijkstra’s Algorithm","description":"","date":"","thumbnail":"/CSCI232/build/dijkstra_example-8cca3c2c620cd1d44d2c9745b698d02d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhuffmancode","title":"Huffman Code","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xserializable","title":"Serialization","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavatechniques","title":"JAVA Techniques","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavahashmaptreemaplinkedhashmap","title":"Examples of Java’s HashMap, TreeMap, and LinkedHashMap","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashsetlinkedhashsettreesetcomparision","title":"HashSet, LinkedHashSet, and TreeSet Comparision","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xprogrammingtotheinterfacemd","title":"Programming To The Interface, Not The Implementation\"","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}]},"page":{"version":3,"kind":"Article","sha256":"93e2741e020a27d02716a818d0eefaae04deaa33256b6d59ca2d65bd2d5f002f","slug":"xbst-splaytrees-2025","location":"/xBST_SplayTrees_2025.md","dependencies":[],"frontmatter":{"title":"Splay Trees","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xBST_SplayTrees_2025.md","url":"/CSCI232/build/xBST_SplayTrees_2025-7dabda0af53291a1ac749b29e7cd1682.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Splay Trees","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"bfNZ3UgBVS"}],"identifier":"splay-trees","label":"Splay Trees","html_id":"splay-trees","implicit":true,"key":"dJPgiEKgko"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"A ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"BLzuSZRzm0"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"splay tree","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"xZYlTFQdbR"}],"key":"ex0plpIrN0"},{"type":"text","value":" is a type of self-adjusting binary search tree (BST) where recently accessed elements are moved to the root of the tree using a process called ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"r0WPiBfZ4g"},{"type":"emphasis","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"splaying","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"xZkwf34fDx"}],"key":"HylzBVQ6is"},{"type":"text","value":". This helps ensure that frequently accessed elements are quicker to access.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"A7uHUommCS"}],"key":"y3MsliJZXc"},{"type":"heading","depth":2,"position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Who Invented It:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"XHqyzOuYfb"}],"identifier":"who-invented-it","label":"Who Invented It:","html_id":"who-invented-it","implicit":true,"key":"MWMTJuo7Ou"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":9,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":9,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Splay trees were invented by ","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"MlqaMcygVd"},{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Daniel Sleator","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"OGtu8B2nFM"}],"key":"AFo4J069MI"},{"type":"text","value":" and ","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"kwWCWV1oPS"},{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Robert Tarjan","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"sjiUC6djTZ"}],"key":"KCNoOg6o7t"},{"type":"text","value":" in 1985. The invention was part of their research on self-adjusting data structures.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"NNLjib2smE"}],"key":"rAqgwpPgSg"}],"key":"gGbQb9CPDK"},{"type":"heading","depth":3,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"When Was It Invented:","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"hf7Kj1DU0Q"}],"identifier":"when-was-it-invented","label":"When Was It Invented:","html_id":"when-was-it-invented","implicit":true,"key":"tIHDzX7WgC"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":13,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":13,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"The splay tree was introduced in ","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"VdqbKuXB5Y"},{"type":"strong","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"text","value":"1985","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"V25iy6TZBv"}],"key":"YwRrNwzZH6"},{"type":"text","value":".","position":{"start":{"line":13,"column":1},"end":{"line":13,"column":1}},"key":"nf32iHzkt1"}],"key":"JQlS7MBtkc"}],"key":"y57rbYTxUV"},{"type":"heading","depth":2,"position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"children":[{"type":"text","value":"Major Uses:","position":{"start":{"line":15,"column":1},"end":{"line":15,"column":1}},"key":"mswGaq1c1W"}],"identifier":"major-uses","label":"Major Uses:","html_id":"major-uses","implicit":true,"key":"KOn25vLqKK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":17,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"strong","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Dynamic sets","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"luJsxT3rbA"}],"key":"iAEJpOaN2T"},{"type":"text","value":": Splay trees are used to maintain a dynamic set of elements that can support a variety of search and update operations.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"cieLLUJw2y"}],"key":"iUzG9I0X3u"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Memory-efficient","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"CkIr7CYL1z"}],"key":"qeqbUr65yl"},{"type":"text","value":": Since splay trees do not require additional space for balancing data like AVL trees or Red-Black trees, they can be more memory-efficient.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"oyjabj9bmK"}],"key":"y10SCpNZiQ"},{"type":"listItem","spread":true,"position":{"start":{"line":19,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"strong","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"text","value":"Efficient in practice for certain workloads","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"du8ieRdMqK"}],"key":"b1uranFd0W"},{"type":"text","value":": Splay trees perform well when there are repeated accesses to a small subset of elements (i.e., the access pattern exhibits locality).","position":{"start":{"line":19,"column":1},"end":{"line":19,"column":1}},"key":"V85Rq4EHBM"}],"key":"DzuYK5qmax"}],"key":"q32dMqdBbo"},{"type":"heading","depth":2,"position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"Typical Applications:","position":{"start":{"line":21,"column":1},"end":{"line":21,"column":1}},"key":"waMgFzYPdd"}],"identifier":"typical-applications","label":"Typical Applications:","html_id":"typical-applications","implicit":true,"key":"R5DG7nQAlL"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":23,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"strong","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"Cache systems","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"l21zmtsz8Q"}],"key":"RY9iWEN5h5"},{"type":"text","value":": Frequently accessed items bubble to the front.","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"p4p53JCC7R"}],"key":"lpCIiXdZY2"},{"type":"listItem","spread":true,"position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"strong","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"text","value":"Text editors","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"aQs9Slcw36"}],"key":"JSUk01ChPz"},{"type":"text","value":": Recently opened files or commands can be organized in a splay list.","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"s07kdj7UoL"}],"key":"EI3sIQQlsu"},{"type":"listItem","spread":true,"position":{"start":{"line":25,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"strong","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"text","value":"Autocomplete lists","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"pbctKLu3Ae"}],"key":"tAt6XissXb"},{"type":"text","value":": Recently or frequently used search terms are moved to the front.","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"tcFiBAcKJg"}],"key":"hlCl1SDztA"}],"key":"tOjj22M8er"},{"type":"heading","depth":2,"position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"text","value":"Insert Function:","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"key":"ii9I55sLAO"}],"identifier":"insert-function","label":"Insert Function:","html_id":"insert-function","implicit":true,"key":"EQkdPP9CEw"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":29,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":29,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"strong","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"children":[{"type":"text","value":"Insertion in a splay tree","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"IuTkkfTmQ7"}],"key":"JG7jKyG3kP"},{"type":"text","value":" is similar to that in a regular binary search tree. The node is inserted following the normal BST rules. However, after insertion, the tree is “splayed” to bring the newly inserted node to the root.","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"icdHr8NZSO"}],"key":"wKtynapGb3"}],"key":"Xq6ODgTYA4"},{"type":"code","lang":"java","value":"public void insert(int value) {\n    root = insertRec(root, value);\n    splay(root, value);\n}\n\nprivate Node insertRec(Node root, int value) {\n    if (root == null) {\n        root = new Node(value);\n        return root;\n    }\n\n    if (value \u003c root.data) {\n        root.left = insertRec(root.left, value);\n    } else if (value \u003e root.data) {\n        root.right = insertRec(root.right, value);\n    }\n\n    return root;\n}","position":{"start":{"line":31,"column":1},"end":{"line":51,"column":1}},"key":"o9YfysZDOU"},{"type":"heading","depth":2,"position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"children":[{"type":"text","value":"Delete Function:","position":{"start":{"line":53,"column":1},"end":{"line":53,"column":1}},"key":"s2SJcBCNR4"}],"identifier":"delete-function","label":"Delete Function:","html_id":"delete-function","implicit":true,"key":"Sr78QNocys"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":55,"column":1},"end":{"line":56,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":55,"column":1},"end":{"line":56,"column":1}},"children":[{"type":"strong","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"children":[{"type":"text","value":"Deletion","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"key":"QgCznRVorK"}],"key":"Xv2XVQuzIV"},{"type":"text","value":" is performed in the same way as in a normal binary search tree. After finding the node to delete, it is removed, and then the tree is splayed to restore the tree’s structure.","position":{"start":{"line":55,"column":1},"end":{"line":55,"column":1}},"key":"jGp92AHHFZ"}],"key":"C4daJJyh0n"}],"key":"yKFRGjkPUh"},{"type":"code","lang":"java","value":"public void delete(int value) {\n    root = deleteRec(root, value);\n}\n\nprivate Node deleteRec(Node root, int value) {\n    if (root == null) return root;\n\n    if (value \u003c root.data) {\n        root.left = deleteRec(root.left, value);\n    } else if (value \u003e root.data) {\n        root.right = deleteRec(root.right, value);\n    } else {\n        // node with value found\n        if (root.left == null) return root.right;\n        else if (root.right == null) return root.left;\n    }\n\n    return root;\n}","position":{"start":{"line":57,"column":1},"end":{"line":77,"column":1}},"key":"oIliHYhPpM"},{"type":"heading","depth":2,"position":{"start":{"line":79,"column":1},"end":{"line":79,"column":1}},"children":[{"type":"text","value":"Find Function:","position":{"start":{"line":79,"column":1},"end":{"line":79,"column":1}},"key":"HOdAGWJ9Di"}],"identifier":"find-function","label":"Find Function:","html_id":"find-function","implicit":true,"key":"xlUmO9m9QK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":81,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":81,"column":1},"end":{"line":82,"column":1}},"children":[{"type":"text","value":"The ","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"MTuIS1f3nI"},{"type":"strong","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"children":[{"type":"text","value":"find function","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"nzS2gUctTH"}],"key":"s8idwdmfNe"},{"type":"text","value":" searches for a value in the tree, and if the value is found, it performs a splay operation to bring that value to the root. If the value is not found, the tree remains unchanged.","position":{"start":{"line":81,"column":1},"end":{"line":81,"column":1}},"key":"FH1qXGlpui"}],"key":"LasSS5MyG5"}],"key":"GSaJdOJmd6"},{"type":"code","lang":"java","value":"public boolean find(int value) {\n    root = splay(root, value);\n    return (root != null \u0026\u0026 root.data == value);\n}","position":{"start":{"line":83,"column":1},"end":{"line":88,"column":1}},"key":"blXazSSSfU"},{"type":"heading","depth":2,"position":{"start":{"line":90,"column":1},"end":{"line":90,"column":1}},"children":[{"type":"text","value":"Rules for Rotations:","position":{"start":{"line":90,"column":1},"end":{"line":90,"column":1}},"key":"OlHghD58Em"}],"identifier":"rules-for-rotations","label":"Rules for Rotations:","html_id":"rules-for-rotations","implicit":true,"key":"okfpBlyaDJ"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":92,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":92,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"text","value":"Splay trees use three types of rotations to adjust the tree during splaying:","position":{"start":{"line":92,"column":1},"end":{"line":92,"column":1}},"key":"neEzjt7zAv"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":93,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"strong","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"children":[{"type":"text","value":"Zig","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"XxowMg1dB3"}],"key":"mDs9S1iFak"},{"type":"text","value":": When the node is the child of the root.","position":{"start":{"line":93,"column":1},"end":{"line":93,"column":1}},"key":"kjqqtKZlr4"}],"key":"IqXgADAVh1"},{"type":"listItem","spread":true,"position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"children":[{"type":"strong","position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"children":[{"type":"text","value":"Zig-Zig","position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"key":"B0ouiR6Z5A"}],"key":"cbnmVESkxR"},{"type":"text","value":": When the node is the left or right child of a left or right child (two-level deep).","position":{"start":{"line":94,"column":1},"end":{"line":94,"column":1}},"key":"IrV574GVO3"}],"key":"FIQBpC5pqg"},{"type":"listItem","spread":true,"position":{"start":{"line":95,"column":1},"end":{"line":96,"column":1}},"children":[{"type":"strong","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"children":[{"type":"text","value":"Zig-Zag","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"RwWMHBNzc8"}],"key":"AEdCsllwN1"},{"type":"text","value":": When the node is the left child of the right child or the right child of the left child.","position":{"start":{"line":95,"column":1},"end":{"line":95,"column":1}},"key":"ZXftDzCLHA"}],"key":"QvuL8S3z4n"}],"key":"YmNd7kis4p"}],"key":"HuqOBPzSuj"}],"key":"t5D720piOC"},{"type":"heading","depth":2,"position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"children":[{"type":"text","value":"Rotations:","position":{"start":{"line":97,"column":1},"end":{"line":97,"column":1}},"key":"aoA7oeOVs5"}],"identifier":"rotations","label":"Rotations:","html_id":"rotations","implicit":true,"key":"h2lz2xWjvQ"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":99,"column":1},"end":{"line":101,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"children":[{"type":"strong","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"children":[{"type":"text","value":"Single Rotation (Zig)","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"key":"Z2n7NeHmMv"}],"key":"OHiuzKeAky"},{"type":"text","value":": If the node is the child of the root, perform a single rotation (right or left depending on the situation).","position":{"start":{"line":99,"column":1},"end":{"line":99,"column":1}},"key":"sPTYtXARw2"}],"key":"csKArHbp66"},{"type":"listItem","spread":true,"position":{"start":{"line":100,"column":1},"end":{"line":101,"column":1}},"children":[{"type":"strong","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"children":[{"type":"text","value":"Double Rotation (Zig-Zig or Zig-Zag)","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"key":"YIKzVF4T3B"}],"key":"OaGgQtjMQi"},{"type":"text","value":": In these cases, two rotations are needed. They help in cases where the tree has more than one level to adjust.","position":{"start":{"line":100,"column":1},"end":{"line":100,"column":1}},"key":"VAuJQP3wwR"}],"key":"mad1xqDWpw"}],"key":"yHpOa1m0KE"},{"type":"code","lang":"java","value":"private Node splay(Node root, int value) {\n    if (root == null || root.data == value) return root;\n\n    if (value \u003c root.data) {\n        if (root.left == null) return root;\n        if (value \u003c root.left.data) {\n            root.left.left = splay(root.left.left, value);\n            root = rotateRight(root);\n        } else if (value \u003e root.left.data) {\n            root.left.right = splay(root.left.right, value);\n            if (root.left.right != null) {\n                root.left = rotateLeft(root.left);\n            }\n        }\n        return (root.left == null) ? root : rotateRight(root);\n    } else {\n        if (root.right == null) return root;\n        if (value \u003e root.right.data) {\n            root.right.right = splay(root.right.right, value);\n            root = rotateLeft(root);\n        } else if (value \u003c root.right.data) {\n            root.right.left = splay(root.right.left, value);\n            if (root.right.left != null) {\n                root.right = rotateRight(root.right);\n            }\n        }\n        return (root.right == null) ? root : rotateLeft(root);\n    }\n}","position":{"start":{"line":102,"column":1},"end":{"line":132,"column":1}},"key":"GTNhcICb9E"},{"type":"heading","depth":2,"position":{"start":{"line":134,"column":1},"end":{"line":134,"column":1}},"children":[{"type":"text","value":"Java Program Demonstrating Insert, Find, Delete, and Pretty Print:","position":{"start":{"line":134,"column":1},"end":{"line":134,"column":1}},"key":"uf2J6mKwwp"}],"identifier":"java-program-demonstrating-insert-find-delete-and-pretty-print","label":"Java Program Demonstrating Insert, Find, Delete, and Pretty Print:","html_id":"java-program-demonstrating-insert-find-delete-and-pretty-print","implicit":true,"key":"AgKQ1vN5ow"},{"type":"code","lang":"java","value":"package inst_splay_2025;\n\nclass SplayTree {\n\n    private Node root;\n\n    // Inner class representing a node in the splay tree\n    class Node {\n\n        int data;\n        Node left, right;\n\n        public Node(int item)\n        {\n            data = item;\n            left = right = null;\n        }\n    }\n\n    // Inserts a value into the tree\n    public void insert(int value)\n    {\n        if (root == null) {\n            root = new Node(value);\n            return;\n        }\n\n        // Splay the tree to bring the value (or closest) to the root\n        root = splay(root, value);\n\n        // If the value already exists, no need to insert\n        if (root.data == value) {\n            return;\n        }\n\n        Node newNode = new Node(value);\n\n        // If the new value is smaller, make the new node root and adjust pointers\n        if (value \u003c root.data) {\n            newNode.right = root;\n            newNode.left = root.left;\n            root.left = null;\n        } else { // If the new value is greater\n            newNode.left = root;\n            newNode.right = root.right;\n            root.right = null;\n        }\n\n        root = newNode; // Update root\n    }\n\n    // Searches for a value in the tree\n    public boolean find(int value)\n    {\n        root = splay(root, value);\n        return (root != null \u0026\u0026 root.data == value);\n    }\n\n    // Deletes a node with the given value\n    public void delete(int value)\n    {\n        if (root == null) {\n            return;\n        }\n\n        // Splay the tree so that the value (or closest) is at the root\n        root = splay(root, value);\n\n        if (root.data != value) {\n            return; // If not found, do nothing\n        }\n        if (root.left == null) {\n            root = root.right;\n        } else {\n            Node temp = root;\n            // Splay the largest node in the left subtree to make it new root\n            root = splay(root.left, value);\n            root.right = temp.right;\n        }\n    }\n\n    // Right rotation (Zig rotation)\n    private Node rotateRight(Node root)\n    {\n        if (root == null || root.left == null) {\n            return root;\n        }\n        Node newRoot = root.left;\n        root.left = newRoot.right;\n        newRoot.right = root;\n        return newRoot;\n    }\n\n    // Left rotation (Zag rotation)\n    private Node rotateLeft(Node root)\n    {\n        if (root == null || root.right == null) {\n            return root;\n        }\n        Node newRoot = root.right;\n        root.right = newRoot.left;\n        newRoot.left = root;\n        return newRoot;\n    }\n\n    /*\n     * Splay Operation: Moves the given value to the root if present, or the closest value.\n     * \n     * Splay tree follows these rules for rotations:\n     * \n     * - Zig Rotation (Single Right): When the value is in the left child of the root.\n     * - Zag Rotation (Single Left): When the value is in the right child of the root.\n     * - Zig-Zig (Double Right Rotation): When the value is in the left child of the left child.\n     * - Zag-Zag (Double Left Rotation): When the value is in the right child of the right child.\n     * - Zig-Zag (Left-Right Rotation): When the value is in the right child of the left child.\n     * - Zag-Zig (Right-Left Rotation): When the value is in the left child of the right child.\n     */\n    private Node splay(Node root, int value)\n    {\n        if (root == null || root.data == value) {\n            return root;\n        }\n\n        if (value \u003c root.data) {\n            if (root.left == null) {\n                return root;\n            }\n\n            // Zig-Zig case (left-left)\n            if (value \u003c root.left.data) {\n                root.left.left = splay(root.left.left, value);\n                root = rotateRight(root);\n            } // Zig-Zag case (left-right)\n            else if (value \u003e root.left.data) {\n                root.left.right = splay(root.left.right, value);\n                if (root.left.right != null) {\n                    root.left = rotateLeft(root.left);\n                }\n            }\n\n            // Perform a final Zig rotation\n            return (root.left == null) ? root : rotateRight(root);\n        } else {\n            if (root.right == null) {\n                return root;\n            }\n\n            // Zag-Zag case (right-right)\n            if (value \u003e root.right.data) {\n                root.right.right = splay(root.right.right, value);\n                root = rotateLeft(root);\n            } // Zag-Zig case (right-left)\n            else if (value \u003c root.right.data) {\n                root.right.left = splay(root.right.left, value);\n                if (root.right.left != null) {\n                    root.right = rotateRight(root.right);\n                }\n            }\n\n            // Perform a final Zag rotation\n            return (root.right == null) ? root : rotateLeft(root);\n        }\n    }\n\n    // Prints the tree structure\n    public void prettyPrint(Node root, String indent)\n    {\n        if (root == null) {\n            return;\n        }\n        prettyPrint(root.right, indent + \"   \");\n        System.out.println(indent + root.data);\n        prettyPrint(root.left, indent + \"   \");\n    }\n\n    // Initiates tree printing\n    public void printTree()\n    {\n        prettyPrint(root, \"\");\n    }\n}\n\n// Driver class to test the Splay Tree implementation\npublic class Inst_splay_2025 {\n\n    public static void main(String[] args)\n    {\n        SplayTree tree = new SplayTree();\n\n        tree.insert(10);\n        tree.insert(20);\n        tree.insert(5);\n        tree.insert(55);\n        tree.insert(60);\n        tree.insert(65);\n        tree.insert(70);\n        tree.insert(75);\n        tree.insert(30);\n        tree.insert(15);\n        tree.insert(25);\n\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.find(20);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.find(5);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.find(65);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(10);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(30);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(15);\n        tree.printTree();\n        System.out.println(\"\\n----------------\\n\");\n\n        tree.delete(5);\n        tree.printTree();\n    }\n}\n\n","position":{"start":{"line":137,"column":1},"end":{"line":372,"column":1}},"key":"Ktf3iaidEu"},{"type":"heading","depth":2,"position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"children":[{"type":"text","value":"Explanation of Rotation Rules:","position":{"start":{"line":374,"column":1},"end":{"line":374,"column":1}},"key":"InthFPODa2"}],"identifier":"explanation-of-rotation-rules","label":"Explanation of Rotation Rules:","html_id":"explanation-of-rotation-rules","implicit":true,"key":"lvmy4P7Yll"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":376,"column":1},"end":{"line":379,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"children":[{"type":"strong","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"children":[{"type":"text","value":"Zig (Single Rotation)","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"tGi5AXZEHB"}],"key":"m0aBMTMU8A"},{"type":"text","value":": If the node to be accessed is the left or right child of the root, perform a single rotation (either left or right).","position":{"start":{"line":376,"column":1},"end":{"line":376,"column":1}},"key":"XmoD4XKL2J"}],"key":"Ho7HK1faMn"},{"type":"listItem","spread":true,"position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"children":[{"type":"strong","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"children":[{"type":"text","value":"Zig-Zig (Double Rotation)","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"key":"kwwnm1wJOd"}],"key":"howtooWyRE"},{"type":"text","value":": If the node is the left or right child of a left or right child (two levels deep), perform two rotations. This optimizes the tree by rotating both the node and its parent.","position":{"start":{"line":377,"column":1},"end":{"line":377,"column":1}},"key":"nlXjRFS5MF"}],"key":"LI44P0x0T7"},{"type":"listItem","spread":true,"position":{"start":{"line":378,"column":1},"end":{"line":379,"column":1}},"children":[{"type":"strong","position":{"start":{"line":378,"column":1},"end":{"line":378,"column":1}},"children":[{"type":"text","value":"Zig-Zag (Double Rotation)","position":{"start":{"line":378,"column":1},"end":{"line":378,"column":1}},"key":"k49A2jyiBt"}],"key":"RhIcKy2ZkC"},{"type":"text","value":": If the node is the left child of the right child, or the right child of the left child (mixed child directions), perform a rotation on the child followed by a rotation on the node itself.","position":{"start":{"line":378,"column":1},"end":{"line":378,"column":1}},"key":"S4taGukYiM"}],"key":"gvO5X7IWUK"}],"key":"Ty6HiWzEVb"},{"type":"paragraph","position":{"start":{"line":380,"column":1},"end":{"line":380,"column":1}},"children":[{"type":"text","value":"This program demonstrates how to use splay tree operations and includes helpful comments and explanations of the rotation rules. Each rotation helps ensure the tree remains balanced by moving frequently accessed nodes towards the root.","position":{"start":{"line":380,"column":1},"end":{"line":380,"column":1}},"key":"PWbC1FWtWT"}],"key":"cVrmBtuYr2"},{"type":"thematicBreak","position":{"start":{"line":384,"column":1},"end":{"line":384,"column":1}},"key":"ov9vnsYLtN"},{"type":"heading","depth":2,"position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"children":[{"type":"text","value":"Splay using for loops","position":{"start":{"line":386,"column":1},"end":{"line":386,"column":1}},"key":"CP1J12ng7a"}],"identifier":"splay-using-for-loops","label":"Splay using for loops","html_id":"splay-using-for-loops","implicit":true,"key":"eveTsqoiQt"},{"type":"paragraph","position":{"start":{"line":390,"column":1},"end":{"line":390,"column":1}},"children":[{"type":"text","value":"This version avoids the recursive calls and uses loops to handle the tree traversal and adjustments.","position":{"start":{"line":390,"column":1},"end":{"line":390,"column":1}},"key":"HWZN2fjwkh"}],"key":"agj9VQM1pg"},{"type":"code","lang":"java","value":"class SplayTree {\n    private Node root;\n\n    // Node class to represent each node in the tree\n    class Node {\n        int data;  // Data stored in the node\n        Node left, right;  // Left and right child nodes\n\n        // Constructor to create a new node with the given value\n        public Node(int item) {\n            data = item;\n            left = right = null;\n        }\n    }\n\n    // Insert function to add a new value into the splay tree\n    public void insert(int value) {\n        if (root == null) {\n            root = new Node(value);  // If tree is empty, create a new node as root\n            return;\n        }\n\n        Node node = root;\n        Node parent = null;\n\n        // Loop to find the correct position for insertion\n        while (node != null) {\n            parent = node;\n            if (value \u003c node.data) {\n                node = node.left;\n            } else if (value \u003e node.data) {\n                node = node.right;\n            } else {\n                return;  // If the value is already present, do nothing\n            }\n        }\n\n        // Create a new node and attach it to the parent\n        node = new Node(value);\n        if (value \u003c parent.data) {\n            parent.left = node;\n        } else {\n            parent.right = node;\n        }\n\n        // After insertion, splay the tree to bring the inserted node to the root\n        root = splay(root, value);\n    }\n\n    // Delete function to remove a node from the splay tree\n    public void delete(int value) {\n        if (root == null) return;\n\n        // Splay the tree to bring the node to be deleted to the root\n        root = splay(root, value);\n\n        if (root == null || root.data != value) return;  // Node not found\n\n        // Node to be deleted is at the root\n        if (root.left == null) {\n            root = root.right;  // If left child is null, replace root with right child\n        } else {\n            Node rightSubtree = root.right;\n            root = root.left;\n            root = splay(root, value);  // Splay the left subtree to bring the max element to the root\n            root.right = rightSubtree;  // Attach the right subtree to the new root\n        }\n    }\n\n    // Find function to search for a value in the splay tree\n    public boolean find(int value) {\n        if (root == null) return false;\n\n        // Splay the tree to bring the searched node to the root\n        root = splay(root, value);\n\n        return (root != null \u0026\u0026 root.data == value);\n    }\n\n    // Function to perform a right rotation on the tree (used during splaying)\n    private Node rotateRight(Node root) {\n        Node newRoot = root.left;  // Make the left child the new root\n        root.left = newRoot.right;  // Make the right child of the new root the left child of the old root\n        newRoot.right = root;  // Make the old root the right child of the new root\n        return newRoot;  // Return the new root\n    }\n\n    // Function to perform a left rotation on the tree (used during splaying)\n    private Node rotateLeft(Node root) {\n        Node newRoot = root.right;  // Make the right child the new root\n        root.right = newRoot.left;  // Make the left child of the new root the right child of the old root\n        newRoot.left = root;  // Make the old root the left child of the new root\n        return newRoot;  // Return the new root\n    }\n\n    // Splay function to bring the node with the given value to the root\n    private Node splay(Node root, int value) {\n        while (root != null) {\n            // Base case: if the node is found or we reach the leaf, break out of the loop\n            if (root.data == value) return root;\n\n            // Zig (single rotation): If the node is the left child or right child of the root\n            if (value \u003c root.data) {\n                if (root.left == null) break;  // If there's no left child, stop\n\n                // Zig-Zig (double rotation): If node's value is in the left subtree of left child\n                if (value \u003c root.left.data) {\n                    root = rotateRight(root);\n                } else if (value \u003e root.left.data) {\n                    // Zig-Zag (double rotation): If node's value is in the right subtree of left child\n                    root.left = rotateLeft(root.left);\n                    root = rotateRight(root);\n                }\n            } else {\n                if (root.right == null) break;  // If there's no right child, stop\n\n                // Zig-Zig (double rotation): If node's value is in the right subtree of right child\n                if (value \u003e root.right.data) {\n                    root = rotateLeft(root);\n                } else if (value \u003c root.right.data) {\n                    // Zig-Zag (double rotation): If node's value is in the left subtree of right child\n                    root.right = rotateRight(root.right);\n                    root = rotateLeft(root);\n                }\n            }\n        }\n        return root;\n    }\n\n    // Pretty print function to display the tree visually\n    public void prettyPrint(Node root, String indent) {\n        if (root == null) return;  // If the root is null, return\n\n        // Print the right subtree first with increased indentation\n        prettyPrint(root.right, indent + \"   \");\n        System.out.println(indent + root.data);  // Print the current node\n        // Print the left subtree with increased indentation\n        prettyPrint(root.left, indent + \"   \");\n    }\n\n    // Wrapper function to print the tree\n    public void printTree() {\n        prettyPrint(root, \"\");  // Call the prettyPrint function starting from the root\n    }\n\n    public static void main(String[] args) {\n        SplayTree tree = new SplayTree();\n\n        // Inserting values into the tree\n        tree.insert(10);\n        tree.insert(20);\n        tree.insert(30);\n        tree.insert(15);\n\n        // Pretty print the tree after insertion\n        System.out.println(\"Tree after insertion:\");\n        tree.printTree();\n\n        // Find a value in the tree and bring it to the root\n        tree.find(20);\n        System.out.println(\"\\nTree after finding 20:\");\n        tree.printTree();\n\n        // Delete a value from the tree\n        tree.delete(10);\n        System.out.println(\"\\nTree after deleting 10:\");\n        tree.printTree();\n    }\n}","position":{"start":{"line":392,"column":1},"end":{"line":562,"column":1}},"key":"yeULeCJSR0"},{"type":"heading","depth":2,"position":{"start":{"line":564,"column":1},"end":{"line":564,"column":1}},"children":[{"type":"text","value":"Explanation of Changes:","position":{"start":{"line":564,"column":1},"end":{"line":564,"column":1}},"key":"lbXOJFjDCU"}],"identifier":"explanation-of-changes","label":"Explanation of Changes:","html_id":"explanation-of-changes","implicit":true,"key":"w7JwzQk7k3"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":566,"column":1},"end":{"line":570,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"children":[{"type":"strong","position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"children":[{"type":"text","value":"Insert Method","position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"key":"XovWr7K0bd"}],"key":"zbJGd9D8ri"},{"type":"text","value":": The insertion now uses a loop to traverse the tree and find the correct position to insert the new node. The insertion process is followed by a splay operation to move the newly inserted node to the root.","position":{"start":{"line":566,"column":1},"end":{"line":566,"column":1}},"key":"Vh4LePUwL2"}],"key":"DC5vU1m9qF"},{"type":"listItem","spread":true,"position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"children":[{"type":"strong","position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"children":[{"type":"text","value":"Delete Method","position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"key":"x5tSN0VgKR"}],"key":"jF7W1Uts2i"},{"type":"text","value":": Similar to insertion, the delete method now uses a loop to traverse the tree and delete the node. It also includes a splay operation to move the necessary nodes after deletion.","position":{"start":{"line":567,"column":1},"end":{"line":567,"column":1}},"key":"sKLURdOviX"}],"key":"rujTvxawCJ"},{"type":"listItem","spread":true,"position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"children":[{"type":"strong","position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"children":[{"type":"text","value":"Splay Method","position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"key":"DAXWUlEZJp"}],"key":"n2Xmq4bv73"},{"type":"text","value":": The splay function has been rewritten to use a loop instead of recursion. It continuously adjusts the tree until the target node is either found or no further adjustments are necessary.","position":{"start":{"line":568,"column":1},"end":{"line":568,"column":1}},"key":"DUiHX3LJU8"}],"key":"pexsLffiqr"},{"type":"listItem","spread":true,"position":{"start":{"line":569,"column":1},"end":{"line":570,"column":1}},"children":[{"type":"strong","position":{"start":{"line":569,"column":1},"end":{"line":569,"column":1}},"children":[{"type":"text","value":"Rotation Methods","position":{"start":{"line":569,"column":1},"end":{"line":569,"column":1}},"key":"lh1fAeWsBj"}],"key":"rNbrfBm4F0"},{"type":"text","value":": The left and right rotations remain the same, as these are simple tree manipulations that don’t depend on recursion.","position":{"start":{"line":569,"column":1},"end":{"line":569,"column":1}},"key":"jnKG8mffl0"}],"key":"g68svJ0z7z"}],"key":"Kx36Xocewh"},{"type":"paragraph","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"children":[{"type":"text","value":"This approach eliminates recursion in favor of iterative methods using loops, which may help avoid potential stack overflow issues with deep trees, though it may still be less efficient compared to a more balanced tree like an AVL or Red-Black tree. However, the splay tree performs well with specific access patterns, especially when there is locality of reference.","position":{"start":{"line":571,"column":1},"end":{"line":571,"column":1}},"key":"YWnLu2DrXu"}],"key":"GOTCa4vxCt"}],"key":"vQks4iszDj"}],"key":"wdfUE4VBhs"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"BST AVL Red Black Tree Comparisons","url":"/xbst-comparisiontable","group":"Algorithms"},"next":{"title":"Hash Table","url":"/xhashing-hashtable","group":"Algorithms"}}},"domain":"http://localhost:3002"},"project":{"bibliography":["C:\\a_books\\CSCI232_algobook\\references.bib"],"exports":[],"title":"Algorithms","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\CSCI232_algobook\\myst-generated-uid-0"}],"github":"https://github.com/executablebooks/jupyter-book","copyright":"2024","toc":[{"file":"intro.md"},{"file":"xCSCI232_Intro.md"},{"children":[{"file":"xTerms_Radix.md"},{"file":"xTerms_Serializable.md"},{"file":"xTerms_Iterator.md"}],"file":"xTerms.md"},{"children":[{"file":"xBST_Applications.md"},{"file":"xBST_Comparisons.md"},{"file":"xBST_TreeTraversal.md"},{"file":"xBST_Iterative_Recursion_Search.md"},{"file":"xBST_BinarySearchTree.md"},{"file":"xBST_AVLTree.md"},{"file":"xBST_RedBlack.md"},{"file":"xBST_ComparisionTable.md"},{"file":"xBST_SplayTrees_2025.md"}],"file":"xBST_Intro.md"},{"children":[{"file":"xHashing_UnderstandingHashTables.md"},{"file":"xHashing_ModulusHashFunction.md"},{"file":"xHashing_Chaining.md"},{"file":"xHashing_OpenAddressing.md"},{"file":"xHashing_OpenAddressingHashingCodeExamples.md"}],"file":"xHashing_HashTable.md"},{"file":"xSkipList.md"},{"children":[{"file":"xGraphsAnalysisOfBFSandDFS.md"},{"file":"xUnderstandingBFS_202504.md"},{"file":"xUnderstandingDFS_202504.md"},{"file":"xGraphsSevenBridges.md"},{"file":"xGraphsDFS.md"},{"file":"xGraphsBFS.md"},{"file":"xDFSStoredPaths.md"},{"file":"xGraphsMazeSolverDFS.md"},{"file":"xGraphsDijkstra.md"}],"file":"xGraphs.md"},{"file":"xHuffmanCode.md"},{"file":"xSerializable.md"},{"children":[{"file":"xJavaHashMapTreeMapLinkedHashMap.md"},{"file":"xHashSetLinkedHashSetTreeSetComparision.md"},{"file":"xProgrammingToTheInterfacemd.md"}],"file":"xJAVATechniques.md"},{"file":"xEnd.md"}],"index":"index","pages":[{"slug":"xcsci232-intro","title":"CSCI 232 Data Structures and Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms","title":"Terms and Concepts","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xterms-radix","title":"Radix - Number Bases","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-serializable","title":"Serializable","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xterms-iterator","title":"Iterator","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-intro","title":"Binary Search Tree - Intro","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbst-applications","title":"Applications That Use Binary Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisons","title":"Binary Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-treetraversal","title":"Tree Traversal","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-iterative-recursion-search","title":"Demonstrate BST using iterative looping and recursion","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-binarysearchtree","title":"Binary Search Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-avltree","title":"AVL Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-redblack","title":"Red Black Tree","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-comparisiontable","title":"BST AVL Red Black Tree Comparisons","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbst-splaytrees-2025","title":"Splay Trees","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-hashtable","title":"Hash Table","description":"","date":"","thumbnail":"/CSCI232/build/f694c399ae1cdea2e011d1ecd6ed8d9d.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xhashing-understandinghashtables","title":"Understanding Hash Tables and Hash Functions*","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-modulushashfunction","title":"Modulus Hash Function","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-chaining","title":"Hash Tables - Chaining","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressing","title":"Hash Table - Open Addressing","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashing-openaddressinghashingcodeexamples","title":"Java code for double hashing in a hash table:","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xskiplist","title":"Skip List","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphs","title":"Graphs","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xgraphsanalysisofbfsanddfs","title":"A Comparative Analysis of Breadth-First Search and Depth-First Search Algorithms","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingbfs-202504","title":"Understanding Breadth-First Search (BFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingdfs-202504","title":"Understanding Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphssevenbridges","title":"Seven Bridges of Königsberg","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdfs","title":"Depth-First Search (DFS)","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsbfs","title":"Breadth First","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdfsstoredpaths","title":"DFS - Stored Paths","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsmazesolverdfs","title":"DSF - Maze Solving","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xgraphsdijkstra","title":"Dijkstra’s Algorithm","description":"","date":"","thumbnail":"/CSCI232/build/dijkstra_example-8cca3c2c620cd1d44d2c9745b698d02d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhuffmancode","title":"Huffman Code","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xserializable","title":"Serialization","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavatechniques","title":"JAVA Techniques","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xjavahashmaptreemaplinkedhashmap","title":"Examples of Java’s HashMap, TreeMap, and LinkedHashMap","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xhashsetlinkedhashsettreesetcomparision","title":"HashSet, LinkedHashSet, and TreeSet Comparision","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xprogrammingtotheinterfacemd","title":"Programming To The Interface, Not The Implementation\"","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End","description":"","date":"","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1}]}}},"actionData":null,"errors":null},"future":{"unstable_dev":false,"unstable_postcss":false,"unstable_tailwind":false,"v2_errorBoundary":true,"v2_headers":true,"v2_meta":true,"v2_normalizeFormMethod":true,"v2_routeConvention":true}};</script><script type="module" async="">import "/CSCI232/build/manifest-54BD5942.js";
import * as route0 from "/CSCI232/build/root-PMP5BIHC.js";
import * as route1 from "/CSCI232/build/routes/$-5ZLZ2O3Y.js";
window.__remixRouteModules = {"root":route0,"routes/$":route1};

import("/CSCI232/build/entry.client-PCJPW7TK.js");</script></body></html>