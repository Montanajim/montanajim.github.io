<!DOCTYPE html><html lang="en" class="" style="scroll-padding:60px"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><title>Merge Sort - Demo Code - JAVA and Basic Algorithms</title><meta property="og:title" content="Merge Sort - Demo Code - JAVA and Basic Algorithms"/><meta name="generator" content="mystmd"/><meta name="description" content="Course material for CSCI 132"/><meta property="og:description" content="Course material for CSCI 132"/><meta name="keywords" content="JAVA, Algorithms"/><link rel="stylesheet" href="/csci132/build/_assets/app-SDGCW62C.css"/><link rel="stylesheet" href="/csci132/build/_assets/thebe-core-VKVHG5VY.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jupyter-matplotlib@0.11.3/css/mpl_widget.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous"/><link rel="icon" href="/csci132/favicon.ico"/><link rel="stylesheet" href="/csci132/myst-theme.css"/><script>
  const savedTheme = localStorage.getItem("myst:theme");
  const theme = window.matchMedia("(prefers-color-scheme: light)").matches ? 'light' : 'dark';
  const classes = document.documentElement.classList;
  const hasAnyTheme = classes.contains('light') || classes.contains('dark');
  if (!hasAnyTheme) classes.add(savedTheme ?? theme);
</script></head><body class="m-0 transition-colors duration-500 bg-white dark:bg-stone-900"><div class="myst-skip-to-article fixed top-1 left-1 h-[0px] w-[0px] focus-within:z-40 focus-within:h-auto focus-within:w-auto bg-white overflow-hidden focus-within:p-2 focus-within:ring-1" aria-label="skip to content options"><a href="#skip-to-frontmatter" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article frontmatter</a><a href="#skip-to-article" class="myst-skip-to-link block px-2 py-1 text-black underline">Skip to article content</a></div><dialog id="myst-no-css" style="position:fixed;left:0px;top:0px;width:100vw;height:100vh;font-size:4rem;padding:1rem;color:black;background:white"><strong>Site not loading correctly?</strong><p>This may be due to an incorrect <code>BASE_URL</code> configuration. See<!-- --> <a href="https://mystmd.org/guide/deployment#deploy-base-url">the MyST Documentation</a> <!-- -->for reference.</p><script>
    (() => {
            // Test for has-styling variable set by the MyST stylesheet
            const node = document.currentScript.parentNode;
            const hasCSS = window.getComputedStyle(node).getPropertyValue("--has-styling");
            if (hasCSS === ""){
                    node.showModal();
            }

    })()
</script></dialog><div class="myst-top-nav bg-white/80 backdrop-blur dark:bg-stone-900/80 shadow dark:shadow-stone-700 p-3 md:px-8 sticky w-screen top-0 z-30 h-[60px]"><nav class="myst-top-nav-bar flex items-center justify-between flex-nowrap max-w-[1440px] mx-auto"><div class="flex flex-row xl:min-w-[19.5rem] mr-2 sm:mr-7 justify-start items-center shrink-0"><div class="block xl:hidden"><button class="myst-top-nav-menu-button flex items-center border-stone-400 text-stone-800 hover:text-stone-900 dark:text-stone-200 hover:dark:text-stone-100"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" width="2rem" height="2rem" class="m-1"><path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd"></path></svg><span class="sr-only">Open Menu</span></button></div><a class="myst-home-link flex items-center ml-3 dark:text-white w-fit md:ml-5 xl:ml-7" href="/csci132/"><span class="text-md sm:text-xl tracking-tight sm:mr-5">CSCI 132</span></a></div><div class="flex items-center flex-grow w-auto"><div class="flex-grow hidden text-md lg:block"></div><div class="flex-grow block"></div><button type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R75cp:" data-state="closed" class="myst-search-bar flex items-center h-10 aspect-square sm:w-64 text-left text-gray-600 border border-gray-300 dark:border-gray-600 rounded-lg bg-gray-50 dark:bg-gray-700 myst-search-bar-disabled hover:ring-blue-500 dark:hover:ring-blue-500 hover:border-blue-500 dark:hover:border-blue-500"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="p-2.5 h-10 w-10 aspect-square"><path fill-rule="evenodd" d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z" clip-rule="evenodd"></path></svg><span class="myst-search-text-placeholder hidden sm:block grow">Search</span><div aria-hidden="true" class="myst-search-shortcut items-center hidden mx-1 font-mono text-sm text-gray-600 sm:flex gap-x-1"><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none hide-mac">CTRL</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none show-mac">⌘</kbd><kbd class="px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md shadow-[0px_2px_0px_0px_rgba(0,0,0,0.08)] dark:shadow-none ">K</kbd><script>
;(() => {
const script = document.currentScript;
const root = script.parentElement;

const isMac = /mac/i.test(
      window.navigator.userAgentData?.platform ?? window.navigator.userAgent,
    );
root.querySelectorAll(".hide-mac").forEach(node => {node.classList.add(isMac ? "hidden" : "block")});
root.querySelectorAll(".show-mac").forEach(node => {node.classList.add(!isMac ? "hidden" : "block")});
})()</script></div></button><button class="myst-theme-button theme rounded-full aspect-square border border-stone-700 dark:border-white hover:bg-neutral-100 border-solid overflow-hidden text-stone-700 dark:text-white hover:text-stone-500 dark:hover:text-neutral-800 w-8 h-8 mx-3" title="Toggle theme between light and dark mode" aria-label="Toggle theme between light and dark mode"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-moon-icon h-full w-full p-0.5 hidden dark:block"><path fill-rule="evenodd" d="M9.528 1.718a.75.75 0 0 1 .162.819A8.97 8.97 0 0 0 9 6a9 9 0 0 0 9 9 8.97 8.97 0 0 0 3.463-.69.75.75 0 0 1 .981.98 10.503 10.503 0 0 1-9.694 6.46c-5.799 0-10.5-4.7-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 0 1 .818.162Z" clip-rule="evenodd"></path></svg><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="myst-theme-sun-icon h-full w-full p-0.5 dark:hidden"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z"></path></svg></button><div class="block sm:hidden"></div><div class="hidden sm:block"></div></div></nav></div><div class="myst-primary-sidebar fixed xl:article-grid grid-gap xl:w-screen xl:pointer-events-none overflow-auto max-xl:min-w-[300px] hidden z-10" style="top:60px"><div class="myst-primary-sidebar-pointer pointer-events-auto xl:col-margin-left flex-col overflow-hidden hidden xl:flex"><div class="myst-primary-sidebar-nav flex-grow py-6 overflow-y-auto primary-scrollbar"><nav aria-label="Navigation" class="myst-primary-sidebar-topnav overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px] lg:hidden"><div class="w-full px-1 dark:text-white font-medium"></div></nav><div class="my-3 border-b-2 lg:hidden"></div><nav aria-label="Table of Contents" class="myst-primary-sidebar-toc flex-grow overflow-y-hidden transition-opacity ml-3 xl:ml-0 mr-3 max-w-[350px]"><div class="myst-toc w-full px-1 dark:text-white"><a title="JAVA and Basic Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30 font-bold" href="/csci132/">CSCI 132</a><a title="Data Structures and Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/csci132/xdatastructuresandalgorithms">Data Structures and Algorithms</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Array Techniques" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/csci132/xarraytechniques">Array Techniques</a><button class="self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:Rupsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:Rupsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><a title="Encapsulation vs Non-Encapsulation" class="block break-words focus:outline outline-blue-200 outline-2 rounded myst-toc-item p-2 my-1 rounded-lg hover:bg-slate-300/30" href="/csci132/xencapsulationnonencapsulation">Encapsulation vs Non-Encapsulation</a><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Big O Notation" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/csci132/xbigonotation">Big O Notation</a><button class="self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1epsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1epsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Linked Lists" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/csci132/xlinkedlists">Linked Lists</a><button class="self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1mpsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1mpsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Stacks and Queues" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/csci132/xstacksandqueues">Stacks and Queues</a><button class="self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R1upsp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R1upsp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div><div data-state="closed" class="w-full"><div class="myst-toc-item flex flex-row w-full gap-2 px-2 my-1 text-left rounded-lg outline-none hover:bg-slate-300/30"><a title="Sorting Algorithms" class="block break-words focus:outline outline-blue-200 outline-2 rounded py-2 grow" href="/csci132/xsortalgorithms">Sorting Algorithms</a><button class="self-center flex-none rounded-md group hover:bg-slate-300/30 focus:outline outline-blue-200 outline-2" aria-label="Open Folder" type="button" aria-controls="radix-:R26psp:" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" data-slot="icon" class="transition-transform duration-300 group-data-[state=open]:rotate-90 text-text-slate-700 dark:text-slate-100" height="1.5rem" width="1.5rem"><path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z" clip-rule="evenodd"></path></svg></button></div><div data-state="closed" id="radix-:R26psp:" hidden="" class="pl-3 pr-[2px] collapsible-content"></div></div></div></nav></div><div class="myst-primary-sidebar-footer flex-none py-6 transition-all duration-700 translate-y-6 opacity-0"><a class="myst-made-with-myst flex mx-auto text-gray-700 w-fit hover:text-blue-700 dark:text-gray-200 dark:hover:text-blue-400" href="https://mystmd.org/made-with-myst" target="_blank" rel="noreferrer"><svg style="width:24px;height:24px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" stroke="none"><g id="icon"><path fill="currentColor" d="M23.8,54.8v-3.6l4.7-0.8V17.5l-4.7-0.8V13H36l13.4,31.7h0.2l13-31.7h12.6v3.6l-4.7,0.8v32.9l4.7,0.8v3.6h-15
          v-3.6l4.9-0.8V20.8H65L51.4,53.3h-3.8l-14-32.5h-0.1l0.2,17.4v12.1l5,0.8v3.6H23.8z"></path><path fill="#F37726" d="M47,86.9c0-5.9-3.4-8.8-10.1-8.8h-8.4c-5.2,0-9.4-1.3-12.5-3.8c-3.1-2.5-5.4-6.2-6.8-11l4.8-1.6
          c1.8,5.6,6.4,8.6,13.8,8.8h9.2c6.4,0,10.8,2.5,13.1,7.5c2.3-5,6.7-7.5,13.1-7.5h8.4c7.8,0,12.7-2.9,14.6-8.7l4.8,1.6
          c-1.4,4.9-3.6,8.6-6.8,11.1c-3.1,2.5-7.3,3.7-12.4,3.8H63c-6.7,0-10,2.9-10,8.8"></path></g></svg><span class="self-center ml-2 text-sm">Made with MyST</span></a></div></div></div><main class="article-grid grid-gap"><article class="article-grid subgrid-gap col-screen article content"><div class="hidden"></div><div id="skip-to-frontmatter" aria-label="article frontmatter" class="myst-fm-block mb-8 pt-9"><div class="myst-fm-block-header flex items-center mb-5 h-6 text-sm font-light"><div class="flex-grow"></div><div class="myst-fm-block-badges"></div><div class="myst-fm-downloads-dropdown relative flex inline-block mx-1 grow-0" data-headlessui-state=""><button class="myst-fm-downloads-button relative ml-2 -mr-1" id="headlessui-menu-button-:Rs8ucp:" type="button" aria-haspopup="menu" aria-expanded="false" data-headlessui-state=""><span class="sr-only">Downloads</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.25rem" height="1.25rem" class="myst-fm-downloads-icon"><title>Download</title><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"></path></svg></button></div></div><h1 class="myst-fm-block-title mb-0">Merge Sort - Demo Code</h1><header class="myst-fm-authors-affiliations mt-4 not-prose"><div class="myst-fm-authors-list"><span class="myst-fm-author font-semibold text-sm myst-fm-author-item inline-block"><button class="myst-fm-author-popover focus:shadow-[0_0_0_2px] focus:shadow-black outline-none hover:underline" aria-label="Author Details" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R78ucp:" data-state="closed"><span class="myst-fm-author-name">James Goudy</span></button></span></div></header><div class="myst-fm-block-date-doi flex mt-2 text-sm font-light"><time dateTime="2025-12-04" class="myst-fm-date-string">December 4, 2025</time></div></div><div class="block my-10 lg:sticky lg:z-10 lg:h-0 lg:pt-0 lg:my-0 lg:ml-10 lg:col-margin-right" style="top:60px"><nav></nav></div><div id="skip-to-article"></div><h3 id="how-merge-sort-works" class="relative group"><span class="heading-text"><strong>How Merge Sort Works</strong></span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#how-merge-sort-works" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><p>Merge sort is a <strong>divide-and-conquer</strong> sorting algorithm. It recursively divides the array into two halves until each subarray has only one element (which is trivially sorted). Then it <strong>merges</strong> these sorted halves back together, comparing elements and building a larger sorted array step by step. This merging process continues until the entire array is reassembled in sorted order.</p><p>The algorithm has a consistent time complexity of <strong>O(n log n)</strong> — it divides the array (log n times) and merges n elements at each level. Merge sort is stable and efficient but requires extra space proportional to the array size due to its temporary workspace array.</p><h2 id="arrays" class="relative group"><span class="heading-text">Arrays</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#arrays" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><h3 id="demo-code" class="relative group"><span class="heading-text">Demo Code</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#demo-code" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">/*
Engineer: James Goduy
 */
package mergesort_rev;

import java.util.Random;


/*
 * The Sorter interface defines a contract that all sorting classes must follow.
 * Any class that implements Sorter must provide concrete versions of insert(),
 * sort(), and displayArray(). These are method signatures only—no code 
 * is written here.
 *
 * Using an interface allows us to treat different sorting algorithms (e.g.,
 * recursive and iterative merge sorts) as the same &quot;type.&quot; This is an example
 * of polymorphism: we can write one block of code that works with any object
 * implementing Sorter, regardless of how it performs the sorting internally.
 *
 * In short, the interface provides a common structure (what must be done),
 * while each class defines its own behavior (how it is done).
 */

interface Sorter {
    void insert(int value);
    void sort();
    void displayArray();
}


class MergeSort implements Sorter {

    private int[] theArray;  // Main array to be sorted
    private int nElems;      // Current number of elements in the array
    private int max;         // Maximum capacity of the array

    // Constructor: initializes the array and tracking variables
    public MergeSort(int max) {
        theArray = new int[max];
        nElems = 0;
        this.max = max;
    }

    // Check if array is full
    private boolean isFull() {
        return nElems == max;
    }

    // Insert a value into the array (if space allows)
    public void insert(int value) {
        if (isFull()) {
            System.out.println(&quot;Array is full&quot;);
            return;
        }
        theArray[nElems++] = value; // Place value and increment element count
    }

    // Public method to start the merge sort process
    public void sort() {
        int[] workspace = new int[nElems]; // Temporary workspace for merging
        recMergeSort(workspace, 0, nElems - 1); // Begin recursive sorting
    }

    // Recursive function that splits and sorts subarrays
    private void recMergeSort(int[] workspace, int lowerBound, int upperBound) {
        if (lowerBound &gt;= upperBound) return; // Base case: one element

        int mid = (lowerBound + upperBound) / 2; // Find midpoint

        // Recursively sort left and right halves
        recMergeSort(workspace, lowerBound, mid);
        recMergeSort(workspace, mid + 1, upperBound);

        // Merge the two sorted halves
        merge(workspace, lowerBound, mid + 1, upperBound);
    }

    // Merge two sorted halves into a single sorted run
    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {
        int j = 0;                   // Index for workspace
        int lowerBound = lowPtr;     // Start index of left half
        int mid = highPtr - 1;       // End index of left half
        int n = upperBound - lowerBound + 1; // Total elements to merge

        // Compare elements from both halves and copy the smaller one first
        while (lowPtr &lt;= mid &amp;&amp; highPtr &lt;= upperBound) {
            workspace[j++] = (theArray[lowPtr] &lt;= theArray[highPtr])
                    ? theArray[lowPtr++]
                    : theArray[highPtr++];
        }

        // Copy any remaining elements from the left half
        if (lowPtr &lt;= mid) {
            System.arraycopy(theArray, lowPtr, workspace, j, mid - lowPtr + 1);
            j += (mid - lowPtr + 1);
        }

        // Copy any remaining elements from the right half
        if (highPtr &lt;= upperBound) {
            System.arraycopy(theArray, highPtr, workspace, j, upperBound - highPtr + 1);
        }

        // Copy merged elements back into the original array
        System.arraycopy(workspace, 0, theArray, lowerBound, n);
    }

    // Utility method to display the array contents
    public void displayArray() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; nElems; i++) sb.append(theArray[i]).append(&#x27; &#x27;);
        System.out.println(sb.toString());
    }
} // End Of Class

class MergeSort_Iterative implements Sorter {

    // Instance Variables
    private int[] theArray;  // The array to be sorted
    private int nElems;      // Current number of elements in the array
    private int max;         // Maximum array capacity (limit)

    // Constructor
    public MergeSort_Iterative (int max) {
        // Initialize the array and size counters
        theArray = new int[max];
        nElems = 0;
        this.max = max;
    }


    // Utility Method
    // Checks whether the array is already full
    private boolean isFull() {
        return nElems == max;
    }

    // Insert Method
    // Adds a value to the array if space is available
    public void insert(int value) {
        if (isFull()) {
            System.out.println(&quot;Array is full&quot;);
            return;
        }
        // Store value and increase the element count
        theArray[nElems++] = value;
    }


    // Iterative Merge Sort
    public void sort() {
        int[] workspace = new int[nElems]; // Temporary array used during merging
        
        // subSize represents the size of subarrays being merged each pass
        // Start with subarrays of size 1 and double the size each iteration
        for (int subSize = 1; subSize &lt; nElems; subSize *= 2) {
            
            // Process and merge all pairs of subarrays of the current subSize
            for (int leftStart = 0; leftStart &lt; nElems - subSize; leftStart += 2 * subSize) {
                
                // leftStart: beginning index of left subarray
                int mid = leftStart + subSize - 1; // Last index of left subarray
                
                // Ensure the right subarray does not exceed array bounds
                int rightEnd = Math.min(leftStart + 2 * subSize - 1, nElems - 1);
                
                // Merge the two adjacent sorted subarrays into one
                merge(workspace, leftStart, mid + 1, rightEnd);
            }
        }
    }


    // Merge Method
    // Merges two sorted halves into a single sorted section
    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {
        int j = 0;                    // Index for workspace array
        int lowerBound = lowPtr;      // Start index of the left half
        int mid = highPtr - 1;        // End index of the left half
        int n = upperBound - lowerBound + 1; // Total number of elements to merge

        // Compare elements from both halves and copy the smaller one first
        while (lowPtr &lt;= mid &amp;&amp; highPtr &lt;= upperBound) {
            if (theArray[lowPtr] &lt;= theArray[highPtr])
                workspace[j++] = theArray[lowPtr++]; // Copy from left half
            else
                workspace[j++] = theArray[highPtr++]; // Copy from right half
        }

        // Copy any remaining elements from the left half
        while (lowPtr &lt;= mid) {
            workspace[j++] = theArray[lowPtr++];
        }

        // Copy any remaining elements from the right half
        while (highPtr &lt;= upperBound) {
            workspace[j++] = theArray[highPtr++];
        }

        // Copy merged elements back into the original array
        for (int k = 0; k &lt; n; k++) {
            theArray[lowerBound + k] = workspace[k];
        }
    }
    
    // Utility method to display the array contents
    public void displayArray() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; nElems; i++) sb.append(theArray[i]).append(&#x27; &#x27;);
        System.out.println(sb.toString());
    }
}


public class MergeSort_Rev {


    public static void main(String[] args)
    {
        
        int maxSize = 15    ;
        int sampleSize =  (int)(maxSize * .9);
        int choice = 2;
        
        Sorter ms;
        
        // create the object
        if(choice == 1)
        {
            // recursive
        	ms = new MergeSort(maxSize);
        }
        else
        {
            // iterative - loops
            ms = new MergeSort_Iterative (maxSize);
        }

        // Create RNG
        Random RNG = new Random();

        // insert random numbers
        for(int c = 0 ; c &lt; sampleSize; c++)
        {
            ms.insert(RNG.nextInt(0,maxSize));
        }
      
        // display the orignal array
        ms.displayArray();

        
        // sort the list
        ms.sort();
        
        // spacing
        System.out.println();

        // display the sorted list
        ms.displayArray();

        System.out.println(&quot;\nbye\n&quot;);
    }
    
}</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="linked-lists" class="relative group"><span class="heading-text">Linked Lists</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#linked-lists" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><h3 id="demo-code-1" class="relative group"><span class="heading-text">Demo Code</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#demo-code-1" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><div class="relative myst-code group not-prose my-5 text-sm shadow hover:shadow-md dark:shadow-2xl dark:shadow-neutral-900 bg-stone-200/10"><pre class="block overflow-auto p-3 myst-code-body hljs" style="background-color:unset"><code class="language-java" style="white-space:pre">/*
 * Example program demonstrating two implementations of Merge Sort
 * for a linked list of people (first name, last name, city).
 * 
 * Both recursive (top-down) and iterative (bottom-up) versions
 * implement a common interface (Sorter) for interchangeable use.
 *
 * Author: [Your Name]
 * Course: [Your Class Name or Section]
 */

package mergesortlinkedlist;

// ----------------------------------------------------------------------
// Interface Definition
// ----------------------------------------------------------------------

/**
 * The Sorter interface defines a simple contract for
 * inserting, sorting, and displaying a collection.
 * 
 * Both recursive and iterative merge sort classes
 * will implement this interface to ensure consistent usage.
 */
interface Sorter {
    void insert(String fn, String ln, String cty);
    void sort();
    void displayList();
}

// ----------------------------------------------------------------------
// Recursive Merge Sort Implementation
// ----------------------------------------------------------------------

/**
 * MergeSortLinkedList_Recursive
 * 
 * Uses a recursive (top-down) merge sort approach.
 * The list is divided into halves until single nodes remain,
 * then merged back together in sorted order by last name.
 */
class MergeSortLinkedList_Recursive implements Sorter {

    /**
     * Inner class Node — represents a single record in the linked list.
     * Each node stores a person&#x27;s first name, last name, and city.
     */
    class Node {
        String firstName;
        String lastName;
        String city;
        Node next;

        Node(String firstName, String lastName, String city) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.city = city;
            this.next = null;
        }
    }

    private Node head;  // Head pointer for the linked list

    /**
     * Inserts a new node at the end of the list.
     */
    public void insert(String firstName, String lastName, String city) {
        Node newNode = new Node(firstName, lastName, city);
        if (head == null) {
            head = newNode;
            return;
        }

        Node current = head;
        while (current.next != null)
            current = current.next;
        current.next = newNode;
    }

    /**
     * Public sort method — initiates recursive merge sort.
     */
    public void sort() {
        head = mergeSort(head);
    }

    /**
     * Recursive merge sort: splits the list, sorts each half, and merges them.
     */
    private Node mergeSort(Node h) {
        // Base case: 0 or 1 element
        if (h == null || h.next == null) return h;

        // Split the list into two halves
        Node middle = getMiddle(h);
        Node nextOfMiddle = middle.next;
        middle.next = null; // Split into two sublists

        // Recursively sort both halves
        Node left = mergeSort(h);
        Node right = mergeSort(nextOfMiddle);

        // Merge the two sorted halves
        return sortedMerge(left, right);
    }

    /**
     * Merges two sorted linked lists into one (sorted by last name).
     */
    private Node sortedMerge(Node a, Node b) {
        if (a == null) return b;
        if (b == null) return a;

        Node result;

        // Compare by last name (case-insensitive)
        if (a.lastName.compareToIgnoreCase(b.lastName) &lt;= 0) {
            result = a;
            result.next = sortedMerge(a.next, b);
        } else {
            result = b;
            result.next = sortedMerge(a, b.next);
        }

        return result;
    }

    /**
     * Finds the middle node of a linked list using the fast/slow pointer method.
     */
    private Node getMiddle(Node h) {
        if (h == null) return h;

        Node slow = h, fast = h;
        while (fast.next != null &amp;&amp; fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    /**
     * Displays the contents of the linked list.
     */
    public void displayList() {
        Node current = head;
        while (current != null) {
            System.out.printf(&quot;%-10s %-10s %-10s%n&quot;,
                    current.firstName, current.lastName, current.city);
            current = current.next;
        }
        System.out.println();
    }
}

// ----------------------------------------------------------------------
// Iterative Merge Sort Implementation
// ----------------------------------------------------------------------

/**
 * MergeSortLinkedList_Iterative
 * 
 * Uses an iterative (bottom-up) merge sort approach.
 * Starts by merging small sorted sublists of size 1, then doubles
 * the size of the sublists (1, 2, 4, 8...) until the full list is sorted.
 */
class MergeSortLinkedList_Iterative implements Sorter {

    /**
     * Inner class Node — represents a single record in the linked list.
     */
    class Node {
        String firstName;
        String lastName;
        String city;
        Node next;

        Node(String firstName, String lastName, String city) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.city = city;
            this.next = null;
        }
    }

    private Node head; // Head of the linked list

    /**
     * Inserts a new node at the end of the list.
     */
    public void insert(String firstName, String lastName, String city) {
        Node newNode = new Node(firstName, lastName, city);
        if (head == null) {
            head = newNode;
            return;
        }
        Node current = head;
        while (current.next != null)
            current = current.next;
        current.next = newNode;
    }

    /**
     * Public method to start iterative merge sort.
     */
    public void sort() {
        head = mergeSortIterative(head);
    }

    /**
     * Iterative (loop-based) merge sort implementation.
     * Uses sublist merging of increasing size to avoid recursion.
     */
    private Node mergeSortIterative(Node head) {
        if (head == null || head.next == null) return head;

        int n = getSize(head);

        // Dummy node simplifies pointer management during merging
        Node dummy = new Node(&quot;&quot;, &quot;&quot;, &quot;&quot;);
        dummy.next = head;

        // Merge sublists of size 1, 2, 4, 8, etc.
        for (int step = 1; step &lt; n; step *= 2) {
            Node prev = dummy;
            Node current = dummy.next;

            while (current != null) {
                Node left = current;
                Node right = split(left, step);
                current = split(right, step);

                Node merged = sortedMerge(left, right);
                prev.next = merged;

                // Move &#x27;prev&#x27; to the end of the merged sublist
                while (prev.next != null)
                    prev = prev.next;
            }
        }

        return dummy.next;
    }

    /**
     * Splits the list after &#x27;size&#x27; nodes and returns the next sublist.
     */
    private Node split(Node head, int size) {
        if (head == null) return null;
        for (int i = 1; head.next != null &amp;&amp; i &lt; size; i++)
            head = head.next;

        Node second = head.next;
        head.next = null;
        return second;
    }

    /**
     * Merges two sorted linked lists (by last name).
     */
    private Node sortedMerge(Node a, Node b) {
        Node dummy = new Node(&quot;&quot;, &quot;&quot;, &quot;&quot;);
        Node tail = dummy;

        while (a != null &amp;&amp; b != null) {
            if (a.lastName.compareToIgnoreCase(b.lastName) &lt;= 0) {
                tail.next = a;
                a = a.next;
            } else {
                tail.next = b;
                b = b.next;
            }
            tail = tail.next;
        }

        tail.next = (a != null) ? a : b;
        return dummy.next;
    }

    /**
     * Counts the number of nodes in the list.
     */
    private int getSize(Node head) {
        int count = 0;
        while (head != null) {
            count++;
            head = head.next;
        }
        return count;
    }

    /**
     * Displays the contents of the linked list.
     */
    public void displayList() {
        Node current = head;
        while (current != null) {
            System.out.printf(&quot;%-10s %-10s %-10s%n&quot;,
                    current.firstName, current.lastName, current.city);
            current = current.next;
        }
        System.out.println();
    }
}

// ----------------------------------------------------------------------
// Driver Class
// ----------------------------------------------------------------------

/**
 * Main driver class.
 * 
 * Demonstrates the use of both recursive and iterative
 * linked list merge sort implementations via the Sorter interface.
 */
public class MergeSortLinkedList {

    public static void main(String[] args) {

        Sorter list;

        int choice = 1;  // 1 = Recursive, 2 = Iterative

        if (choice == 1)
            list = new MergeSortLinkedList_Recursive();
        else
            list = new MergeSortLinkedList_Iterative();

        // Insert sample data
        list.insert(&quot;Alice&quot;, &quot;Zimmer&quot;, &quot;Chicago&quot;);
        list.insert(&quot;Bob&quot;, &quot;Anderson&quot;, &quot;Kalispell&quot;);
        list.insert(&quot;Cathy&quot;, &quot;Johnson&quot;, &quot;Seattle&quot;);
        list.insert(&quot;Daniel&quot;, &quot;Brown&quot;, &quot;Denver&quot;);

        // Display before sorting
        System.out.println(&quot;Before Sorting:&quot;);
        list.displayList();

        // Sort and display results
        list.sort();
        System.out.println(&quot;After Sorting by Last Name:&quot;);
        list.displayList();
    }
}
</code></pre><button title="Copy to Clipboard" class="inline-flex items-center opacity-0 group-hover:opacity-100 hover:opacity-100 focus:opacity-100 active:opacity-100 cursor-pointer ml-2 transition-color duration-200 ease-in-out text-blue-400 hover:text-blue-500 absolute right-1 myst-code-copy-icon top-1" aria-pressed="false" aria-label="Copy code to clipboard"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="24" height="24"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"></path></svg></button></div><h2 id="when-to-use" class="relative group"><span class="heading-text">When To Use</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#when-to-use" title="Link to this Section" aria-label="Link to this Section">¶</a></h2><h3 id="quick-summary" class="relative group"><span class="heading-text">Quick summary</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#quick-summary" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><ul><li><p><strong>Both</strong> are <code>O(n log n)</code> time, <strong>stable</strong>, and <code>O(1)</code> extra space on the list (recursive adds <code>O(log n)</code> call-stack space).</p></li><li><p><strong>Recursive</strong> = simpler to read/teach; <strong>Iterative</strong> = no recursion, often better constants and safer for huge inputs.</p></li></ul><h3 id="strengths-vs-weaknesses" class="relative group"><span class="heading-text">Strengths vs. weaknesses</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#strengths-vs-weaknesses" title="Link to this Section" aria-label="Link to this Section">¶</a></h3><h4 id="recursive-top-down" class="relative group"><span class="heading-text">Recursive (top-down)</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#recursive-top-down" title="Link to this Section" aria-label="Link to this Section">¶</a></h4><p><strong>How it works:</strong> repeatedly split with fast/slow pointers (<code>getMiddle</code>), then merge.</p><p><strong>Strengths</strong></p><ul><li><p><strong>Clarity &amp; pedagogy:</strong> mirrors the textbook definition; very readable for students.</p></li><li><p><strong>Natural structure:</strong> the “divide → conquer → combine” flow matches the mental model of merge sort.</p></li><li><p><strong>Easy to parallelize:</strong> left and right halves can be sorted concurrently if you go multi-threaded later.</p></li><li><p><strong>Stable by construction:</strong> merge step preserves order of equals.</p></li></ul><p><strong>Weaknesses</strong></p><ul><li><p><strong>Call-stack use:</strong> <code>O(log n)</code> stack frames. Usually fine, but it’s still extra memory and can matter on very tight stacks or unusual environments.</p></li><li><p><strong>Function-call overhead:</strong> many small recursive calls; minor but measurable on some JVMs.</p></li><li><p><strong>Middle finding every level:</strong> each split uses fast/slow pointers; total cost stays <code>O(n log n)</code> but the constant factor isn’t free.</p></li></ul><h4 id="iterative-bottom-up" class="relative group"><span class="heading-text">Iterative (bottom-up)</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#iterative-bottom-up" title="Link to this Section" aria-label="Link to this Section">¶</a></h4><p><strong>How it works:</strong> repeatedly merge runs of size <code>1, 2, 4, 8, …</code> using loops; uses pointer “splicing” (<code>split</code>, <code>merge</code>) and a dummy head.</p><p><strong>Strengths</strong></p><ul><li><p><strong>No recursion:</strong> avoids stack growth entirely; safer for <strong>very large lists</strong> or constrained runtimes.</p></li><li><p><strong>Good constants:</strong> one linear pass per run size; practical throughput often edges out recursive on linked lists.</p></li><li><p><strong>Predictable control flow:</strong> all in loops; easy to bound and instrument.</p></li><li><p><strong>Still stable:</strong> merge loop preserves order of equals.</p></li></ul><p><strong>Weaknesses</strong></p><ul><li><p><strong>More pointer surgery:</strong> more places to make off-by-one / null-next mistakes; trickier to get right first time.</p></li><li><p><strong>Slightly less intuitive to newcomers:</strong> bottom-up run doubling is less obvious than “split in half”.</p></li><li><p><strong>Needs size or tail walking:</strong> typical pattern computes <code>n</code> up front or advances pointers carefully; again, more book-keeping.</p></li></ul><h4 id="performance-resource-notes" class="relative group"><span class="heading-text">Performance &amp; resource notes</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#performance-resource-notes" title="Link to this Section" aria-label="Link to this Section">¶</a></h4><ul><li><p><strong>Time complexity:</strong> both <code>O(n log n)</code> on singly linked lists.</p></li><li><p><strong>Space:</strong> both in-place on nodes; <strong>recursive adds <code>O(log n)</code> call stack</strong>, iterative doesn’t.</p></li><li><p><strong>Cache locality:</strong> neither is great (linked lists aren’t cache-friendly), but iterative’s fewer function calls can help a bit.</p></li><li><p><strong>Stability:</strong> both remain stable as long as your merge uses <code>&lt;=</code> (or equivalent) and never reorders equals.</p></li></ul><h4 id="when-to-pick-which" class="relative group"><span class="heading-text">When to pick which</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#when-to-pick-which" title="Link to this Section" aria-label="Link to this Section">¶</a></h4><ul><li><p><strong>Teaching / readability / quick correctness:</strong> <strong>Recursive</strong>.</p></li><li><p><strong>Production on huge lists / tight memory / maximum robustness:</strong> <strong>Iterative</strong>.</p></li><li><p><strong>Parallel sort of very large lists:</strong> <strong>Recursive</strong> lends itself to parallelizing the two halves.</p></li></ul><h4 id="practical-checklist" class="relative group"><span class="heading-text">Practical checklist</span><a class="no-underline text-inherit hover:text-inherit inline-block w-0 px-0 translate-x-[10px] font-normal select-none transition-opacity opacity-0 focus:opacity-100 group-hover:opacity-70" href="#practical-checklist" title="Link to this Section" aria-label="Link to this Section">¶</a></h4><ul><li><p>Need simple code? → <strong>Recursive</strong>.</p></li><li><p>Worried about stack or sorting millions of nodes? → <strong>Iterative</strong>.</p></li></ul><div class="myst-backmatter-parts"></div><div class="myst-footer-links flex pt-10 mb-10 space-x-4"><a class="myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700 myst-footer-link-prev" href="/csci132/xmergesort"><div class="flex h-full align-middle"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="myst-footer-link-icon self-center transition-transform group-hover:-translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"></path></svg><div class="flex-grow text-right"><div class="myst-footer-link-group text-xs text-gray-500 dark:text-gray-400">CSCI 132</div>Merge Sort</div></div></a><a class="myst-footer-link flex-1 block p-4 font-normal text-gray-600 no-underline border border-gray-200 rounded shadow-sm group hover:border-blue-600 dark:hover:border-blue-400 hover:text-blue-600 dark:hover:text-blue-400 dark:text-gray-100 dark:border-gray-500 hover:shadow-lg dark:shadow-neutral-700 myst-footer-link-next" href="/csci132/xquicksort"><div class="flex h-full align-middle"><div class="flex-grow"><div class="myst-footer-link-group text-xs text-gray-500 dark:text-gray-400">CSCI 132</div>Quick Sort</div><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" width="1.5rem" height="1.5rem" class="myst-footer-link-icon self-center transition-transform group-hover:translate-x-1 shrink-0"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"></path></svg></div></a></div></article></main><script>((a,l)=>{if(!window.history.state||!window.history.state.key){let u=Math.random().toString(32).slice(2);window.history.replaceState({key:u},"")}try{let d=JSON.parse(sessionStorage.getItem(a)||"{}")[l||window.history.state.key];typeof d=="number"&&window.scrollTo(0,d)}catch(u){console.error(u),sessionStorage.removeItem(a)}})("positions", null)</script><link rel="modulepreload" href="/csci132/build/entry.client-PCJPW7TK.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-AQ2CODAG.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-JJXTQVMA.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-OZE3FFNP.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-N76G4W6Y.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-C4DFGG5C.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-J7TUH54J.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-FZ2S7OYD.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-JEM6JXYA.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-34XIY2DH.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-KQM5FBHR.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-OCWQY3HK.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-7HNKBP4B.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-CUKUDK3R.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-3EBOCCHJ.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-O4VQNZ62.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-4OEDG4JQ.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-GUCIBHGO.js"/><link rel="modulepreload" href="/csci132/build/root-AA24SA6C.js"/><link rel="modulepreload" href="/csci132/build/_shared/chunk-AH7OE64W.js"/><link rel="modulepreload" href="/csci132/build/routes/$-5SFLQWPV.js"/><script>window.__remixContext = {"url":"/xmergesort-reva","state":{"loaderData":{"root":{"config":{"version":2,"myst":"1.6.4","options":{"logo_text":"CSCI 132"},"nav":[],"actions":[],"projects":[{"date":"2025-12-04","exports":[],"title":"JAVA and Basic Algorithms","short_title":"CSCI 132","description":"Course material for CSCI 132","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_bdbook\\myst-generated-uid-0"}],"keywords":["JAVA","Algorithms"],"id":"70435226-f2e9-4585-b1e5-763a843f2399","toc":[{"file":"index.md"},{"file":"xDataStructuresAndAlgorithms.md"},{"children":[{"file":"xArraysCoreFunctionality.md"},{"file":"xArrayWarpAround.md"},{"file":"xArrayAddDeleteData.md"}],"file":"xArrayTechniques.md"},{"file":"xEncapsulationNonEncapsulation.md"},{"children":[{"file":"xON_VisualizingBigONotation.md"},{"file":"xBigONotationExplained.md"}],"file":"xBigONotation.md"},{"children":[{"file":"xSinglyLinkedListRev3.md"},{"file":"xDoublyLinkedList.md"},{"file":"xDoublyLinkedListSubClass.md"},{"file":"xCircularLinkedList.md"},{"file":"xDoublyLinkedListReadDataIntoLL.md"},{"file":"xDoublyLinkedListCSharp.md"},{"file":"xDoublyLinkedListJava.md"}],"file":"xLinkedLists.md"},{"children":[{"file":"xStackUsingArrayOfObjects.md"},{"file":"xQueueUsingArrayOfObjects.md"},{"file":"xPriorityQueue.md"}],"file":"xStacksAndQueues.md"},{"children":[{"file":"xSort_Bubble.md"},{"file":"xbucketsort.md"},{"file":"xMergeSort.md"},{"file":"xMergeSort_revA.md"},{"file":"xQuickSort.md"},{"file":"xQuicksortDemo.md"},{"file":"xQuicksortLinkedLists.md"},{"file":"xSort_HeapSort.md"},{"file":"xUnderstandingQuickMergeHeap.md"},{"file":"xSortingVideosVisualizers.md"},{"file":"xend.md"}],"file":"xSortAlgorithms.md"}],"bibliography":[],"index":"index","pages":[{"slug":"xdatastructuresandalgorithms","title":"Data Structures and Algorithms","description":"","date":"2025-12-04","thumbnail":"/csci132/build/c798a09d2ea7aaf43821d8d632896091.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xarraytechniques","title":"Array Techniques","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xarrayscorefunctionality","title":"Arrays Core Functionality","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xarraywarparound","title":"Array Warp Around","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xarrayadddeletedata","title":"Array Add and Delete Data","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xencapsulationnonencapsulation","title":"Encapsulation vs Non-Encapsulation","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbigonotation","title":"Big O Notation","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xon-visualizingbigonotation","title":"Visualizing Big O notation","description":"","date":"2025-12-04","thumbnail":"/csci132/build/vbon_image_O1-9b81a61817a64d078f43a349fd16f04b.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbigonotationexplained","title":"Big O Notation - Explained","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xlinkedlists","title":"Linked Lists","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xsinglylinkedlistrev3","title":"Singly Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlist","title":"Doubly Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistsubclass","title":"Doubly Linked List - Links as Sub Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xcircularlinkedlist","title":"Circular Linked List - Links as Sub Class","description":"","date":"2025-12-04","thumbnail":"/csci132/build/CircularLinkList-c844fefbdf30018d464995a97d1c7c8d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistreaddataintoll","title":"Reading Datafile Into Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistcsharp","title":"C# Linked List Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistjava","title":"Java Linked List Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xstacksandqueues","title":"Stacks and Queues","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xstackusingarrayofobjects","title":"Stack  - Using Array of Objects","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xqueueusingarrayofobjects","title":"Queue  - Using Array Of Objects","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xpriorityqueue","title":"Priority Queue","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsortalgorithms","title":"Sorting Algorithms","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xsort-bubble","title":"Bubble Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbucketsort","title":"Bucket Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xmergesort","title":"Merge Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xmergesort-reva","title":"Merge Sort - Demo Code","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksort","title":"Quick Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksortdemo","title":"Quicksort Demo","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksortlinkedlists","title":"Quicksort - Linked Lists","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsort-heapsort","title":"Heap Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingquickmergeheap","title":"Understanding Three Quick, Merge, and Heap Sort Algorithms","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsortingvideosvisualizers","title":"Sorting Videos and Visualizers","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End Of Section","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2}]}]},"CONTENT_CDN_PORT":"3100","MODE":"static","BASE_URL":"/csci132"},"routes/$":{"config":{"version":2,"myst":"1.6.4","options":{"logo_text":"CSCI 132"},"nav":[],"actions":[],"projects":[{"date":"2025-12-04","exports":[],"title":"JAVA and Basic Algorithms","short_title":"CSCI 132","description":"Course material for CSCI 132","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_bdbook\\myst-generated-uid-0"}],"keywords":["JAVA","Algorithms"],"id":"70435226-f2e9-4585-b1e5-763a843f2399","toc":[{"file":"index.md"},{"file":"xDataStructuresAndAlgorithms.md"},{"children":[{"file":"xArraysCoreFunctionality.md"},{"file":"xArrayWarpAround.md"},{"file":"xArrayAddDeleteData.md"}],"file":"xArrayTechniques.md"},{"file":"xEncapsulationNonEncapsulation.md"},{"children":[{"file":"xON_VisualizingBigONotation.md"},{"file":"xBigONotationExplained.md"}],"file":"xBigONotation.md"},{"children":[{"file":"xSinglyLinkedListRev3.md"},{"file":"xDoublyLinkedList.md"},{"file":"xDoublyLinkedListSubClass.md"},{"file":"xCircularLinkedList.md"},{"file":"xDoublyLinkedListReadDataIntoLL.md"},{"file":"xDoublyLinkedListCSharp.md"},{"file":"xDoublyLinkedListJava.md"}],"file":"xLinkedLists.md"},{"children":[{"file":"xStackUsingArrayOfObjects.md"},{"file":"xQueueUsingArrayOfObjects.md"},{"file":"xPriorityQueue.md"}],"file":"xStacksAndQueues.md"},{"children":[{"file":"xSort_Bubble.md"},{"file":"xbucketsort.md"},{"file":"xMergeSort.md"},{"file":"xMergeSort_revA.md"},{"file":"xQuickSort.md"},{"file":"xQuicksortDemo.md"},{"file":"xQuicksortLinkedLists.md"},{"file":"xSort_HeapSort.md"},{"file":"xUnderstandingQuickMergeHeap.md"},{"file":"xSortingVideosVisualizers.md"},{"file":"xend.md"}],"file":"xSortAlgorithms.md"}],"bibliography":[],"index":"index","pages":[{"slug":"xdatastructuresandalgorithms","title":"Data Structures and Algorithms","description":"","date":"2025-12-04","thumbnail":"/csci132/build/c798a09d2ea7aaf43821d8d632896091.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xarraytechniques","title":"Array Techniques","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xarrayscorefunctionality","title":"Arrays Core Functionality","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xarraywarparound","title":"Array Warp Around","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xarrayadddeletedata","title":"Array Add and Delete Data","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xencapsulationnonencapsulation","title":"Encapsulation vs Non-Encapsulation","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbigonotation","title":"Big O Notation","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xon-visualizingbigonotation","title":"Visualizing Big O notation","description":"","date":"2025-12-04","thumbnail":"/csci132/build/vbon_image_O1-9b81a61817a64d078f43a349fd16f04b.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbigonotationexplained","title":"Big O Notation - Explained","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xlinkedlists","title":"Linked Lists","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xsinglylinkedlistrev3","title":"Singly Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlist","title":"Doubly Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistsubclass","title":"Doubly Linked List - Links as Sub Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xcircularlinkedlist","title":"Circular Linked List - Links as Sub Class","description":"","date":"2025-12-04","thumbnail":"/csci132/build/CircularLinkList-c844fefbdf30018d464995a97d1c7c8d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistreaddataintoll","title":"Reading Datafile Into Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistcsharp","title":"C# Linked List Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistjava","title":"Java Linked List Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xstacksandqueues","title":"Stacks and Queues","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xstackusingarrayofobjects","title":"Stack  - Using Array of Objects","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xqueueusingarrayofobjects","title":"Queue  - Using Array Of Objects","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xpriorityqueue","title":"Priority Queue","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsortalgorithms","title":"Sorting Algorithms","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xsort-bubble","title":"Bubble Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbucketsort","title":"Bucket Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xmergesort","title":"Merge Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xmergesort-reva","title":"Merge Sort - Demo Code","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksort","title":"Quick Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksortdemo","title":"Quicksort Demo","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksortlinkedlists","title":"Quicksort - Linked Lists","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsort-heapsort","title":"Heap Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingquickmergeheap","title":"Understanding Three Quick, Merge, and Heap Sort Algorithms","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsortingvideosvisualizers","title":"Sorting Videos and Visualizers","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End Of Section","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2}]}]},"page":{"version":2,"kind":"Article","sha256":"9e386581b58bab0e077a33e71eb63aa88fba7cb23a0cc93a4a130dcba262490d","slug":"xmergesort-reva","location":"/xMergeSort_revA.md","dependencies":[],"frontmatter":{"title":"Merge Sort - Demo Code","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_bdbook\\myst-generated-uid-0"}],"date":"2025-12-04","keywords":["JAVA","Algorithms"],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xMergeSort_revA.md","url":"/csci132/build/xMergeSort_revA-266827a16cf2c714e30509031ff44c15.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":3,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"strong","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"How Merge Sort Works","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"fvQalV0ju8"}],"key":"PCfSQRieJ9"}],"identifier":"how-merge-sort-works","label":"How Merge Sort Works","html_id":"how-merge-sort-works","implicit":true,"key":"S1TaR49lSE"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Merge sort is a ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"Cr0XISiV5k"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"divide-and-conquer","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"MqBywqd306"}],"key":"nEtbgByeAZ"},{"type":"text","value":" sorting algorithm. It recursively divides the array into two halves until each subarray has only one element (which is trivially sorted). Then it ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"zDsTQR6mt3"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"merges","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"DbvZ1Z2RLY"}],"key":"Yw0cFFyEHh"},{"type":"text","value":" these sorted halves back together, comparing elements and building a larger sorted array step by step. This merging process continues until the entire array is reassembled in sorted order.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"XaDEn1crKZ"}],"key":"MONvANB2rz"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"The algorithm has a consistent time complexity of ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"e07E5KyGOl"},{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"O(n log n)","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"m7KemTNZAe"}],"key":"Hc2MdPbwv0"},{"type":"text","value":" — it divides the array (log n times) and merges n elements at each level. Merge sort is stable and efficient but requires extra space proportional to the array size due to its temporary workspace array.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"zsugWPmAVK"}],"key":"FSeuyTMZrE"},{"type":"heading","depth":2,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Arrays","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"weB9wnxJVJ"}],"identifier":"arrays","label":"Arrays","html_id":"arrays","implicit":true,"key":"PoeIflyrpu"},{"type":"heading","depth":3,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Demo Code","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"NPg5FEIjP2"}],"identifier":"demo-code","label":"Demo Code","html_id":"demo-code","implicit":true,"key":"sI0ZJtkuhr"},{"type":"code","lang":"java","value":"/*\nEngineer: James Goduy\n */\npackage mergesort_rev;\n\nimport java.util.Random;\n\n\n/*\n * The Sorter interface defines a contract that all sorting classes must follow.\n * Any class that implements Sorter must provide concrete versions of insert(),\n * sort(), and displayArray(). These are method signatures only—no code \n * is written here.\n *\n * Using an interface allows us to treat different sorting algorithms (e.g.,\n * recursive and iterative merge sorts) as the same \"type.\" This is an example\n * of polymorphism: we can write one block of code that works with any object\n * implementing Sorter, regardless of how it performs the sorting internally.\n *\n * In short, the interface provides a common structure (what must be done),\n * while each class defines its own behavior (how it is done).\n */\n\ninterface Sorter {\n    void insert(int value);\n    void sort();\n    void displayArray();\n}\n\n\nclass MergeSort implements Sorter {\n\n    private int[] theArray;  // Main array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum capacity of the array\n\n    // Constructor: initializes the array and tracking variables\n    public MergeSort(int max) {\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n    // Check if array is full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert a value into the array (if space allows)\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        theArray[nElems++] = value; // Place value and increment element count\n    }\n\n    // Public method to start the merge sort process\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary workspace for merging\n        recMergeSort(workspace, 0, nElems - 1); // Begin recursive sorting\n    }\n\n    // Recursive function that splits and sorts subarrays\n    private void recMergeSort(int[] workspace, int lowerBound, int upperBound) {\n        if (lowerBound \u003e= upperBound) return; // Base case: one element\n\n        int mid = (lowerBound + upperBound) / 2; // Find midpoint\n\n        // Recursively sort left and right halves\n        recMergeSort(workspace, lowerBound, mid);\n        recMergeSort(workspace, mid + 1, upperBound);\n\n        // Merge the two sorted halves\n        merge(workspace, lowerBound, mid + 1, upperBound);\n    }\n\n    // Merge two sorted halves into a single sorted run\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                   // Index for workspace\n        int lowerBound = lowPtr;     // Start index of left half\n        int mid = highPtr - 1;       // End index of left half\n        int n = upperBound - lowerBound + 1; // Total elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr \u003c= mid \u0026\u0026 highPtr \u003c= upperBound) {\n            workspace[j++] = (theArray[lowPtr] \u003c= theArray[highPtr])\n                    ? theArray[lowPtr++]\n                    : theArray[highPtr++];\n        }\n\n        // Copy any remaining elements from the left half\n        if (lowPtr \u003c= mid) {\n            System.arraycopy(theArray, lowPtr, workspace, j, mid - lowPtr + 1);\n            j += (mid - lowPtr + 1);\n        }\n\n        // Copy any remaining elements from the right half\n        if (highPtr \u003c= upperBound) {\n            System.arraycopy(theArray, highPtr, workspace, j, upperBound - highPtr + 1);\n        }\n\n        // Copy merged elements back into the original array\n        System.arraycopy(workspace, 0, theArray, lowerBound, n);\n    }\n\n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i \u003c nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n} // End Of Class\n\nclass MergeSort_Iterative implements Sorter {\n\n    // Instance Variables\n    private int[] theArray;  // The array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum array capacity (limit)\n\n    // Constructor\n    public MergeSort_Iterative (int max) {\n        // Initialize the array and size counters\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n\n    // Utility Method\n    // Checks whether the array is already full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert Method\n    // Adds a value to the array if space is available\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        // Store value and increase the element count\n        theArray[nElems++] = value;\n    }\n\n\n    // Iterative Merge Sort\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary array used during merging\n        \n        // subSize represents the size of subarrays being merged each pass\n        // Start with subarrays of size 1 and double the size each iteration\n        for (int subSize = 1; subSize \u003c nElems; subSize *= 2) {\n            \n            // Process and merge all pairs of subarrays of the current subSize\n            for (int leftStart = 0; leftStart \u003c nElems - subSize; leftStart += 2 * subSize) {\n                \n                // leftStart: beginning index of left subarray\n                int mid = leftStart + subSize - 1; // Last index of left subarray\n                \n                // Ensure the right subarray does not exceed array bounds\n                int rightEnd = Math.min(leftStart + 2 * subSize - 1, nElems - 1);\n                \n                // Merge the two adjacent sorted subarrays into one\n                merge(workspace, leftStart, mid + 1, rightEnd);\n            }\n        }\n    }\n\n\n    // Merge Method\n    // Merges two sorted halves into a single sorted section\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                    // Index for workspace array\n        int lowerBound = lowPtr;      // Start index of the left half\n        int mid = highPtr - 1;        // End index of the left half\n        int n = upperBound - lowerBound + 1; // Total number of elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr \u003c= mid \u0026\u0026 highPtr \u003c= upperBound) {\n            if (theArray[lowPtr] \u003c= theArray[highPtr])\n                workspace[j++] = theArray[lowPtr++]; // Copy from left half\n            else\n                workspace[j++] = theArray[highPtr++]; // Copy from right half\n        }\n\n        // Copy any remaining elements from the left half\n        while (lowPtr \u003c= mid) {\n            workspace[j++] = theArray[lowPtr++];\n        }\n\n        // Copy any remaining elements from the right half\n        while (highPtr \u003c= upperBound) {\n            workspace[j++] = theArray[highPtr++];\n        }\n\n        // Copy merged elements back into the original array\n        for (int k = 0; k \u003c n; k++) {\n            theArray[lowerBound + k] = workspace[k];\n        }\n    }\n    \n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i \u003c nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n}\n\n\npublic class MergeSort_Rev {\n\n\n    public static void main(String[] args)\n    {\n        \n        int maxSize = 15    ;\n        int sampleSize =  (int)(maxSize * .9);\n        int choice = 2;\n        \n        Sorter ms;\n        \n        // create the object\n        if(choice == 1)\n        {\n            // recursive\n        \tms = new MergeSort(maxSize);\n        }\n        else\n        {\n            // iterative - loops\n            ms = new MergeSort_Iterative (maxSize);\n        }\n\n        // Create RNG\n        Random RNG = new Random();\n\n        // insert random numbers\n        for(int c = 0 ; c \u003c sampleSize; c++)\n        {\n            ms.insert(RNG.nextInt(0,maxSize));\n        }\n      \n        // display the orignal array\n        ms.displayArray();\n\n        \n        // sort the list\n        ms.sort();\n        \n        // spacing\n        System.out.println();\n\n        // display the sorted list\n        ms.displayArray();\n\n        System.out.println(\"\\nbye\\n\");\n    }\n    \n}","position":{"start":{"line":13,"column":1},"end":{"line":277,"column":1}},"key":"vGjqAVB9Y1"},{"type":"heading","depth":2,"position":{"start":{"line":279,"column":1},"end":{"line":279,"column":1}},"children":[{"type":"text","value":"Linked Lists","position":{"start":{"line":279,"column":1},"end":{"line":279,"column":1}},"key":"hBe63wYsmw"}],"identifier":"linked-lists","label":"Linked Lists","html_id":"linked-lists","implicit":true,"key":"xav6rj2BgY"},{"type":"heading","depth":3,"position":{"start":{"line":281,"column":1},"end":{"line":281,"column":1}},"children":[{"type":"text","value":"Demo Code","position":{"start":{"line":281,"column":1},"end":{"line":281,"column":1}},"key":"vglZ3DNEm4"}],"identifier":"demo-code","label":"Demo Code","html_id":"demo-code-1","implicit":true,"key":"iZEGM0gFwl"},{"type":"code","lang":"java","value":"/*\n * Example program demonstrating two implementations of Merge Sort\n * for a linked list of people (first name, last name, city).\n * \n * Both recursive (top-down) and iterative (bottom-up) versions\n * implement a common interface (Sorter) for interchangeable use.\n *\n * Author: [Your Name]\n * Course: [Your Class Name or Section]\n */\n\npackage mergesortlinkedlist;\n\n// ----------------------------------------------------------------------\n// Interface Definition\n// ----------------------------------------------------------------------\n\n/**\n * The Sorter interface defines a simple contract for\n * inserting, sorting, and displaying a collection.\n * \n * Both recursive and iterative merge sort classes\n * will implement this interface to ensure consistent usage.\n */\ninterface Sorter {\n    void insert(String fn, String ln, String cty);\n    void sort();\n    void displayList();\n}\n\n// ----------------------------------------------------------------------\n// Recursive Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Recursive\n * \n * Uses a recursive (top-down) merge sort approach.\n * The list is divided into halves until single nodes remain,\n * then merged back together in sorted order by last name.\n */\nclass MergeSortLinkedList_Recursive implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     * Each node stores a person's first name, last name, and city.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head;  // Head pointer for the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public sort method — initiates recursive merge sort.\n     */\n    public void sort() {\n        head = mergeSort(head);\n    }\n\n    /**\n     * Recursive merge sort: splits the list, sorts each half, and merges them.\n     */\n    private Node mergeSort(Node h) {\n        // Base case: 0 or 1 element\n        if (h == null || h.next == null) return h;\n\n        // Split the list into two halves\n        Node middle = getMiddle(h);\n        Node nextOfMiddle = middle.next;\n        middle.next = null; // Split into two sublists\n\n        // Recursively sort both halves\n        Node left = mergeSort(h);\n        Node right = mergeSort(nextOfMiddle);\n\n        // Merge the two sorted halves\n        return sortedMerge(left, right);\n    }\n\n    /**\n     * Merges two sorted linked lists into one (sorted by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n\n        Node result;\n\n        // Compare by last name (case-insensitive)\n        if (a.lastName.compareToIgnoreCase(b.lastName) \u003c= 0) {\n            result = a;\n            result.next = sortedMerge(a.next, b);\n        } else {\n            result = b;\n            result.next = sortedMerge(a, b.next);\n        }\n\n        return result;\n    }\n\n    /**\n     * Finds the middle node of a linked list using the fast/slow pointer method.\n     */\n    private Node getMiddle(Node h) {\n        if (h == null) return h;\n\n        Node slow = h, fast = h;\n        while (fast.next != null \u0026\u0026 fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Iterative Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Iterative\n * \n * Uses an iterative (bottom-up) merge sort approach.\n * Starts by merging small sorted sublists of size 1, then doubles\n * the size of the sublists (1, 2, 4, 8...) until the full list is sorted.\n */\nclass MergeSortLinkedList_Iterative implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head; // Head of the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public method to start iterative merge sort.\n     */\n    public void sort() {\n        head = mergeSortIterative(head);\n    }\n\n    /**\n     * Iterative (loop-based) merge sort implementation.\n     * Uses sublist merging of increasing size to avoid recursion.\n     */\n    private Node mergeSortIterative(Node head) {\n        if (head == null || head.next == null) return head;\n\n        int n = getSize(head);\n\n        // Dummy node simplifies pointer management during merging\n        Node dummy = new Node(\"\", \"\", \"\");\n        dummy.next = head;\n\n        // Merge sublists of size 1, 2, 4, 8, etc.\n        for (int step = 1; step \u003c n; step *= 2) {\n            Node prev = dummy;\n            Node current = dummy.next;\n\n            while (current != null) {\n                Node left = current;\n                Node right = split(left, step);\n                current = split(right, step);\n\n                Node merged = sortedMerge(left, right);\n                prev.next = merged;\n\n                // Move 'prev' to the end of the merged sublist\n                while (prev.next != null)\n                    prev = prev.next;\n            }\n        }\n\n        return dummy.next;\n    }\n\n    /**\n     * Splits the list after 'size' nodes and returns the next sublist.\n     */\n    private Node split(Node head, int size) {\n        if (head == null) return null;\n        for (int i = 1; head.next != null \u0026\u0026 i \u003c size; i++)\n            head = head.next;\n\n        Node second = head.next;\n        head.next = null;\n        return second;\n    }\n\n    /**\n     * Merges two sorted linked lists (by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        Node dummy = new Node(\"\", \"\", \"\");\n        Node tail = dummy;\n\n        while (a != null \u0026\u0026 b != null) {\n            if (a.lastName.compareToIgnoreCase(b.lastName) \u003c= 0) {\n                tail.next = a;\n                a = a.next;\n            } else {\n                tail.next = b;\n                b = b.next;\n            }\n            tail = tail.next;\n        }\n\n        tail.next = (a != null) ? a : b;\n        return dummy.next;\n    }\n\n    /**\n     * Counts the number of nodes in the list.\n     */\n    private int getSize(Node head) {\n        int count = 0;\n        while (head != null) {\n            count++;\n            head = head.next;\n        }\n        return count;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Driver Class\n// ----------------------------------------------------------------------\n\n/**\n * Main driver class.\n * \n * Demonstrates the use of both recursive and iterative\n * linked list merge sort implementations via the Sorter interface.\n */\npublic class MergeSortLinkedList {\n\n    public static void main(String[] args) {\n\n        Sorter list;\n\n        int choice = 1;  // 1 = Recursive, 2 = Iterative\n\n        if (choice == 1)\n            list = new MergeSortLinkedList_Recursive();\n        else\n            list = new MergeSortLinkedList_Iterative();\n\n        // Insert sample data\n        list.insert(\"Alice\", \"Zimmer\", \"Chicago\");\n        list.insert(\"Bob\", \"Anderson\", \"Kalispell\");\n        list.insert(\"Cathy\", \"Johnson\", \"Seattle\");\n        list.insert(\"Daniel\", \"Brown\", \"Denver\");\n\n        // Display before sorting\n        System.out.println(\"Before Sorting:\");\n        list.displayList();\n\n        // Sort and display results\n        list.sort();\n        System.out.println(\"After Sorting by Last Name:\");\n        list.displayList();\n    }\n}\n","position":{"start":{"line":283,"column":1},"end":{"line":629,"column":1}},"key":"lOe2tPVa1T"},{"type":"heading","depth":2,"position":{"start":{"line":631,"column":1},"end":{"line":631,"column":1}},"children":[{"type":"text","value":"When To Use","position":{"start":{"line":631,"column":1},"end":{"line":631,"column":1}},"key":"Q6X4gDFD5F"}],"identifier":"when-to-use","label":"When To Use","html_id":"when-to-use","implicit":true,"key":"JjpmTYujyD"},{"type":"heading","depth":3,"position":{"start":{"line":633,"column":1},"end":{"line":633,"column":1}},"children":[{"type":"text","value":"Quick summary","position":{"start":{"line":633,"column":1},"end":{"line":633,"column":1}},"key":"aYsv1gr1gB"}],"identifier":"quick-summary","label":"Quick summary","html_id":"quick-summary","implicit":true,"key":"dGhRatNGW7"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":635,"column":1},"end":{"line":637,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"children":[{"type":"text","value":"Both","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"qvztXcVAwu"}],"key":"lnvmgMXkpQ"},{"type":"text","value":" are ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"bbaBeRg9Vz"},{"type":"inlineCode","value":"O(n log n)","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"aSVgthCMaq"},{"type":"text","value":" time, ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"cShZk9b6BP"},{"type":"strong","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"children":[{"type":"text","value":"stable","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"GUUpRq8DOE"}],"key":"s3pLWy8ym6"},{"type":"text","value":", and ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"I6wdkZeOe8"},{"type":"inlineCode","value":"O(1)","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"TJcMFYBEUA"},{"type":"text","value":" extra space on the list (recursive adds ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"I1sLWBqnW2"},{"type":"inlineCode","value":"O(log n)","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"Dp55rBKDoz"},{"type":"text","value":" call-stack space).","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"vxg6q6AQMK"}],"key":"Khx4plsCHV"}],"key":"OuqC4bN6Q1"},{"type":"listItem","spread":true,"position":{"start":{"line":636,"column":1},"end":{"line":637,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"TvIveThbb1"}],"key":"g9Hbom0i7S"},{"type":"text","value":" = simpler to read/teach; ","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"rr8uhMJ6pH"},{"type":"strong","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"children":[{"type":"text","value":"Iterative","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"pvifalLhxc"}],"key":"sG9X71ouPC"},{"type":"text","value":" = no recursion, often better constants and safer for huge inputs.","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"W2fL3JWVrJ"}],"key":"zgWIezLFgh"}],"key":"pPzgcz81in"}],"key":"TO4CTXQLdU"},{"type":"heading","depth":3,"position":{"start":{"line":638,"column":1},"end":{"line":638,"column":1}},"children":[{"type":"text","value":"Strengths vs. weaknesses","position":{"start":{"line":638,"column":1},"end":{"line":638,"column":1}},"key":"Hyl5pBXnWe"}],"identifier":"strengths-vs-weaknesses","label":"Strengths vs. weaknesses","html_id":"strengths-vs-weaknesses","implicit":true,"key":"GSfsdTqUbT"},{"type":"heading","depth":4,"position":{"start":{"line":640,"column":1},"end":{"line":640,"column":1}},"children":[{"type":"text","value":"Recursive (top-down)","position":{"start":{"line":640,"column":1},"end":{"line":640,"column":1}},"key":"cH4bwlTgxj"}],"identifier":"recursive-top-down","label":"Recursive (top-down)","html_id":"recursive-top-down","implicit":true,"key":"ZfMfNTBsaE"},{"type":"paragraph","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"children":[{"type":"strong","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"children":[{"type":"text","value":"How it works:","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"CUbbXqv8wD"}],"key":"Hi92NCCZFt"},{"type":"text","value":" repeatedly split with fast/slow pointers (","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"mCmW2iiPwe"},{"type":"inlineCode","value":"getMiddle","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"WYABLsQcs1"},{"type":"text","value":"), then merge.","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"H37apIKq8d"}],"key":"SzTMcVclG8"},{"type":"paragraph","position":{"start":{"line":644,"column":1},"end":{"line":644,"column":1}},"children":[{"type":"strong","position":{"start":{"line":644,"column":1},"end":{"line":644,"column":1}},"children":[{"type":"text","value":"Strengths","position":{"start":{"line":644,"column":1},"end":{"line":644,"column":1}},"key":"ZyttxwgKFn"}],"key":"NsrB6PQnyn"}],"key":"MfJA8yRpJR"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":646,"column":1},"end":{"line":650,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"children":[{"type":"text","value":"Clarity \u0026 pedagogy:","position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"key":"UPBelmA9Z4"}],"key":"jVNkwGDJmN"},{"type":"text","value":" mirrors the textbook definition; very readable for students.","position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"key":"s1AHijVkWV"}],"key":"bK5B6MaBPr"}],"key":"BLRy91GElb"},{"type":"listItem","spread":true,"position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"children":[{"type":"text","value":"Natural structure:","position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"key":"ypMBw2mFdi"}],"key":"JKZuG0szZJ"},{"type":"text","value":" the “divide → conquer → combine” flow matches the mental model of merge sort.","position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"key":"nmT8is8ddn"}],"key":"pbNzAIA3NZ"}],"key":"CB6JhmkENy"},{"type":"listItem","spread":true,"position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"children":[{"type":"text","value":"Easy to parallelize:","position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"key":"u0dL9DUR7M"}],"key":"jpyQZSAbWP"},{"type":"text","value":" left and right halves can be sorted concurrently if you go multi-threaded later.","position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"key":"eix5iZ9Dnj"}],"key":"pGPG19LylB"}],"key":"JtvafrvukB"},{"type":"listItem","spread":true,"position":{"start":{"line":649,"column":1},"end":{"line":650,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":649,"column":1},"end":{"line":649,"column":1}},"children":[{"type":"text","value":"Stable by construction:","position":{"start":{"line":649,"column":1},"end":{"line":649,"column":1}},"key":"WYJR6XeiJy"}],"key":"fDrSH0GteE"},{"type":"text","value":" merge step preserves order of equals.","position":{"start":{"line":649,"column":1},"end":{"line":649,"column":1}},"key":"gKjmE15DbZ"}],"key":"ndcDyQFbPn"}],"key":"yzJz7FKr0a"}],"key":"jlvcCjdwpX"},{"type":"paragraph","position":{"start":{"line":651,"column":1},"end":{"line":651,"column":1}},"children":[{"type":"strong","position":{"start":{"line":651,"column":1},"end":{"line":651,"column":1}},"children":[{"type":"text","value":"Weaknesses","position":{"start":{"line":651,"column":1},"end":{"line":651,"column":1}},"key":"SMac4ENK0g"}],"key":"gQnFWKFVLE"}],"key":"JzFkJsPv5k"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":653,"column":1},"end":{"line":656,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"text","value":"Call-stack use:","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"oybPeHWn3g"}],"key":"xDZwI66zNt"},{"type":"text","value":" ","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"rmOPoE15z1"},{"type":"inlineCode","value":"O(log n)","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"gM6YosON9S"},{"type":"text","value":" stack frames. Usually fine, but it’s still extra memory and can matter on very tight stacks or unusual environments.","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"Kz31PwkD0v"}],"key":"FACPKZoM62"}],"key":"vXDXYNsipk"},{"type":"listItem","spread":true,"position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"children":[{"type":"text","value":"Function-call overhead:","position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"key":"fsUcdjoJDK"}],"key":"zaDxBKyh2D"},{"type":"text","value":" many small recursive calls; minor but measurable on some JVMs.","position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"key":"F6EZDeU6uY"}],"key":"pRP0Jj9OPp"}],"key":"ixyf09IgcA"},{"type":"listItem","spread":true,"position":{"start":{"line":655,"column":1},"end":{"line":656,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"children":[{"type":"text","value":"Middle finding every level:","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"GP1Lz5hmHZ"}],"key":"ijqzF0mSMO"},{"type":"text","value":" each split uses fast/slow pointers; total cost stays ","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"pUoAkHf35W"},{"type":"inlineCode","value":"O(n log n)","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"FscIm3MbBs"},{"type":"text","value":" but the constant factor isn’t free.","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"wcFqUclLtn"}],"key":"TauIOSlGX7"}],"key":"ID12htqbKZ"}],"key":"TDgCatnn7K"},{"type":"heading","depth":4,"position":{"start":{"line":657,"column":1},"end":{"line":657,"column":1}},"children":[{"type":"text","value":"Iterative (bottom-up)","position":{"start":{"line":657,"column":1},"end":{"line":657,"column":1}},"key":"wehiATgqPB"}],"identifier":"iterative-bottom-up","label":"Iterative (bottom-up)","html_id":"iterative-bottom-up","implicit":true,"key":"ksGJumumQI"},{"type":"paragraph","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"children":[{"type":"strong","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"children":[{"type":"text","value":"How it works:","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"Hj7qPu5zyD"}],"key":"tuLXaiCsdU"},{"type":"text","value":" repeatedly merge runs of size ","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"tS0q1BXBGY"},{"type":"inlineCode","value":"1, 2, 4, 8, …","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"kkKz3OFjMj"},{"type":"text","value":" using loops; uses pointer “splicing” (","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"MSdVDoeYFa"},{"type":"inlineCode","value":"split","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"oE8vovQpps"},{"type":"text","value":", ","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"Sky5vx5PRx"},{"type":"inlineCode","value":"merge","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"xxjX474qKh"},{"type":"text","value":") and a dummy head.","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"MIZ2LvY4qO"}],"key":"sB3s1V8t85"},{"type":"paragraph","position":{"start":{"line":661,"column":1},"end":{"line":661,"column":1}},"children":[{"type":"strong","position":{"start":{"line":661,"column":1},"end":{"line":661,"column":1}},"children":[{"type":"text","value":"Strengths","position":{"start":{"line":661,"column":1},"end":{"line":661,"column":1}},"key":"VTJsYc6oEs"}],"key":"HGfg1KZTDJ"}],"key":"FYDaRaQflH"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":663,"column":1},"end":{"line":667,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"children":[{"type":"text","value":"No recursion:","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"aTn5DEylp6"}],"key":"QDc1Hxn64z"},{"type":"text","value":" avoids stack growth entirely; safer for ","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"wZqCO91Jip"},{"type":"strong","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"children":[{"type":"text","value":"very large lists","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"S39hJLhWJH"}],"key":"GmMd3FA4ON"},{"type":"text","value":" or constrained runtimes.","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"fEYr3uvjCR"}],"key":"bboJtbatUN"}],"key":"n5ViNUcPn5"},{"type":"listItem","spread":true,"position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"children":[{"type":"text","value":"Good constants:","position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"key":"serRVqcjN0"}],"key":"Ss5n8WrbP9"},{"type":"text","value":" one linear pass per run size; practical throughput often edges out recursive on linked lists.","position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"key":"YxQPitl0eI"}],"key":"gUuASAUjyH"}],"key":"dIsXsFSmj2"},{"type":"listItem","spread":true,"position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"children":[{"type":"text","value":"Predictable control flow:","position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"key":"NCcsUMxk9m"}],"key":"PUxkjGrsyd"},{"type":"text","value":" all in loops; easy to bound and instrument.","position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"key":"q1ftkLvMOV"}],"key":"sva6Nx3eSx"}],"key":"IBuXvSFlhU"},{"type":"listItem","spread":true,"position":{"start":{"line":666,"column":1},"end":{"line":667,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":666,"column":1},"end":{"line":666,"column":1}},"children":[{"type":"text","value":"Still stable:","position":{"start":{"line":666,"column":1},"end":{"line":666,"column":1}},"key":"asNPdBw8mY"}],"key":"yiVSRI74zr"},{"type":"text","value":" merge loop preserves order of equals.","position":{"start":{"line":666,"column":1},"end":{"line":666,"column":1}},"key":"PoaxZb7Yhk"}],"key":"r81MGkj2VQ"}],"key":"ZQQf3kY9Br"}],"key":"BWzHskZChe"},{"type":"paragraph","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"children":[{"type":"strong","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"children":[{"type":"text","value":"Weaknesses","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"key":"OEZzegHLpT"}],"key":"T13TXYSlBh"}],"key":"zUadbMUu9H"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":670,"column":1},"end":{"line":673,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"children":[{"type":"text","value":"More pointer surgery:","position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"key":"LspR46equ9"}],"key":"dOvaFyWCkz"},{"type":"text","value":" more places to make off-by-one / null-next mistakes; trickier to get right first time.","position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"key":"ic8p6Kqw5k"}],"key":"QnLlTEjOHe"}],"key":"Cega4TNG55"},{"type":"listItem","spread":true,"position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"children":[{"type":"text","value":"Slightly less intuitive to newcomers:","position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"key":"LC19ciEk8T"}],"key":"GZJliQmUVA"},{"type":"text","value":" bottom-up run doubling is less obvious than “split in half”.","position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"key":"Hy4BaUgvaf"}],"key":"DUOgc17fVc"}],"key":"lhxXaqCDUS"},{"type":"listItem","spread":true,"position":{"start":{"line":672,"column":1},"end":{"line":673,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"children":[{"type":"text","value":"Needs size or tail walking:","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"AToSpVCXzM"}],"key":"sKLdIlTM3A"},{"type":"text","value":" typical pattern computes ","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"fCtCJhJZtb"},{"type":"inlineCode","value":"n","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"uTntjNeSnf"},{"type":"text","value":" up front or advances pointers carefully; again, more book-keeping.","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"ruCUv8axqO"}],"key":"QPNQzsrehf"}],"key":"mpebj5t8WP"}],"key":"WBvzzLVgqM"},{"type":"heading","depth":4,"position":{"start":{"line":674,"column":1},"end":{"line":674,"column":1}},"children":[{"type":"text","value":"Performance \u0026 resource notes","position":{"start":{"line":674,"column":1},"end":{"line":674,"column":1}},"key":"MF7uXKt2tL"}],"identifier":"performance-resource-notes","label":"Performance \u0026 resource notes","html_id":"performance-resource-notes","implicit":true,"key":"OxuNtGMjYJ"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":676,"column":1},"end":{"line":680,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"children":[{"type":"text","value":"Time complexity:","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"dkz1Ln3iBw"}],"key":"CVap2zImtG"},{"type":"text","value":" both ","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"O5zyiqMQeP"},{"type":"inlineCode","value":"O(n log n)","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"xkMr9ciNqJ"},{"type":"text","value":" on singly linked lists.","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"KKS6HUKFSx"}],"key":"kBq9eFRmUe"}],"key":"MRx3C8sJS5"},{"type":"listItem","spread":true,"position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"children":[{"type":"text","value":"Space:","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"o1oYOhw0Iu"}],"key":"Y2cyH8tSTe"},{"type":"text","value":" both in-place on nodes; ","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"kAobF6VlbY"},{"type":"strong","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"children":[{"type":"text","value":"recursive adds ","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"gbXNWXoOEp"},{"type":"inlineCode","value":"O(log n)","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"e0MjBv46Dr"},{"type":"text","value":" call stack","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"Xhao8saACB"}],"key":"Htp3kV4oGY"},{"type":"text","value":", iterative doesn’t.","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"Kk776J9b0b"}],"key":"vJJtHMfdsy"}],"key":"FQGUxPybTp"},{"type":"listItem","spread":true,"position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"children":[{"type":"text","value":"Cache locality:","position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"key":"tdf09SQ1jn"}],"key":"f9WicyHLp7"},{"type":"text","value":" neither is great (linked lists aren’t cache-friendly), but iterative’s fewer function calls can help a bit.","position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"key":"spllI92ZIj"}],"key":"XGyf5hF8FE"}],"key":"VZselGVFYN"},{"type":"listItem","spread":true,"position":{"start":{"line":679,"column":1},"end":{"line":680,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"children":[{"type":"text","value":"Stability:","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"gl3gd5EqaU"}],"key":"yyIip15vir"},{"type":"text","value":" both remain stable as long as your merge uses ","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"LCJVIoim72"},{"type":"inlineCode","value":"\u003c=","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"mxuBEzjgtj"},{"type":"text","value":" (or equivalent) and never reorders equals.","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"G4hii5ys8N"}],"key":"S9tPZK3pmk"}],"key":"VqtBg4Umyw"}],"key":"tnFCCItSVV"},{"type":"heading","depth":4,"position":{"start":{"line":681,"column":1},"end":{"line":681,"column":1}},"children":[{"type":"text","value":"When to pick which","position":{"start":{"line":681,"column":1},"end":{"line":681,"column":1}},"key":"OWK60rys2q"}],"identifier":"when-to-pick-which","label":"When to pick which","html_id":"when-to-pick-which","implicit":true,"key":"fhtEO6fCUF"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":683,"column":1},"end":{"line":686,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"children":[{"type":"text","value":"Teaching / readability / quick correctness:","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"fJ1ZPhORbE"}],"key":"OEjGEL2lfl"},{"type":"text","value":" ","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"e86TiEHFrn"},{"type":"strong","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"Bmfnfnekhm"}],"key":"Yk6vsQ1oag"},{"type":"text","value":".","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"OkQixC9Sza"}],"key":"VFTUeuX65K"}],"key":"i0XmDlctsA"},{"type":"listItem","spread":true,"position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"children":[{"type":"text","value":"Production on huge lists / tight memory / maximum robustness:","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"Y3KboiLMPQ"}],"key":"sz4UF1cals"},{"type":"text","value":" ","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"PCuAx8ZDge"},{"type":"strong","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"children":[{"type":"text","value":"Iterative","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"S3TjmhkDbU"}],"key":"c5E4Vmei9i"},{"type":"text","value":".","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"Qx04rIAbcW"}],"key":"toFFZCi4Ew"}],"key":"B0lXUM8o99"},{"type":"listItem","spread":true,"position":{"start":{"line":685,"column":1},"end":{"line":686,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"children":[{"type":"text","value":"Parallel sort of very large lists:","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"rN3yyf4DIK"}],"key":"ilAa4ENXCX"},{"type":"text","value":" ","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"PgzGOfm4Bv"},{"type":"strong","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"t6OQv80VHQ"}],"key":"MiP4aqRbQD"},{"type":"text","value":" lends itself to parallelizing the two halves.","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"ThJ8QfoNog"}],"key":"JSKa08JSfx"}],"key":"lz0TlM8DRi"}],"key":"hL7nGECzAG"},{"type":"heading","depth":4,"position":{"start":{"line":687,"column":1},"end":{"line":687,"column":1}},"children":[{"type":"text","value":"Practical checklist","position":{"start":{"line":687,"column":1},"end":{"line":687,"column":1}},"key":"fc0NBh3frt"}],"identifier":"practical-checklist","label":"Practical checklist","html_id":"practical-checklist","implicit":true,"key":"Wb4UrS8h9x"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":689,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Need simple code? → ","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"key":"NAMNXsoA5u"},{"type":"strong","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"key":"Xltb21VhnK"}],"key":"ZscCSK4qPl"},{"type":"text","value":".","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"key":"IfWMnhPu8M"}],"key":"W9p3u3xol9"}],"key":"imr7o3zSGH"},{"type":"listItem","spread":true,"position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Worried about stack or sorting millions of nodes? → ","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"zPOyUHOz17"},{"type":"strong","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"text","value":"Iterative","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"Re3DmmRh5B"}],"key":"QctlcedOGx"},{"type":"text","value":".","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"PUEINQj35F"}],"key":"wgmnalgZBZ"}],"key":"ipZHtoNjvz"}],"key":"PlR3xsTuO3"}],"key":"yXgjqH6DwZ"}],"key":"vgjCJiOT0S"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Merge Sort","url":"/xmergesort","group":"CSCI 132"},"next":{"title":"Quick Sort","url":"/xquicksort","group":"CSCI 132"}}},"domain":"http://localhost:3002"},"project":{"date":"2025-12-04","exports":[],"title":"JAVA and Basic Algorithms","short_title":"CSCI 132","description":"Course material for CSCI 132","authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_bdbook\\myst-generated-uid-0"}],"keywords":["JAVA","Algorithms"],"id":"70435226-f2e9-4585-b1e5-763a843f2399","toc":[{"file":"index.md"},{"file":"xDataStructuresAndAlgorithms.md"},{"children":[{"file":"xArraysCoreFunctionality.md"},{"file":"xArrayWarpAround.md"},{"file":"xArrayAddDeleteData.md"}],"file":"xArrayTechniques.md"},{"file":"xEncapsulationNonEncapsulation.md"},{"children":[{"file":"xON_VisualizingBigONotation.md"},{"file":"xBigONotationExplained.md"}],"file":"xBigONotation.md"},{"children":[{"file":"xSinglyLinkedListRev3.md"},{"file":"xDoublyLinkedList.md"},{"file":"xDoublyLinkedListSubClass.md"},{"file":"xCircularLinkedList.md"},{"file":"xDoublyLinkedListReadDataIntoLL.md"},{"file":"xDoublyLinkedListCSharp.md"},{"file":"xDoublyLinkedListJava.md"}],"file":"xLinkedLists.md"},{"children":[{"file":"xStackUsingArrayOfObjects.md"},{"file":"xQueueUsingArrayOfObjects.md"},{"file":"xPriorityQueue.md"}],"file":"xStacksAndQueues.md"},{"children":[{"file":"xSort_Bubble.md"},{"file":"xbucketsort.md"},{"file":"xMergeSort.md"},{"file":"xMergeSort_revA.md"},{"file":"xQuickSort.md"},{"file":"xQuicksortDemo.md"},{"file":"xQuicksortLinkedLists.md"},{"file":"xSort_HeapSort.md"},{"file":"xUnderstandingQuickMergeHeap.md"},{"file":"xSortingVideosVisualizers.md"},{"file":"xend.md"}],"file":"xSortAlgorithms.md"}],"bibliography":[],"index":"index","pages":[{"slug":"xdatastructuresandalgorithms","title":"Data Structures and Algorithms","description":"","date":"2025-12-04","thumbnail":"/csci132/build/c798a09d2ea7aaf43821d8d632896091.jpeg","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xarraytechniques","title":"Array Techniques","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xarrayscorefunctionality","title":"Arrays Core Functionality","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xarraywarparound","title":"Array Warp Around","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xarrayadddeletedata","title":"Array Add and Delete Data","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xencapsulationnonencapsulation","title":"Encapsulation vs Non-Encapsulation","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xbigonotation","title":"Big O Notation","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xon-visualizingbigonotation","title":"Visualizing Big O notation","description":"","date":"2025-12-04","thumbnail":"/csci132/build/vbon_image_O1-9b81a61817a64d078f43a349fd16f04b.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbigonotationexplained","title":"Big O Notation - Explained","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xlinkedlists","title":"Linked Lists","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xsinglylinkedlistrev3","title":"Singly Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlist","title":"Doubly Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistsubclass","title":"Doubly Linked List - Links as Sub Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xcircularlinkedlist","title":"Circular Linked List - Links as Sub Class","description":"","date":"2025-12-04","thumbnail":"/csci132/build/CircularLinkList-c844fefbdf30018d464995a97d1c7c8d.png","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistreaddataintoll","title":"Reading Datafile Into Linked List","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistcsharp","title":"C# Linked List Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xdoublylinkedlistjava","title":"Java Linked List Class","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xstacksandqueues","title":"Stacks and Queues","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xstackusingarrayofobjects","title":"Stack  - Using Array of Objects","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xqueueusingarrayofobjects","title":"Queue  - Using Array Of Objects","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xpriorityqueue","title":"Priority Queue","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsortalgorithms","title":"Sorting Algorithms","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":1},{"slug":"xsort-bubble","title":"Bubble Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xbucketsort","title":"Bucket Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xmergesort","title":"Merge Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xmergesort-reva","title":"Merge Sort - Demo Code","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksort","title":"Quick Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksortdemo","title":"Quicksort Demo","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xquicksortlinkedlists","title":"Quicksort - Linked Lists","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsort-heapsort","title":"Heap Sort","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xunderstandingquickmergeheap","title":"Understanding Three Quick, Merge, and Heap Sort Algorithms","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xsortingvideosvisualizers","title":"Sorting Videos and Visualizers","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2},{"slug":"xend","title":"End Of Section","description":"","date":"2025-12-04","thumbnail":"","thumbnailOptimized":"","banner":"","bannerOptimized":"","tags":[],"level":2}]}}},"actionData":null,"errors":null},"future":{"unstable_dev":false,"unstable_postcss":false,"unstable_tailwind":false,"v2_errorBoundary":true,"v2_headers":true,"v2_meta":true,"v2_normalizeFormMethod":true,"v2_routeConvention":true}};</script><script type="module" async="">import "/csci132/build/manifest-5D5D9E8C.js";
import * as route0 from "/csci132/build/root-AA24SA6C.js";
import * as route1 from "/csci132/build/routes/$-5SFLQWPV.js";
window.__remixRouteModules = {"root":route0,"routes/$":route1};

import("/csci132/build/entry.client-PCJPW7TK.js");</script></body></html>