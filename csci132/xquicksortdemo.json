{"version":2,"kind":"Article","sha256":"9b4c23a75635ccfb0b5372c8437b548a83438bfa4e5e73b3ba25a6eb003630e4","slug":"xquicksortdemo","location":"/xQuicksortDemo.md","dependencies":[],"frontmatter":{"title":"Quicksort Demo","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_bdbook\\myst-generated-uid-0"}],"date":"2025-12-04","keywords":["JAVA","Algorithms"],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xQuicksortDemo.md","url":"/csci132/build/xQuicksortDemo-3c89e54bb63142496f46dd95cfec2baf.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":2,"position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"How QuickSort Works (Recursive Version)","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"TGubRqFfFn"}],"key":"zH8Xkfi44w"}],"identifier":"how-quicksort-works-recursive-version","label":"How QuickSort Works (Recursive Version)","html_id":"how-quicksort-works-recursive-version","implicit":true,"key":"xY18rC9qbi"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"QuickSort is a ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"TxJbrWBbvI"},{"type":"emphasis","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"divide-and-conquer","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"SMFhShmzTz"}],"key":"FwZJ0VXOrf"},{"type":"text","value":" sorting algorithm. The recursive version works like a rhythm of splitting and sorting:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"xZaZn0Jjml"}],"key":"ZM5TrztmHx"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":9,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Pick a pivot","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"i31tq47gXH"}],"key":"WpdMPFuCJS"},{"type":"text","value":" — usually the last element.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"ShmLZmquN0"}],"key":"JJnTRdV9MI"}],"key":"HOipCywsis"},{"type":"listItem","spread":true,"position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Partition the array","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"jMGy8FXdL8"}],"key":"VPujKiMsej"},{"type":"text","value":" — move all smaller values to the left side, larger values to the right.","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"GKrhcy1Jm7"}],"key":"IIoQ5lS3Ro"}],"key":"lAZUxSPoMn"},{"type":"listItem","spread":true,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Recursively sort the two halves","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"WKY8U71RUg"}],"key":"IyYUBx7oHr"},{"type":"text","value":" — QuickSort calls itself on the left subarray, then on the right.","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"QKcmBT8yjI"}],"key":"Faq39WXny3"}],"key":"Zt3Vd0pomE"},{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Base case","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"RoQZKyc4Mv"}],"key":"XX6q538m3m"},{"type":"text","value":" — when a segment has 0 or 1 elements, it’s already sorted.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"KC6lBNbhsH"}],"key":"bhOfLNZnaa"}],"key":"GNeZM1UEto"}],"key":"MdiguGcGxN"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"The recursion naturally creates a call stack, breaking the array into smaller problems until each tiny piece is sorted. When the calls unwind, the entire array emerges in order.","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"E3nleI3m0F"}],"key":"SbGyHAEwop"},{"type":"thematicBreak","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"ZYl08Fd4v3"},{"type":"heading","depth":2,"position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"How QuickSort Works (Iterative Version)","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"zjZ8jqRnNN"}],"key":"S3p7lDwyYP"}],"identifier":"how-quicksort-works-iterative-version","label":"How QuickSort Works (Iterative Version)","html_id":"how-quicksort-works-iterative-version","implicit":true,"key":"Q2XBy6OrZ4"},{"type":"paragraph","position":{"start":{"line":20,"column":1},"end":{"line":21,"column":1}},"children":[{"type":"text","value":"The iterative version works the same way conceptually, but ","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"zqf8cDxdz0"},{"type":"emphasis","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"no recursion","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"me49zGxXye"}],"key":"Typo5HeQCq"},{"type":"text","value":" is used.\nInstead of letting the call stack manage sub-problems, we manage it ourselves:","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"UkqNXjRpIf"}],"key":"eakNpKQbOE"},{"type":"list","ordered":true,"start":1,"spread":false,"position":{"start":{"line":23,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"children":[{"type":"text","value":"Use an explicit stack (an array)","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"HTqR3mITae"}],"key":"OibHFeGGI2"},{"type":"text","value":" to store the index ranges that still need sorting.","position":{"start":{"line":23,"column":1},"end":{"line":23,"column":1}},"key":"yhPGC17NyH"}],"key":"dEZ3uXSjsV"}],"key":"HLAuSlldvz"},{"type":"listItem","spread":true,"position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"children":[{"type":"text","value":"Push the initial full array range","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"bopKMWnmeD"}],"key":"eSc1ElV1T0"},{"type":"text","value":" onto the stack.","position":{"start":{"line":24,"column":1},"end":{"line":24,"column":1}},"key":"ECLjF4USNx"}],"key":"pvlKT6jCCw"}],"key":"Ikt6UdHMEK"},{"type":"listItem","spread":true,"position":{"start":{"line":25,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"children":[{"type":"text","value":"Loop","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"CRzmghTjt5"}],"key":"Esiy1WeoS5"},{"type":"text","value":" while the stack isn’t empty:","position":{"start":{"line":25,"column":1},"end":{"line":25,"column":1}},"key":"z35ETGgmdv"}],"key":"kzp1ZxMajS"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":26,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Pop a range off the stack.","position":{"start":{"line":26,"column":1},"end":{"line":26,"column":1}},"key":"Ckddgth8TF"}],"key":"b8Xmf6uc5j"}],"key":"hfCi2YxIaq"},{"type":"listItem","spread":true,"position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Partition that section around a pivot.","position":{"start":{"line":27,"column":1},"end":{"line":27,"column":1}},"key":"uOPKIW6jK0"}],"key":"DcrG2xWwnz"}],"key":"TmBuqjbolO"},{"type":"listItem","spread":true,"position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Push the left and right sub-ranges back onto the stack (if they exist).","position":{"start":{"line":28,"column":1},"end":{"line":28,"column":1}},"key":"GVMguQKTD3"}],"key":"eNubKYayFt"}],"key":"mmmBl22k1A"}],"key":"qFuylLaNmD"}],"key":"LPzdKgwfbm"},{"type":"listItem","spread":true,"position":{"start":{"line":29,"column":1},"end":{"line":30,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Continue until no unsorted sections remain.","position":{"start":{"line":29,"column":1},"end":{"line":29,"column":1}},"key":"feXywvDLwr"}],"key":"nzIeXxbpZp"}],"key":"dLJ6SY2Hs2"}],"key":"mMVm5i73eQ"},{"type":"paragraph","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"children":[{"type":"text","value":"This version exposes what recursion does behind the scenes. It sorts the same way—just with loops and a manually managed stack.","position":{"start":{"line":31,"column":1},"end":{"line":31,"column":1}},"key":"ppUvO1TEh0"}],"key":"W6HmidB60F"},{"type":"code","lang":"java","value":"/*\nDeveloper James Goudy\n */\npackage quicksort_demo;\n\n\ninterface SortingAlgorithm {\n\n    // Method to sort the array in-place\n    void sort(int[] arr);\n\n}\n\n\n// -------------------------------------------------------------\n// QuickSort.java\n// A simple, teaching-friendly implementation of QuickSort.\n// This class contains ONLY the QuickSort logic.\n//\n// How it works\n// - QuickSort is a \"divide and conquer\" sorting algorithm.\n// - We pick a pivot, split the array into smaller/larger parts,\n//   then recursively sort each part.\n// - This version is NOT optimized. It's intentionally simple.\n// -------------------------------------------------------------\n\nclass QuickSort implements SortingAlgorithm {\n\n    @Override\n    public void sort(int[] arr) {\n        quickSort(arr, 0, arr.length - 1);\n    }\n    // Internal recursive method that performs the sorting\n    private static void quickSort(int[] arr, int low, int high)\n    {\n        if (low < high) {\n            // Partition the array and get the pivot index\n            int pivotIndex = partition(arr, low, high);\n\n            // Recursively sort the left side\n            quickSort(arr, low, pivotIndex - 1);\n\n            // Recursively sort the right side\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n\n    // ---------------------------------------------------------\n    // partition()\n    // This function:\n    //   • chooses a pivot (here we use the last element)\n    //   • rearranges elements so smaller values go left,\n    //     larger values go right\n    //   • returns the final position of the pivot\n    // ---------------------------------------------------------\n    private static int partition(int[] arr, int low, int high)\n    {\n        int pivot = arr[high]; // choose pivot\n        int i = low - 1;       // index of smaller element\n\n        // Move through the array and swap values as needed\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n\n                // swap arr[i] and arr[j]\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        // Move pivot to the correct location\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1; // return pivot position\n    }\n}\n// --------------------------------------------------------------\n\n// -------------------------------------------------------------\n// QuickSortIterative.java\n// A simple, teaching-friendly **iterative** QuickSort.\n// This version uses loops instead of recursion by manually\n// managing our own \"stack\" of sub-array ranges.\n//\n// -------------------------------------------------------------\n\nclass QuickSortIterative implements SortingAlgorithm {\n\n    @Override\n    public void sort(int[] arr) {\n        quickSort(arr);\n    }\n\n    // Iterative quicksort using manual stack\n    private static void quickSort(int[] arr) {\n        int low = 0;\n        int high = arr.length - 1;\n\n        // -----------------------------------------------------\n        // Our manual stack will hold pairs of (low, high) index\n        // ranges that still need to be processed.\n        // -----------------------------------------------------\n        int[] stack = new int[high - low + 1];\n\n        int top = -1;\n\n        // Push initial range onto stack\n        stack[++top] = low;\n        stack[++top] = high;\n\n        // -----------------------------------------------------\n        // Keep looping while we have ranges to process\n        // -----------------------------------------------------\n        while (top >= 0) {\n\n            // Pop the high and low indexes for the next segment\n            high = stack[top--];\n            low = stack[top--];\n\n            // Partition this segment\n            int pivotIndex = partition(arr, low, high);\n\n            // -------------------------------------------------\n            // PUSH RIGHT SIDE (if it exists)\n            // -------------------------------------------------\n            if (pivotIndex + 1 < high) {\n                stack[++top] = pivotIndex + 1;\n                stack[++top] = high;\n            }\n\n            // -------------------------------------------------\n            // PUSH LEFT SIDE (if it exists)\n            // -------------------------------------------------\n            if (pivotIndex - 1 > low) {\n                stack[++top] = low;\n                stack[++top] = pivotIndex - 1;\n            }\n        }\n    }\n\n    // ---------------------------------------------------------\n    // partition()\n    // Same idea as recursive QuickSort:\n    //   - Pick last element as pivot\n    //   - Move all smaller elements to the left\n    //   - Move pivot to its correct position\n    // ---------------------------------------------------------\n    private static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n\n        // Scan through and swap as necessary\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n\n                // Swap arr[i] and arr[j]\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        // Move pivot into correct place\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1;\n    }\n}\n\n\n// --------------------------------------------------------------\n\npublic class QuickSort_Demo {\n    \n    static SortingAlgorithm sa;\n    \n    \n  \n\n    // Utility method to print an array\n    public static void printArray(int[] arr)\n    {\n        for (int num : arr) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        \n          int choice = 2;\n    \n        if (choice == 1) {\n            sa = new QuickSort();\n        } else {\n            sa = new QuickSortIterative();\n        }\n        \n        int[] data = {34, 7, 23, 32, 5, 62};\n\n        System.out.println(\"Original Array:\");\n        printArray(data);\n\n        // Call the QuickSort class\n        sa.sort(data);\n\n        System.out.println(\"\\nSorted Array:\");\n        printArray(data);\n    }\n\n}\n","position":{"start":{"line":35,"column":1},"end":{"line":256,"column":1}},"key":"eTtcDAYqvt"}],"key":"p4Bs0QVwj1"}],"key":"Ay98txluQW"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Quick Sort","url":"/xquicksort","group":"CSCI 132"},"next":{"title":"Quicksort - Linked Lists","url":"/xquicksortlinkedlists","group":"CSCI 132"}}},"domain":"http://localhost:3002"}