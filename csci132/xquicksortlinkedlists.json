{"version":2,"kind":"Article","sha256":"3669d7c6e96d078f26d24a2235adc8c8d2a7deab07984895a1972b13c0727e29","slug":"xquicksortlinkedlists","location":"/xQuicksortLinkedLists.md","dependencies":[],"frontmatter":{"title":"Quicksort - Linked Lists","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_bdbook\\myst-generated-uid-0"}],"date":"2025-12-04","keywords":["JAVA","Algorithms"],"numbering":{"title":{"offset":1}},"exports":[{"format":"md","filename":"xQuicksortLinkedLists.md","url":"/csci132/build/xQuicksortLinkedList-7e0b3dd847f33c46f9b81eb5a4ece2b5.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Annotated","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"gwPIBfRfps"}],"key":"iaaIevgHjW"},{"type":"code","lang":"java","value":"/*\n * Quick Sort using Linked Lists\n * By James Goudy\n *\n * This program shows TWO different versions of QuickSort\n * for a singly linked list:\n *   1) A recursive version\n *   2) An iterative (loop-based) version that uses a Stack\n *\n * In main(), you can choose which version to run.\n */\n\npackage inst_quicksort_linklists;\n\nimport java.util.Stack;\n\n// -----------------------------------------------------\n// SortingAlgorithm interface\n// -----------------------------------------------------\n// An interface is like a \"contract\" that says:\n// \"Any class that implements me MUST have this method.\"\n// Here, any sorting class must have a quickSort() method\n// that takes the head of a linked list and returns\n// the (new) head of the sorted list.\n// -----------------------------------------------------\ninterface SortingAlgorithm {\n\n    Node quickSort(Node head);\n}\n\n// -----------------------------------------------------\n// Node class: a simple node for a singly linked list\n// -----------------------------------------------------\n// Each Node holds one integer (data) and a reference\n// (pointer) to the next Node in the list.\n// If next == null, this is the last node in the list.\n// -----------------------------------------------------\nclass Node {\n\n    int data;   // the value stored in this node\n    Node next;  // reference to the next node in the list\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// -----------------------------------------------------\n// RecursiveQuickSortLinkedList\n// -----------------------------------------------------\n// This class uses a RECURSIVE version of QuickSort.\n//\n// Basic idea of QuickSort on a linked list:\n// 1) Choose a pivot (here: the first node).\n// 2) Split the list into:\n//    - nodes with values LESS than the pivot\n//    - nodes with values GREATER or EQUAL to the pivot\n// 3) Recursively sort the two smaller lists.\n// 4) Connect: less list + pivot + greater list\n// -----------------------------------------------------\nclass RecursiveQuickSortLinkedList implements SortingAlgorithm {\n\n    // Entry point for recursive QuickSort\n    public Node quickSort(Node head)\n    {\n        // Base Case:\n        // If the list is empty (head == null)\n        // OR has only one element (head.next == null),\n        // then it is already sorted.\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // Use the first node as the pivot\n        Node pivot = head;\n\n        // These will be the heads and tails of two new lists:\n        //  - less: nodes with data < pivot.data\n        //  - greater: nodes with data >= pivot.data\n        Node lessHead = null, lessTail = null;\n        Node greaterHead = null, greaterTail = null;\n\n        // Start from the node after the pivot\n        Node current = head.next;\n\n        // -------------------------------------------------\n        // Partition loop:\n        // Walk through the list, and put each node into\n        // either the \"less\" list or the \"greater\" list.\n        // -------------------------------------------------\n        while (current != null) {\n            if (current.data < pivot.data) {\n                // Goes into the \"less\" list\n                if (lessHead == null) {\n                    // First node in the less list\n                    lessHead = lessTail = current;\n                } else {\n                    // Append to the end of the less list\n                    lessTail.next = current;\n                    lessTail = current;\n                }\n            } else {\n                // Goes into the \"greater\" list\n                if (greaterHead == null) {\n                    // First node in the greater list\n                    greaterHead = greaterTail = current;\n                } else {\n                    // Append to the end of the greater list\n                    greaterTail.next = current;\n                    greaterTail = current;\n                }\n            }\n            // Move to the next node in the original list\n            current = current.next;\n        }\n\n        // -------------------------------------------------\n        // Important cleanup step:\n        // Make sure the less and greater lists have\n        // proper endings (tails point to null).\n        // This helps prevent accidental \"cycles\" in the list.\n        // -------------------------------------------------\n        if (lessTail != null) {\n            lessTail.next = null;\n        }\n        if (greaterTail != null) {\n            greaterTail.next = null;\n        }\n\n        // Recursively sort the two sublists:\n        //  - lessHead: all nodes < pivot\n        //  - greaterHead: all nodes >= pivot\n        lessHead = quickSort(lessHead);\n        greaterHead = quickSort(greaterHead);\n\n        // Finally, stitch everything together:\n        // less list + pivot + greater list\n        return concatenate(lessHead, pivot, greaterHead);\n    }\n\n    // -----------------------------------------------------\n    // concatenate()\n    // -----------------------------------------------------\n    // This helper method connects three pieces:\n    // 1) less list (may be null)\n    // 2) the pivot node (single node)\n    // 3) greater list (may be null)\n    //\n    // Returns the head of the new combined list.\n    // -----------------------------------------------------\n    private Node concatenate(Node less, Node pivot, Node greater)\n    {\n        // Pivot should point to the start of the greater list\n        pivot.next = greater;\n\n        // If there is no \"less\" list, pivot is the new head\n        if (less == null) {\n            return pivot;\n        }\n\n        // Otherwise, walk to the end of the less list\n        Node current = less;\n        while (current.next != null) {\n            current = current.next;\n        }\n\n        // Attach pivot (and greater) to the end of less\n        current.next = pivot;\n\n        // The head of the combined list is still \"less\"\n        return less;\n    }\n\n    // -----------------------------------------------------\n    // printList()\n    // -----------------------------------------------------\n    // Utility method to print the linked list in a friendly\n    // format like: 8 -> 3 -> 7 -> null\n    // -----------------------------------------------------\n    public void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n// ---------------------------------------------------------\n// IterativeQuickSortLinkedList\n// ---------------------------------------------------------\n// This class uses an ITERATIVE version of QuickSort.\n// Instead of using recursion, we use a Stack to keep\n// track of which part (range) of the list we still\n// need to process.\n// ---------------------------------------------------------\nclass IterativeQuickSortLinkedList implements SortingAlgorithm {\n\n    // -----------------------------------------------------\n    // Range class:\n    // A small helper class that stores a \"sub-list\" using\n    // two pointers:\n    //   start: first node in the range\n    //   end:   one past the last node (EXCLUSIVE)\n    //\n    // The range is [start, end), meaning:\n    //   start is included, end is NOT included.\n    // -----------------------------------------------------\n    private static class Range {\n        Node start, end; // end is EXCLUSIVE\n        Range(Node s, Node e) {\n            start = s;\n            end   = e;\n        }\n    }\n\n    @Override\n    public Node quickSort(Node head) {\n\n        // Base case: empty or single-node list is already sorted\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // -------------------------------------------------\n        // Use a Stack to store the ranges we need to sort.\n        // We start with the entire list: [head, null)\n        // (null means \"go all the way to the end\").\n        // -------------------------------------------------\n        Stack<Range> stack = new Stack<>();\n        stack.push(new Range(head, null)); // whole list: [head, null)\n\n        // -------------------------------------------------\n        // While there are still ranges to process\n        // -------------------------------------------------\n        while (!stack.isEmpty()) {\n            Range r = stack.pop();\n            Node start = r.start;\n            Node end   = r.end;\n\n            // If the range has 0 or 1 elements, it is already sorted.\n            // Conditions:\n            //  - start == null: empty\n            //  - start == end: empty\n            //  - start.next == end: exactly one element\n            if (start == null || start == end || start.next == end) {\n                continue;\n            }\n\n            // ---- Partition [start, end) around pivot = start ----\n            Node pivot = start;\n            Node lessH = null, lessT = null;        // \"less than pivot\" list\n            Node greaterH = null, greaterT = null;  // \"greater or equal\" list\n\n            // Start from the node after the pivot\n            Node curr = pivot.next;\n\n            // Walk through the range [pivot.next, end)\n            while (curr != end) {\n                Node next = curr.next; // Save next node before re-linking\n\n                if (curr.data < pivot.data) {\n                    // Goes in the \"less\" list\n                    if (lessH == null) {\n                        lessH = lessT = curr;\n                    } else {\n                        lessT.next = curr;\n                        lessT = curr;\n                    }\n                } else {\n                    // Goes in the \"greater or equal\" list\n                    if (greaterH == null) {\n                        greaterH = greaterT = curr;\n                    } else {\n                        greaterT.next = curr;\n                        greaterT = curr;\n                    }\n                }\n\n                // Move to the next node in the original range\n                curr = next;\n            }\n\n            // ---- Re-link the nodes in sorted order within this range ----\n            // We want: less list -> pivot -> greater list -> end\n\n            // Attach pivot AFTER less list (if it exists)\n            if (lessT != null) {\n                lessT.next = pivot;\n            }\n\n            // Pivot should point to the start of the greater list\n            pivot.next = greaterH;\n\n            // If there is a greater list, its tail should point to end\n            if (greaterT != null) {\n                greaterT.next = end;\n            } else {\n                // No greater list: pivot should point directly to end\n                pivot.next = end;\n            }\n\n            // newStart is the first node in this now-partially-sorted range\n            Node newStart = (lessH != null) ? lessH : pivot;\n\n            // ---- Fix list head or previous pointer ----\n            // If this range started at the overall head of the list,\n            // then we need to update the head.\n            if (start == head) {\n                head = newStart;\n            } else {\n                // Otherwise, find the node whose next was 'start'\n                // and make it point to newStart.\n                Node prev = head;\n                while (prev != null && prev.next != start) {\n                    prev = prev.next;\n                }\n                if (prev != null) {\n                    prev.next = newStart;\n                }\n            }\n\n            // ---- Push the two new subranges onto the stack ----\n            // Right subrange: [pivot.next, end)\n            if (pivot.next != null && pivot.next != end) {\n                stack.push(new Range(pivot.next, end));\n            }\n\n            // Left subrange: [newStart, pivot)\n            if (newStart != pivot) {\n                stack.push(new Range(newStart, pivot));\n            }\n        }\n\n        // When the stack is empty, everything is sorted\n        return head;\n    }\n\n    // Utility: print list (same idea as above)\n    public void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n// ---------------------------------------------------------\n// Inst_quicksort_linklists (Main Class)\n// ---------------------------------------------------------\n// This is the class with the main() method.\n// It builds a sample linked list, lets you choose which\n// QuickSort version to use (recursive or iterative),\n// and then prints the original and sorted lists.\n// ---------------------------------------------------------\npublic class Inst_quicksort_linklists {\n\n    // -----------------------------------------------------\n    // Helper: buildList()\n    // -----------------------------------------------------\n    // Takes a regular int[] array and builds a linked list\n    // with the same values in the same order.\n    // Returns the head of that new linked list.\n    // -----------------------------------------------------\n    private static Node buildList(int[] arr)\n    {\n        if (arr.length == 0) {\n            return null;\n        }\n\n        // First node becomes the head\n        Node head = new Node(arr[0]);\n        Node curr = head;\n\n        // Attach the rest of the nodes\n        for (int i = 1; i < arr.length; i++) {\n            curr.next = new Node(arr[i]);\n            curr = curr.next;\n        }\n\n        return head;\n    }\n\n    // -----------------------------------------------------\n    // Helper: printList()\n    // -----------------------------------------------------\n    // Another simple print method for convenience.\n    // -----------------------------------------------------\n    private static void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args)\n    {\n        // Sample data to be sorted\n        int[] data = {8, 3, 7, 1, 9, 2, 6, 5};\n\n        // --------------------------------------------------\n        // CHOICE VARIABLE\n        // --------------------------------------------------\n        // 1 = use the RECURSIVE QuickSort\n        // any other value = use the ITERATIVE QuickSort\n        //\n        // Try changing this to 1 and 2 and see how both\n        // versions behave with the same data.\n        // --------------------------------------------------\n        int choice = 10;     // <<< change this to 1 for recursive, 2 for iterative\n\n        SortingAlgorithm sorter;\n\n        // Decide which sorting algorithm to use\n        if (choice == 1) {\n            System.out.println(\"Running Recursive QuickSort...\");\n            sorter = new RecursiveQuickSortLinkedList();\n        } else {\n            System.out.println(\"Running Iterative QuickSort...\");\n            sorter = new IterativeQuickSortLinkedList();\n        }\n\n        // Build the original linked list from the array\n        Node list = buildList(data);\n\n        System.out.println(\"Original List:\");\n        printList(list);\n\n        // Sort the list using the selected algorithm\n        Node sorted = sorter.quickSort(list);\n\n        System.out.println(\"\\nSorted List:\");\n        printList(sorted);\n    }\n\n}\n","position":{"start":{"line":5,"column":1},"end":{"line":449,"column":1}},"key":"DFeoVMLSTc"},{"type":"paragraph","position":{"start":{"line":455,"column":1},"end":{"line":455,"column":1}},"children":[{"type":"text","value":"Non Annotated","position":{"start":{"line":455,"column":1},"end":{"line":455,"column":1}},"key":"XwDaL3CVjt"}],"key":"rHRS9eGjj4"},{"type":"code","lang":"java","value":"/*\n\nQuick Sort using Linked Lists\nBy James Goudy\n\n */\npackage inst_quicksort_linklists;\n\nimport java.util.Stack;\n\ninterface SortingAlgorithm {\n\n    Node quickSort(Node head);\n}\n\n// Simple node for a singly linked list\nclass Node {\n\n    int data;\n    Node next;\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nclass RecursiveQuickSortLinkedList implements SortingAlgorithm {\n\n    // QuickSort Entry Point\n    public Node quickSort(Node head)\n    {\n        // Base Case\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // Partition using head as pivot\n        Node pivot = head;\n        Node lessHead = null, lessTail = null;\n        Node greaterHead = null, greaterTail = null;\n\n        Node current = head.next;\n\n        while (current != null) {\n            if (current.data < pivot.data) {\n                if (lessHead == null) {\n                    lessHead = lessTail = current;\n                } else {\n                    lessTail.next = current;\n                    lessTail = current;\n                }\n            } else {\n                if (greaterHead == null) {\n                    greaterHead = greaterTail = current;\n                } else {\n                    greaterTail.next = current;\n                    greaterTail = current;\n                }\n            }\n            current = current.next;\n        }\n\n        // Prevent accidental list cycles\n        if (lessTail != null) {\n            lessTail.next = null;\n        }\n        if (greaterTail != null) {\n            greaterTail.next = null;\n        }\n\n        // Recursively sort sublists\n        lessHead = quickSort(lessHead);\n        greaterHead = quickSort(greaterHead);\n\n        // Stitch together: less + pivot + greater\n        return concatenate(lessHead, pivot, greaterHead);\n    }\n\n    // Helper: combine lists\n    private Node concatenate(Node less, Node pivot, Node greater)\n    {\n        pivot.next = greater;\n\n        if (less == null) {\n            return pivot;\n        }\n\n        Node current = less;\n        while (current.next != null) {\n            current = current.next;\n        }\n        current.next = pivot;\n\n        return less;\n    }\n\n    // Utility: print list\n    public void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n\nclass IterativeQuickSortLinkedList implements SortingAlgorithm {\n\n    private static class Range {\n        Node start, end; // end is EXCLUSIVE\n        Range(Node s, Node e) {\n            start = s;\n            end   = e;\n        }\n    }\n\n    @Override\n    public Node quickSort(Node head) {\n\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Stack<Range> stack = new Stack<>();\n        stack.push(new Range(head, null)); // whole list: [head, null)\n\n        while (!stack.isEmpty()) {\n            Range r = stack.pop();\n            Node start = r.start;\n            Node end   = r.end;\n\n            // 0 or 1 element in this range\n            if (start == null || start == end || start.next == end) {\n                continue;\n            }\n\n            // ---- Partition [start, end) around pivot = start ----\n            Node pivot = start;\n            Node lessH = null, lessT = null;\n            Node greaterH = null, greaterT = null;\n\n            Node curr = pivot.next;\n\n            while (curr != end) {\n                Node next = curr.next; // save before re-linking\n\n                if (curr.data < pivot.data) {\n                    if (lessH == null) {\n                        lessH = lessT = curr;\n                    } else {\n                        lessT.next = curr;\n                        lessT = curr;\n                    }\n                } else {\n                    if (greaterH == null) {\n                        greaterH = greaterT = curr;\n                    } else {\n                        greaterT.next = curr;\n                        greaterT = curr;\n                    }\n                }\n                curr = next;\n            }\n\n            // ---- Re-link: less -> pivot -> greater -> end ----\n            if (lessT != null) {\n                lessT.next = pivot;\n            }\n            pivot.next = greaterH;\n            if (greaterT != null) {\n                greaterT.next = end;\n            } else {\n                // no greater list\n                pivot.next = end;\n            }\n\n            Node newStart = (lessH != null) ? lessH : pivot;\n\n            // ---- Fix list head or previous pointer ----\n            if (start == head) {\n                head = newStart;\n            } else {\n                // find node whose next was 'start' and re-point it\n                Node prev = head;\n                while (prev != null && prev.next != start) {\n                    prev = prev.next;\n                }\n                if (prev != null) {\n                    prev.next = newStart;\n                }\n            }\n\n            // ---- Push subranges: right then left ----\n            // Right: [pivot.next, end)\n            if (pivot.next != null && pivot.next != end) {\n                stack.push(new Range(pivot.next, end));\n            }\n            // Left: [newStart, pivot)\n            if (newStart != pivot) {\n                stack.push(new Range(newStart, pivot));\n            }\n        }\n\n        return head;\n    }\n\n    // Utility: print list\n    public void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n\n\npublic class Inst_quicksort_linklists {\n\n    // Helper: build a linked list from an array\n    private static Node buildList(int[] arr)\n    {\n        if (arr.length == 0) {\n            return null;\n        }\n        Node head = new Node(arr[0]);\n        Node curr = head;\n        for (int i = 1; i < arr.length; i++) {\n            curr.next = new Node(arr[i]);\n            curr = curr.next;\n        }\n        return head;\n    }\n\n    // Helper: print list\n    private static void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args)\n    {\n        int[] data = {8, 3, 7, 1, 9, 2, 6, 5};\n\n        // ------------------------------------------------------\n        // CHOICE VARIABLE\n        // 1 = recursive quicksort\n        // 2 = iterative quicksort\n        // ------------------------------------------------------\n        int choice = 10;     // <<< change this to 2 for iterative\n\n        SortingAlgorithm sorter;\n\n        if (choice == 1) {\n            System.out.println(\"Running Recursive QuickSort...\");\n            sorter = new RecursiveQuickSortLinkedList();\n        } else {\n            System.out.println(\"Running Iterative QuickSort...\");\n            sorter = new IterativeQuickSortLinkedList();\n        }\n\n        // Build original list\n        Node list = buildList(data);\n\n        System.out.println(\"Original List:\");\n        printList(list);\n\n        // Sort using selected algorithm\n        Node sorted = sorter.quickSort(list);\n\n        System.out.println(\"\\nSorted List:\");\n        printList(sorted);\n    }\n\n}\n","position":{"start":{"line":457,"column":1},"end":{"line":743,"column":1}},"key":"S4wYQvojic"}],"key":"HVpoy7Xf17"}],"key":"eyd0gPhzoZ"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Quicksort Demo","url":"/xquicksortdemo","group":"CSCI 132"},"next":{"title":"Heap Sort","url":"/xsort-heapsort","group":"CSCI 132"}}},"domain":"http://localhost:3002"}