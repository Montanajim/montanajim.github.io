{"version":2,"kind":"Article","sha256":"9e386581b58bab0e077a33e71eb63aa88fba7cb23a0cc93a4a130dcba262490d","slug":"mergesort-reva","location":"/basicalgo/MergeSort_revA.md","dependencies":[],"frontmatter":{"title":"Merge Sort - Demo Code","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_basicalgo\\the_bdbook\\myst-generated-uid-0"}],"copyright":"2025","numbering":{"title":{"offset":2}},"exports":[{"format":"md","filename":"MergeSort_revA.md","url":"/csci132//build/MergeSort_revA-29b5c46edaa262cb447448db1cadb4af.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"heading","depth":3,"position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"strong","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"How Merge Sort Works","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"tDFYasfQc5"}],"key":"JoC5InOkQy"}],"identifier":"how-merge-sort-works","label":"How Merge Sort Works","html_id":"how-merge-sort-works","implicit":true,"key":"oiDMwTz9Zd"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Merge sort is a ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"aejWIoGJp8"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"divide-and-conquer","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"X3FY53MzlT"}],"key":"KJhOzl0Byu"},{"type":"text","value":" sorting algorithm. It recursively divides the array into two halves until each subarray has only one element (which is trivially sorted). Then it ","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"KGZgflZiT0"},{"type":"strong","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"merges","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"hgID2o9y1a"}],"key":"kt80bK2TPk"},{"type":"text","value":" these sorted halves back together, comparing elements and building a larger sorted array step by step. This merging process continues until the entire array is reassembled in sorted order.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"zizqVLbkAL"}],"key":"SV6sguZvbr"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"The algorithm has a consistent time complexity of ","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"g74DjQkvh0"},{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"O(n log n)","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"Fgff8uuuZl"}],"key":"E5mH6Px95Q"},{"type":"text","value":" — it divides the array (log n times) and merges n elements at each level. Merge sort is stable and efficient but requires extra space proportional to the array size due to its temporary workspace array.","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"hGlnEFPYzg"}],"key":"PQb22GwIGu"},{"type":"heading","depth":2,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Arrays","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"qn0u16DVZg"}],"identifier":"arrays","label":"Arrays","html_id":"arrays","implicit":true,"key":"sHQi4N9dO0"},{"type":"heading","depth":3,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Demo Code","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"DttyqNv195"}],"identifier":"demo-code","label":"Demo Code","html_id":"demo-code","implicit":true,"key":"ggx2pAMXI9"},{"type":"code","lang":"java","value":"/*\nEngineer: James Goduy\n */\npackage mergesort_rev;\n\nimport java.util.Random;\n\n\n/*\n * The Sorter interface defines a contract that all sorting classes must follow.\n * Any class that implements Sorter must provide concrete versions of insert(),\n * sort(), and displayArray(). These are method signatures only—no code \n * is written here.\n *\n * Using an interface allows us to treat different sorting algorithms (e.g.,\n * recursive and iterative merge sorts) as the same \"type.\" This is an example\n * of polymorphism: we can write one block of code that works with any object\n * implementing Sorter, regardless of how it performs the sorting internally.\n *\n * In short, the interface provides a common structure (what must be done),\n * while each class defines its own behavior (how it is done).\n */\n\ninterface Sorter {\n    void insert(int value);\n    void sort();\n    void displayArray();\n}\n\n\nclass MergeSort implements Sorter {\n\n    private int[] theArray;  // Main array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum capacity of the array\n\n    // Constructor: initializes the array and tracking variables\n    public MergeSort(int max) {\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n    // Check if array is full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert a value into the array (if space allows)\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        theArray[nElems++] = value; // Place value and increment element count\n    }\n\n    // Public method to start the merge sort process\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary workspace for merging\n        recMergeSort(workspace, 0, nElems - 1); // Begin recursive sorting\n    }\n\n    // Recursive function that splits and sorts subarrays\n    private void recMergeSort(int[] workspace, int lowerBound, int upperBound) {\n        if (lowerBound >= upperBound) return; // Base case: one element\n\n        int mid = (lowerBound + upperBound) / 2; // Find midpoint\n\n        // Recursively sort left and right halves\n        recMergeSort(workspace, lowerBound, mid);\n        recMergeSort(workspace, mid + 1, upperBound);\n\n        // Merge the two sorted halves\n        merge(workspace, lowerBound, mid + 1, upperBound);\n    }\n\n    // Merge two sorted halves into a single sorted run\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                   // Index for workspace\n        int lowerBound = lowPtr;     // Start index of left half\n        int mid = highPtr - 1;       // End index of left half\n        int n = upperBound - lowerBound + 1; // Total elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr <= mid && highPtr <= upperBound) {\n            workspace[j++] = (theArray[lowPtr] <= theArray[highPtr])\n                    ? theArray[lowPtr++]\n                    : theArray[highPtr++];\n        }\n\n        // Copy any remaining elements from the left half\n        if (lowPtr <= mid) {\n            System.arraycopy(theArray, lowPtr, workspace, j, mid - lowPtr + 1);\n            j += (mid - lowPtr + 1);\n        }\n\n        // Copy any remaining elements from the right half\n        if (highPtr <= upperBound) {\n            System.arraycopy(theArray, highPtr, workspace, j, upperBound - highPtr + 1);\n        }\n\n        // Copy merged elements back into the original array\n        System.arraycopy(workspace, 0, theArray, lowerBound, n);\n    }\n\n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n} // End Of Class\n\nclass MergeSort_Iterative implements Sorter {\n\n    // Instance Variables\n    private int[] theArray;  // The array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum array capacity (limit)\n\n    // Constructor\n    public MergeSort_Iterative (int max) {\n        // Initialize the array and size counters\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n\n    // Utility Method\n    // Checks whether the array is already full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert Method\n    // Adds a value to the array if space is available\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        // Store value and increase the element count\n        theArray[nElems++] = value;\n    }\n\n\n    // Iterative Merge Sort\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary array used during merging\n        \n        // subSize represents the size of subarrays being merged each pass\n        // Start with subarrays of size 1 and double the size each iteration\n        for (int subSize = 1; subSize < nElems; subSize *= 2) {\n            \n            // Process and merge all pairs of subarrays of the current subSize\n            for (int leftStart = 0; leftStart < nElems - subSize; leftStart += 2 * subSize) {\n                \n                // leftStart: beginning index of left subarray\n                int mid = leftStart + subSize - 1; // Last index of left subarray\n                \n                // Ensure the right subarray does not exceed array bounds\n                int rightEnd = Math.min(leftStart + 2 * subSize - 1, nElems - 1);\n                \n                // Merge the two adjacent sorted subarrays into one\n                merge(workspace, leftStart, mid + 1, rightEnd);\n            }\n        }\n    }\n\n\n    // Merge Method\n    // Merges two sorted halves into a single sorted section\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                    // Index for workspace array\n        int lowerBound = lowPtr;      // Start index of the left half\n        int mid = highPtr - 1;        // End index of the left half\n        int n = upperBound - lowerBound + 1; // Total number of elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr <= mid && highPtr <= upperBound) {\n            if (theArray[lowPtr] <= theArray[highPtr])\n                workspace[j++] = theArray[lowPtr++]; // Copy from left half\n            else\n                workspace[j++] = theArray[highPtr++]; // Copy from right half\n        }\n\n        // Copy any remaining elements from the left half\n        while (lowPtr <= mid) {\n            workspace[j++] = theArray[lowPtr++];\n        }\n\n        // Copy any remaining elements from the right half\n        while (highPtr <= upperBound) {\n            workspace[j++] = theArray[highPtr++];\n        }\n\n        // Copy merged elements back into the original array\n        for (int k = 0; k < n; k++) {\n            theArray[lowerBound + k] = workspace[k];\n        }\n    }\n    \n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n}\n\n\npublic class MergeSort_Rev {\n\n\n    public static void main(String[] args)\n    {\n        \n        int maxSize = 15    ;\n        int sampleSize =  (int)(maxSize * .9);\n        int choice = 2;\n        \n        Sorter ms;\n        \n        // create the object\n        if(choice == 1)\n        {\n            // recursive\n        \tms = new MergeSort(maxSize);\n        }\n        else\n        {\n            // iterative - loops\n            ms = new MergeSort_Iterative (maxSize);\n        }\n\n        // Create RNG\n        Random RNG = new Random();\n\n        // insert random numbers\n        for(int c = 0 ; c < sampleSize; c++)\n        {\n            ms.insert(RNG.nextInt(0,maxSize));\n        }\n      \n        // display the orignal array\n        ms.displayArray();\n\n        \n        // sort the list\n        ms.sort();\n        \n        // spacing\n        System.out.println();\n\n        // display the sorted list\n        ms.displayArray();\n\n        System.out.println(\"\\nbye\\n\");\n    }\n    \n}","position":{"start":{"line":13,"column":1},"end":{"line":277,"column":1}},"key":"fjvJYezn5a"},{"type":"heading","depth":2,"position":{"start":{"line":279,"column":1},"end":{"line":279,"column":1}},"children":[{"type":"text","value":"Linked Lists","position":{"start":{"line":279,"column":1},"end":{"line":279,"column":1}},"key":"hRjMB8onbp"}],"identifier":"linked-lists","label":"Linked Lists","html_id":"linked-lists","implicit":true,"key":"sHnu02lA5U"},{"type":"heading","depth":3,"position":{"start":{"line":281,"column":1},"end":{"line":281,"column":1}},"children":[{"type":"text","value":"Demo Code","position":{"start":{"line":281,"column":1},"end":{"line":281,"column":1}},"key":"USok9fnrZQ"}],"identifier":"demo-code","label":"Demo Code","html_id":"demo-code-1","implicit":true,"key":"BeHCA0uInK"},{"type":"code","lang":"java","value":"/*\n * Example program demonstrating two implementations of Merge Sort\n * for a linked list of people (first name, last name, city).\n * \n * Both recursive (top-down) and iterative (bottom-up) versions\n * implement a common interface (Sorter) for interchangeable use.\n *\n * Author: [Your Name]\n * Course: [Your Class Name or Section]\n */\n\npackage mergesortlinkedlist;\n\n// ----------------------------------------------------------------------\n// Interface Definition\n// ----------------------------------------------------------------------\n\n/**\n * The Sorter interface defines a simple contract for\n * inserting, sorting, and displaying a collection.\n * \n * Both recursive and iterative merge sort classes\n * will implement this interface to ensure consistent usage.\n */\ninterface Sorter {\n    void insert(String fn, String ln, String cty);\n    void sort();\n    void displayList();\n}\n\n// ----------------------------------------------------------------------\n// Recursive Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Recursive\n * \n * Uses a recursive (top-down) merge sort approach.\n * The list is divided into halves until single nodes remain,\n * then merged back together in sorted order by last name.\n */\nclass MergeSortLinkedList_Recursive implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     * Each node stores a person's first name, last name, and city.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head;  // Head pointer for the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public sort method — initiates recursive merge sort.\n     */\n    public void sort() {\n        head = mergeSort(head);\n    }\n\n    /**\n     * Recursive merge sort: splits the list, sorts each half, and merges them.\n     */\n    private Node mergeSort(Node h) {\n        // Base case: 0 or 1 element\n        if (h == null || h.next == null) return h;\n\n        // Split the list into two halves\n        Node middle = getMiddle(h);\n        Node nextOfMiddle = middle.next;\n        middle.next = null; // Split into two sublists\n\n        // Recursively sort both halves\n        Node left = mergeSort(h);\n        Node right = mergeSort(nextOfMiddle);\n\n        // Merge the two sorted halves\n        return sortedMerge(left, right);\n    }\n\n    /**\n     * Merges two sorted linked lists into one (sorted by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n\n        Node result;\n\n        // Compare by last name (case-insensitive)\n        if (a.lastName.compareToIgnoreCase(b.lastName) <= 0) {\n            result = a;\n            result.next = sortedMerge(a.next, b);\n        } else {\n            result = b;\n            result.next = sortedMerge(a, b.next);\n        }\n\n        return result;\n    }\n\n    /**\n     * Finds the middle node of a linked list using the fast/slow pointer method.\n     */\n    private Node getMiddle(Node h) {\n        if (h == null) return h;\n\n        Node slow = h, fast = h;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Iterative Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Iterative\n * \n * Uses an iterative (bottom-up) merge sort approach.\n * Starts by merging small sorted sublists of size 1, then doubles\n * the size of the sublists (1, 2, 4, 8...) until the full list is sorted.\n */\nclass MergeSortLinkedList_Iterative implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head; // Head of the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public method to start iterative merge sort.\n     */\n    public void sort() {\n        head = mergeSortIterative(head);\n    }\n\n    /**\n     * Iterative (loop-based) merge sort implementation.\n     * Uses sublist merging of increasing size to avoid recursion.\n     */\n    private Node mergeSortIterative(Node head) {\n        if (head == null || head.next == null) return head;\n\n        int n = getSize(head);\n\n        // Dummy node simplifies pointer management during merging\n        Node dummy = new Node(\"\", \"\", \"\");\n        dummy.next = head;\n\n        // Merge sublists of size 1, 2, 4, 8, etc.\n        for (int step = 1; step < n; step *= 2) {\n            Node prev = dummy;\n            Node current = dummy.next;\n\n            while (current != null) {\n                Node left = current;\n                Node right = split(left, step);\n                current = split(right, step);\n\n                Node merged = sortedMerge(left, right);\n                prev.next = merged;\n\n                // Move 'prev' to the end of the merged sublist\n                while (prev.next != null)\n                    prev = prev.next;\n            }\n        }\n\n        return dummy.next;\n    }\n\n    /**\n     * Splits the list after 'size' nodes and returns the next sublist.\n     */\n    private Node split(Node head, int size) {\n        if (head == null) return null;\n        for (int i = 1; head.next != null && i < size; i++)\n            head = head.next;\n\n        Node second = head.next;\n        head.next = null;\n        return second;\n    }\n\n    /**\n     * Merges two sorted linked lists (by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        Node dummy = new Node(\"\", \"\", \"\");\n        Node tail = dummy;\n\n        while (a != null && b != null) {\n            if (a.lastName.compareToIgnoreCase(b.lastName) <= 0) {\n                tail.next = a;\n                a = a.next;\n            } else {\n                tail.next = b;\n                b = b.next;\n            }\n            tail = tail.next;\n        }\n\n        tail.next = (a != null) ? a : b;\n        return dummy.next;\n    }\n\n    /**\n     * Counts the number of nodes in the list.\n     */\n    private int getSize(Node head) {\n        int count = 0;\n        while (head != null) {\n            count++;\n            head = head.next;\n        }\n        return count;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Driver Class\n// ----------------------------------------------------------------------\n\n/**\n * Main driver class.\n * \n * Demonstrates the use of both recursive and iterative\n * linked list merge sort implementations via the Sorter interface.\n */\npublic class MergeSortLinkedList {\n\n    public static void main(String[] args) {\n\n        Sorter list;\n\n        int choice = 1;  // 1 = Recursive, 2 = Iterative\n\n        if (choice == 1)\n            list = new MergeSortLinkedList_Recursive();\n        else\n            list = new MergeSortLinkedList_Iterative();\n\n        // Insert sample data\n        list.insert(\"Alice\", \"Zimmer\", \"Chicago\");\n        list.insert(\"Bob\", \"Anderson\", \"Kalispell\");\n        list.insert(\"Cathy\", \"Johnson\", \"Seattle\");\n        list.insert(\"Daniel\", \"Brown\", \"Denver\");\n\n        // Display before sorting\n        System.out.println(\"Before Sorting:\");\n        list.displayList();\n\n        // Sort and display results\n        list.sort();\n        System.out.println(\"After Sorting by Last Name:\");\n        list.displayList();\n    }\n}\n","position":{"start":{"line":283,"column":1},"end":{"line":629,"column":1}},"key":"fNVIz4Ts3d"},{"type":"heading","depth":2,"position":{"start":{"line":631,"column":1},"end":{"line":631,"column":1}},"children":[{"type":"text","value":"When To Use","position":{"start":{"line":631,"column":1},"end":{"line":631,"column":1}},"key":"vcrHhb0HyV"}],"identifier":"when-to-use","label":"When To Use","html_id":"when-to-use","implicit":true,"key":"drlzZfv7QX"},{"type":"heading","depth":3,"position":{"start":{"line":633,"column":1},"end":{"line":633,"column":1}},"children":[{"type":"text","value":"Quick summary","position":{"start":{"line":633,"column":1},"end":{"line":633,"column":1}},"key":"UiUESup3Iq"}],"identifier":"quick-summary","label":"Quick summary","html_id":"quick-summary","implicit":true,"key":"Q69lVxMgQS"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":635,"column":1},"end":{"line":637,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"children":[{"type":"text","value":"Both","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"zXWsngECzw"}],"key":"Uv4KTSBFae"},{"type":"text","value":" are ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"pK9AWGFuUg"},{"type":"inlineCode","value":"O(n log n)","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"xlfvaNmVlb"},{"type":"text","value":" time, ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"ZvXN1DxvVJ"},{"type":"strong","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"children":[{"type":"text","value":"stable","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"bXordn1bU2"}],"key":"trAw6tdGYm"},{"type":"text","value":", and ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"vlz0cBu1o3"},{"type":"inlineCode","value":"O(1)","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"yhojNCEimX"},{"type":"text","value":" extra space on the list (recursive adds ","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"MZxuAchLCx"},{"type":"inlineCode","value":"O(log n)","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"IagUTOFLsD"},{"type":"text","value":" call-stack space).","position":{"start":{"line":635,"column":1},"end":{"line":635,"column":1}},"key":"S2xP5nvg7N"}],"key":"cN9jF2FqOD"}],"key":"VfwZAKOLj1"},{"type":"listItem","spread":true,"position":{"start":{"line":636,"column":1},"end":{"line":637,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"S6FzU0t0qY"}],"key":"nNOpCNJhjq"},{"type":"text","value":" = simpler to read/teach; ","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"vmmygr5To4"},{"type":"strong","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"children":[{"type":"text","value":"Iterative","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"yximz6KZRG"}],"key":"wnzZvyuRUM"},{"type":"text","value":" = no recursion, often better constants and safer for huge inputs.","position":{"start":{"line":636,"column":1},"end":{"line":636,"column":1}},"key":"s10lh05DOe"}],"key":"ZWSaQQYHhg"}],"key":"eINgKYNjNH"}],"key":"QJsJkHQcTv"},{"type":"heading","depth":3,"position":{"start":{"line":638,"column":1},"end":{"line":638,"column":1}},"children":[{"type":"text","value":"Strengths vs. weaknesses","position":{"start":{"line":638,"column":1},"end":{"line":638,"column":1}},"key":"J60xjRpDUB"}],"identifier":"strengths-vs-weaknesses","label":"Strengths vs. weaknesses","html_id":"strengths-vs-weaknesses","implicit":true,"key":"wTgddM1uTs"},{"type":"heading","depth":4,"position":{"start":{"line":640,"column":1},"end":{"line":640,"column":1}},"children":[{"type":"text","value":"Recursive (top-down)","position":{"start":{"line":640,"column":1},"end":{"line":640,"column":1}},"key":"tDOpLHJKXD"}],"identifier":"recursive-top-down","label":"Recursive (top-down)","html_id":"recursive-top-down","implicit":true,"key":"OfJ21vrbKG"},{"type":"paragraph","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"children":[{"type":"strong","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"children":[{"type":"text","value":"How it works:","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"kIpJbJB5as"}],"key":"Hlhy23uXL7"},{"type":"text","value":" repeatedly split with fast/slow pointers (","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"RJvrrl7EkL"},{"type":"inlineCode","value":"getMiddle","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"aWMJ5lT4wt"},{"type":"text","value":"), then merge.","position":{"start":{"line":642,"column":1},"end":{"line":642,"column":1}},"key":"C8Di92Yyj5"}],"key":"HRxlEK0OgB"},{"type":"paragraph","position":{"start":{"line":644,"column":1},"end":{"line":644,"column":1}},"children":[{"type":"strong","position":{"start":{"line":644,"column":1},"end":{"line":644,"column":1}},"children":[{"type":"text","value":"Strengths","position":{"start":{"line":644,"column":1},"end":{"line":644,"column":1}},"key":"Xf1osDeZIR"}],"key":"F2uhkgOWRy"}],"key":"sFBJ5ggW2I"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":646,"column":1},"end":{"line":650,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"children":[{"type":"text","value":"Clarity & pedagogy:","position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"key":"IMZ6Avnynr"}],"key":"Zj2Ju3JxFx"},{"type":"text","value":" mirrors the textbook definition; very readable for students.","position":{"start":{"line":646,"column":1},"end":{"line":646,"column":1}},"key":"gBWs9VHdWC"}],"key":"VHnQ9Dwf0P"}],"key":"fsuOPDS6OG"},{"type":"listItem","spread":true,"position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"children":[{"type":"text","value":"Natural structure:","position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"key":"jQV31X0ojT"}],"key":"Xpook35Wjo"},{"type":"text","value":" the “divide → conquer → combine” flow matches the mental model of merge sort.","position":{"start":{"line":647,"column":1},"end":{"line":647,"column":1}},"key":"zFWdz4ezkj"}],"key":"UMCMb4aTI0"}],"key":"oVgg6N8TgJ"},{"type":"listItem","spread":true,"position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"children":[{"type":"text","value":"Easy to parallelize:","position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"key":"S5QqWFJuze"}],"key":"EtiST2EPdB"},{"type":"text","value":" left and right halves can be sorted concurrently if you go multi-threaded later.","position":{"start":{"line":648,"column":1},"end":{"line":648,"column":1}},"key":"En8qQDcFeS"}],"key":"utLPLvPcEl"}],"key":"JW93xwrZI9"},{"type":"listItem","spread":true,"position":{"start":{"line":649,"column":1},"end":{"line":650,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":649,"column":1},"end":{"line":649,"column":1}},"children":[{"type":"text","value":"Stable by construction:","position":{"start":{"line":649,"column":1},"end":{"line":649,"column":1}},"key":"HHz8ZTFkHr"}],"key":"VIZSl8rBo5"},{"type":"text","value":" merge step preserves order of equals.","position":{"start":{"line":649,"column":1},"end":{"line":649,"column":1}},"key":"IClAMeb0Of"}],"key":"dH0InnlJoo"}],"key":"QFdC6lBAUw"}],"key":"D4RvNXOV15"},{"type":"paragraph","position":{"start":{"line":651,"column":1},"end":{"line":651,"column":1}},"children":[{"type":"strong","position":{"start":{"line":651,"column":1},"end":{"line":651,"column":1}},"children":[{"type":"text","value":"Weaknesses","position":{"start":{"line":651,"column":1},"end":{"line":651,"column":1}},"key":"T9PjK5vy96"}],"key":"K3I3ucZ4N1"}],"key":"MMh3gz9vLI"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":653,"column":1},"end":{"line":656,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"children":[{"type":"text","value":"Call-stack use:","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"pBBxfKen47"}],"key":"ozhl5WgjfB"},{"type":"text","value":" ","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"zAAM7Q0tKC"},{"type":"inlineCode","value":"O(log n)","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"vGsGymRcE7"},{"type":"text","value":" stack frames. Usually fine, but it’s still extra memory and can matter on very tight stacks or unusual environments.","position":{"start":{"line":653,"column":1},"end":{"line":653,"column":1}},"key":"g5pSCbI2uv"}],"key":"WHjFt74Faf"}],"key":"eW9cSRHQzU"},{"type":"listItem","spread":true,"position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"children":[{"type":"text","value":"Function-call overhead:","position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"key":"dXMTHPfnag"}],"key":"Dse8ppgHgg"},{"type":"text","value":" many small recursive calls; minor but measurable on some JVMs.","position":{"start":{"line":654,"column":1},"end":{"line":654,"column":1}},"key":"gnwWNlCZJg"}],"key":"NRju99Tz2y"}],"key":"bXygOJpmGn"},{"type":"listItem","spread":true,"position":{"start":{"line":655,"column":1},"end":{"line":656,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"children":[{"type":"text","value":"Middle finding every level:","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"cG7y0pspL2"}],"key":"E0hGSdYHNu"},{"type":"text","value":" each split uses fast/slow pointers; total cost stays ","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"NSRzCJpuzt"},{"type":"inlineCode","value":"O(n log n)","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"VubQFIYeKH"},{"type":"text","value":" but the constant factor isn’t free.","position":{"start":{"line":655,"column":1},"end":{"line":655,"column":1}},"key":"ahQY0n4xvj"}],"key":"ZoWnIg46VR"}],"key":"DOPjwiFNrN"}],"key":"YpvJ0AQfbX"},{"type":"heading","depth":4,"position":{"start":{"line":657,"column":1},"end":{"line":657,"column":1}},"children":[{"type":"text","value":"Iterative (bottom-up)","position":{"start":{"line":657,"column":1},"end":{"line":657,"column":1}},"key":"lJya2JoMDM"}],"identifier":"iterative-bottom-up","label":"Iterative (bottom-up)","html_id":"iterative-bottom-up","implicit":true,"key":"bb46lJrO2N"},{"type":"paragraph","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"children":[{"type":"strong","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"children":[{"type":"text","value":"How it works:","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"vq5cBoFzRe"}],"key":"EA4C9wdUs5"},{"type":"text","value":" repeatedly merge runs of size ","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"rc72ZCiLeu"},{"type":"inlineCode","value":"1, 2, 4, 8, …","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"IQZPOIWxK1"},{"type":"text","value":" using loops; uses pointer “splicing” (","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"HbtrtEVh2m"},{"type":"inlineCode","value":"split","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"zTIQ2AYDY1"},{"type":"text","value":", ","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"slnPHgWhOP"},{"type":"inlineCode","value":"merge","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"kjKjccnNDe"},{"type":"text","value":") and a dummy head.","position":{"start":{"line":659,"column":1},"end":{"line":659,"column":1}},"key":"mXplyB1EIO"}],"key":"nNexu5iFpa"},{"type":"paragraph","position":{"start":{"line":661,"column":1},"end":{"line":661,"column":1}},"children":[{"type":"strong","position":{"start":{"line":661,"column":1},"end":{"line":661,"column":1}},"children":[{"type":"text","value":"Strengths","position":{"start":{"line":661,"column":1},"end":{"line":661,"column":1}},"key":"ePcCjWkE0S"}],"key":"kWNRLC29BG"}],"key":"WP1NahT1rK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":663,"column":1},"end":{"line":667,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"children":[{"type":"text","value":"No recursion:","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"zF9YFpv18m"}],"key":"PHWtVxHdmh"},{"type":"text","value":" avoids stack growth entirely; safer for ","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"QybcuEvsac"},{"type":"strong","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"children":[{"type":"text","value":"very large lists","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"z5cAmLqZ8S"}],"key":"uDhLYGedTL"},{"type":"text","value":" or constrained runtimes.","position":{"start":{"line":663,"column":1},"end":{"line":663,"column":1}},"key":"KH3BxeQDyZ"}],"key":"krKUDKqATw"}],"key":"EfmG5JHUgl"},{"type":"listItem","spread":true,"position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"children":[{"type":"text","value":"Good constants:","position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"key":"fcCUilKYWw"}],"key":"IP4Jybf7wx"},{"type":"text","value":" one linear pass per run size; practical throughput often edges out recursive on linked lists.","position":{"start":{"line":664,"column":1},"end":{"line":664,"column":1}},"key":"II5MB5WJts"}],"key":"jwow4jETET"}],"key":"TGjNbzUL2K"},{"type":"listItem","spread":true,"position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"children":[{"type":"text","value":"Predictable control flow:","position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"key":"zQ3F0vB2aw"}],"key":"eRrMmBECgY"},{"type":"text","value":" all in loops; easy to bound and instrument.","position":{"start":{"line":665,"column":1},"end":{"line":665,"column":1}},"key":"arywRTMQK2"}],"key":"acM7rZZVjF"}],"key":"ZpdfXITFka"},{"type":"listItem","spread":true,"position":{"start":{"line":666,"column":1},"end":{"line":667,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":666,"column":1},"end":{"line":666,"column":1}},"children":[{"type":"text","value":"Still stable:","position":{"start":{"line":666,"column":1},"end":{"line":666,"column":1}},"key":"kLsGjtonCM"}],"key":"G5VQQR5xmI"},{"type":"text","value":" merge loop preserves order of equals.","position":{"start":{"line":666,"column":1},"end":{"line":666,"column":1}},"key":"YoDF2ecI1I"}],"key":"K7Z78wOisI"}],"key":"plzcgRZQq2"}],"key":"GbiSJFmpBG"},{"type":"paragraph","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"children":[{"type":"strong","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"children":[{"type":"text","value":"Weaknesses","position":{"start":{"line":668,"column":1},"end":{"line":668,"column":1}},"key":"FnPdtrXwWF"}],"key":"sA27ujKxgS"}],"key":"RRBc1vI7Zl"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":670,"column":1},"end":{"line":673,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"children":[{"type":"text","value":"More pointer surgery:","position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"key":"FxCsMw42i3"}],"key":"Ez0glbUrVW"},{"type":"text","value":" more places to make off-by-one / null-next mistakes; trickier to get right first time.","position":{"start":{"line":670,"column":1},"end":{"line":670,"column":1}},"key":"B6Q5QMtXP5"}],"key":"goQWdubpRd"}],"key":"n8eGajmK1h"},{"type":"listItem","spread":true,"position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"children":[{"type":"text","value":"Slightly less intuitive to newcomers:","position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"key":"JIf50Efq9L"}],"key":"Uu2UeJFkMF"},{"type":"text","value":" bottom-up run doubling is less obvious than “split in half”.","position":{"start":{"line":671,"column":1},"end":{"line":671,"column":1}},"key":"cdVL7VdYU1"}],"key":"hRgq7smnBo"}],"key":"T3lFpWVubA"},{"type":"listItem","spread":true,"position":{"start":{"line":672,"column":1},"end":{"line":673,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"children":[{"type":"text","value":"Needs size or tail walking:","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"FrISwO95hJ"}],"key":"snznWJfW5X"},{"type":"text","value":" typical pattern computes ","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"KkpjAkiBTH"},{"type":"inlineCode","value":"n","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"QZdwMA48XT"},{"type":"text","value":" up front or advances pointers carefully; again, more book-keeping.","position":{"start":{"line":672,"column":1},"end":{"line":672,"column":1}},"key":"zormNmaUsK"}],"key":"bIRi4eEpEK"}],"key":"SOgoQHQ66k"}],"key":"uYB4RMNyQc"},{"type":"heading","depth":4,"position":{"start":{"line":674,"column":1},"end":{"line":674,"column":1}},"children":[{"type":"text","value":"Performance & resource notes","position":{"start":{"line":674,"column":1},"end":{"line":674,"column":1}},"key":"VIzifHn2tl"}],"identifier":"performance-resource-notes","label":"Performance & resource notes","html_id":"performance-resource-notes","implicit":true,"key":"CKWdYXZjQH"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":676,"column":1},"end":{"line":680,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"children":[{"type":"text","value":"Time complexity:","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"focabvZ8yv"}],"key":"N2ZAsMaccq"},{"type":"text","value":" both ","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"ego0eKqhZw"},{"type":"inlineCode","value":"O(n log n)","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"vMLcxDv6mT"},{"type":"text","value":" on singly linked lists.","position":{"start":{"line":676,"column":1},"end":{"line":676,"column":1}},"key":"lqjFcbm5Qo"}],"key":"ELHNlbPVRQ"}],"key":"EBrSiQu0av"},{"type":"listItem","spread":true,"position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"children":[{"type":"text","value":"Space:","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"YbpdRrLtDf"}],"key":"mzohd5muPW"},{"type":"text","value":" both in-place on nodes; ","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"OBazknMNli"},{"type":"strong","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"children":[{"type":"text","value":"recursive adds ","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"RJ6BjclKhd"},{"type":"inlineCode","value":"O(log n)","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"dURfeiwn6a"},{"type":"text","value":" call stack","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"iJkK06qAFP"}],"key":"dEip83AwYS"},{"type":"text","value":", iterative doesn’t.","position":{"start":{"line":677,"column":1},"end":{"line":677,"column":1}},"key":"ohgibnEUH7"}],"key":"wui5vT61YY"}],"key":"jpSeFk9FEi"},{"type":"listItem","spread":true,"position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"children":[{"type":"text","value":"Cache locality:","position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"key":"c66CWdaTJb"}],"key":"VRiTwxByVg"},{"type":"text","value":" neither is great (linked lists aren’t cache-friendly), but iterative’s fewer function calls can help a bit.","position":{"start":{"line":678,"column":1},"end":{"line":678,"column":1}},"key":"sjIGa9v76r"}],"key":"AwBoqwsC30"}],"key":"LRvIPBQelv"},{"type":"listItem","spread":true,"position":{"start":{"line":679,"column":1},"end":{"line":680,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"children":[{"type":"text","value":"Stability:","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"GImyk3ay0V"}],"key":"ioFZAkQzb8"},{"type":"text","value":" both remain stable as long as your merge uses ","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"fhDKiPl45b"},{"type":"inlineCode","value":"<=","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"Ec4S2dQhGR"},{"type":"text","value":" (or equivalent) and never reorders equals.","position":{"start":{"line":679,"column":1},"end":{"line":679,"column":1}},"key":"jOHZsyRIiO"}],"key":"o0O2xOexTM"}],"key":"tEO81w9KW5"}],"key":"vtlM60SvEt"},{"type":"heading","depth":4,"position":{"start":{"line":681,"column":1},"end":{"line":681,"column":1}},"children":[{"type":"text","value":"When to pick which","position":{"start":{"line":681,"column":1},"end":{"line":681,"column":1}},"key":"Qrr97oMFwJ"}],"identifier":"when-to-pick-which","label":"When to pick which","html_id":"when-to-pick-which","implicit":true,"key":"FdW4VynOWK"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":683,"column":1},"end":{"line":686,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"children":[{"type":"text","value":"Teaching / readability / quick correctness:","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"oRMDqsbIWV"}],"key":"yYGWbOfX9p"},{"type":"text","value":" ","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"DyhXTi4GDp"},{"type":"strong","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"yJTxBW6cm1"}],"key":"c8SKcOUW3O"},{"type":"text","value":".","position":{"start":{"line":683,"column":1},"end":{"line":683,"column":1}},"key":"vP7mD2nZBK"}],"key":"ZYbvPYMlk6"}],"key":"tCxLDfeXjn"},{"type":"listItem","spread":true,"position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"children":[{"type":"text","value":"Production on huge lists / tight memory / maximum robustness:","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"WldpP1Fqzo"}],"key":"gqdOpVQ667"},{"type":"text","value":" ","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"A9K5s7r35x"},{"type":"strong","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"children":[{"type":"text","value":"Iterative","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"W9NhQ5imNR"}],"key":"v3DjyWcMPy"},{"type":"text","value":".","position":{"start":{"line":684,"column":1},"end":{"line":684,"column":1}},"key":"HehgePDSJg"}],"key":"xIgWpiuK9U"}],"key":"KgpRBgAn8E"},{"type":"listItem","spread":true,"position":{"start":{"line":685,"column":1},"end":{"line":686,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"children":[{"type":"text","value":"Parallel sort of very large lists:","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"bb98tcHOEx"}],"key":"frbgI2axMd"},{"type":"text","value":" ","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"iuiTvgxfUo"},{"type":"strong","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"Mv7ZFMgqm6"}],"key":"yrycVvcpFz"},{"type":"text","value":" lends itself to parallelizing the two halves.","position":{"start":{"line":685,"column":1},"end":{"line":685,"column":1}},"key":"FKi98H6ec0"}],"key":"QuUY5CLeJP"}],"key":"b7zVhzeFeT"}],"key":"rDj8Q9pdvx"},{"type":"heading","depth":4,"position":{"start":{"line":687,"column":1},"end":{"line":687,"column":1}},"children":[{"type":"text","value":"Practical checklist","position":{"start":{"line":687,"column":1},"end":{"line":687,"column":1}},"key":"Cu7mfuXHgG"}],"identifier":"practical-checklist","label":"Practical checklist","html_id":"practical-checklist","implicit":true,"key":"WgPmCky6o4"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":689,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Need simple code? → ","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"key":"Eh54HeU2VB"},{"type":"strong","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"children":[{"type":"text","value":"Recursive","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"key":"O389OeiJkT"}],"key":"nTZ5BWA6iy"},{"type":"text","value":".","position":{"start":{"line":689,"column":1},"end":{"line":689,"column":1}},"key":"twZcsvPAQi"}],"key":"fUoLNwNejs"}],"key":"xaF3umqV5B"},{"type":"listItem","spread":true,"position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"paragraph","children":[{"type":"text","value":"Worried about stack or sorting millions of nodes? → ","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"PgnvJt0ddF"},{"type":"strong","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"children":[{"type":"text","value":"Iterative","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"jSBATtfeRT"}],"key":"kFHfB9Iypg"},{"type":"text","value":".","position":{"start":{"line":690,"column":1},"end":{"line":690,"column":1}},"key":"G7cMRlZS6a"}],"key":"W89DJAdoi7"}],"key":"XDqPjhTcRJ"}],"key":"KOzZ7fytuj"}],"key":"AVrPidWYTU"}],"key":"HhbOH8ngFP"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Merge Sort","url":"/mergesort","group":"Data Structures"},"next":{"title":"Quick Sort","url":"/quicksort","group":"Data Structures"}}},"domain":"http://localhost:3001"}