{"version":2,"kind":"Article","sha256":"c53158dda81b03a55ca2af3330de59b1a786cb5a4147785eedfe3a287ae1c3e6","slug":"basicalgo.mergesort","location":"/basicalgo/MergeSort.md","dependencies":[],"frontmatter":{"title":"Merge Sort","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_basicalgo\\0_bdbook\\myst-generated-uid-0"}],"copyright":"2024","numbering":{"title":{"offset":2}},"exports":[{"format":"md","filename":"MergeSort.md","url":"/build/MergeSort-ede2a0d8a0db7085dc1c34a51d75b734.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Here’s a summary of the pros and cons of merge sort presented in bullet points:","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"HUbMViAaZm"}],"key":"tpSYzKtDfw"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Pros of Merge Sort:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"EfOk6Dhe16"}],"key":"hs77PV77U3"}],"key":"mrLbmnXLiN"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":9,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Efficient for large datasets:","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"z6If2C9ocT"}],"key":"tDP8xBssj4"},{"type":"text","value":" Merge sort’s average and worst-case time complexities are O(n log n), making it highly efficient for sorting large datasets.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"AkPyDSteQi"}],"key":"H34o3jr3Z4"}],"key":"Z4C0tEQx25"},{"type":"listItem","spread":true,"position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Stable sorting algorithm:","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"l54w6Kot73"}],"key":"HmkYZvHp4b"},{"type":"text","value":" Merge sort preserves the original order of equal elements, making it a stable sorting algorithm. This is particularly useful when sorting data that contains multiple instances of the same value.","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"uPK2fyoJDw"}],"key":"dtcjriwUnG"}],"key":"vJgWuj51OO"},{"type":"listItem","spread":true,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Adaptable to external sorting:","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"DvoQ3yPLuf"}],"key":"Q89Q6Lvivk"},{"type":"text","value":" Merge sort can be adapted for external sorting, where the data to be sorted is too large to fit into main memory.","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"DL4oRCf97P"}],"key":"ZwRgxBG2ok"}],"key":"VU363skGnL"},{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Highly parallelizable:","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"DOtkPuJ3sY"}],"key":"PkdM66oItI"},{"type":"text","value":" Merge sort can be effectively parallelized, making it suitable for multithreaded and distributed computing environments.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"IsEA0pFfDp"}],"key":"tUoWhgBIm1"}],"key":"Sov6DHD1T8"}],"key":"dgBBSBPJEH"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"strong","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Cons of Merge Sort:","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"ZnEVmoe5wa"}],"key":"z5Y2YGaUv7"}],"key":"Fk1XKu2tyk"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":16,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Additional memory usage:","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"u271u9G7jC"}],"key":"BlCgNfFBRg"},{"type":"text","value":" Merge sort requires additional memory to store the temporary sublists created during the sorting process.","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"IXgg3e5wp5"}],"key":"iYnMvBmm5S"}],"key":"ZFEku58Osn"},{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Overhead for small datasets:","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"IoxqHTX8Qs"}],"key":"sAZ7k4F7Zm"},{"type":"text","value":" For small datasets, the overhead of recursion and merging can make merge sort less efficient than simpler algorithms like insertion sort.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"YeH3bTBG5v"}],"key":"JEKUYnqABE"}],"key":"Xswz1LPNtL"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Not in-place sorting:","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"DV8CUOjd2J"}],"key":"WAdbZxwyeM"},{"type":"text","value":" Merge sort is not an in-place sorting algorithm, meaning it requires additional memory to store the sorted result.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"MWPeTscbKS"}],"key":"EdVdNGlpak"}],"key":"FszoG5NXdD"}],"key":"lOcvoVCf9C"},{"type":"paragraph","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"Overall, merge sort is a versatile and efficient sorting algorithm that is particularly well-suited for large datasets. However, its additional memory requirements and overhead for small datasets make it less suitable for certain applications.","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"U48bwV8ejf"}],"key":"swXxUzfQEP"}],"key":"tEe48VsRC0"}],"key":"p3XCwHziD3"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Bubble Sort","url":"/basicalgo/sort-bubble","group":"Basic Algorithms"},"next":{"title":"Merge Sort - Demo Code","url":"/basicalgo/mergesort-reva","group":"Basic Algorithms"}}},"domain":"http://localhost:3000"}