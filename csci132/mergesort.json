{"version":2,"kind":"Article","sha256":"c53158dda81b03a55ca2af3330de59b1a786cb5a4147785eedfe3a287ae1c3e6","slug":"mergesort","location":"/basicalgo/MergeSort.md","dependencies":[],"frontmatter":{"title":"Merge Sort","content_includes_title":false,"authors":[{"nameParsed":{"literal":"James Goudy","given":"James","family":"Goudy"},"name":"James Goudy","id":"contributors-a_books\\csci132_basicalgo\\the_bdbook\\myst-generated-uid-0"}],"copyright":"2025","numbering":{"title":{"offset":2}},"exports":[{"format":"md","filename":"MergeSort.md","url":"/build/MergeSort-1482d484f937e08e06e1aad6a2c51dba.md"}]},"mdast":{"type":"root","children":[{"type":"block","children":[{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Here’s a summary of the pros and cons of merge sort presented in bullet points:","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"dr2FW8ACwg"}],"key":"zbDRrxFGxj"},{"type":"paragraph","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"strong","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"Pros of Merge Sort:","position":{"start":{"line":7,"column":1},"end":{"line":7,"column":1}},"key":"DLUBzaPlF3"}],"key":"tWRSQo1MwH"}],"key":"D4wuqtT3jN"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":9,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"children":[{"type":"text","value":"Efficient for large datasets:","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"Uxu5srHImL"}],"key":"tdryWqqJzL"},{"type":"text","value":" Merge sort’s average and worst-case time complexities are O(n log n), making it highly efficient for sorting large datasets.","position":{"start":{"line":9,"column":1},"end":{"line":9,"column":1}},"key":"pY0XcBpFcv"}],"key":"dHdPxB3cvO"}],"key":"z28KOl312y"},{"type":"listItem","spread":true,"position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"children":[{"type":"text","value":"Stable sorting algorithm:","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"hSo7Ttn5va"}],"key":"VOcFifmOWO"},{"type":"text","value":" Merge sort preserves the original order of equal elements, making it a stable sorting algorithm. This is particularly useful when sorting data that contains multiple instances of the same value.","position":{"start":{"line":10,"column":1},"end":{"line":10,"column":1}},"key":"zfjss9qDbF"}],"key":"Qhlroj1l7e"}],"key":"nhODmh5t92"},{"type":"listItem","spread":true,"position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"children":[{"type":"text","value":"Adaptable to external sorting:","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"SpjwQC89Es"}],"key":"GzfF0mpcrQ"},{"type":"text","value":" Merge sort can be adapted for external sorting, where the data to be sorted is too large to fit into main memory.","position":{"start":{"line":11,"column":1},"end":{"line":11,"column":1}},"key":"t0PrpJXfgh"}],"key":"yhr4NBI2nV"}],"key":"D2IU3rLaY2"},{"type":"listItem","spread":true,"position":{"start":{"line":12,"column":1},"end":{"line":13,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"children":[{"type":"text","value":"Highly parallelizable:","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"LJXSupX1KV"}],"key":"ML9qLacktP"},{"type":"text","value":" Merge sort can be effectively parallelized, making it suitable for multithreaded and distributed computing environments.","position":{"start":{"line":12,"column":1},"end":{"line":12,"column":1}},"key":"zePJPsMU4w"}],"key":"aWfSaqbb68"}],"key":"p2rS3mpeqG"}],"key":"yOyR2cWEM9"},{"type":"paragraph","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"strong","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"children":[{"type":"text","value":"Cons of Merge Sort:","position":{"start":{"line":14,"column":1},"end":{"line":14,"column":1}},"key":"TSQrrByJGX"}],"key":"BMFov1I1o6"}],"key":"wFwxr3S885"},{"type":"list","ordered":false,"spread":false,"position":{"start":{"line":16,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"listItem","spread":true,"position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"children":[{"type":"text","value":"Additional memory usage:","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"d2x0mokLuy"}],"key":"nsGATpf2mN"},{"type":"text","value":" Merge sort requires additional memory to store the temporary sublists created during the sorting process.","position":{"start":{"line":16,"column":1},"end":{"line":16,"column":1}},"key":"QlvFSoBvKJ"}],"key":"gP57T96Dh9"}],"key":"g3Hp5shdiw"},{"type":"listItem","spread":true,"position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"children":[{"type":"text","value":"Overhead for small datasets:","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"xD5Q1ktHib"}],"key":"XlR0X4iTZC"},{"type":"text","value":" For small datasets, the overhead of recursion and merging can make merge sort less efficient than simpler algorithms like insertion sort.","position":{"start":{"line":17,"column":1},"end":{"line":17,"column":1}},"key":"aj9xYC0H60"}],"key":"GHGtRSk14b"}],"key":"yuMpct9NVO"},{"type":"listItem","spread":true,"position":{"start":{"line":18,"column":1},"end":{"line":19,"column":1}},"children":[{"type":"paragraph","children":[{"type":"strong","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"children":[{"type":"text","value":"Not in-place sorting:","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"qxxPYlH5WG"}],"key":"sAw5M2ec6T"},{"type":"text","value":" Merge sort is not an in-place sorting algorithm, meaning it requires additional memory to store the sorted result.","position":{"start":{"line":18,"column":1},"end":{"line":18,"column":1}},"key":"ZXmd9jYjsB"}],"key":"G4dSdZbzFb"}],"key":"tOIfhNLmDi"}],"key":"QuTNvsble1"},{"type":"paragraph","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"children":[{"type":"text","value":"Overall, merge sort is a versatile and efficient sorting algorithm that is particularly well-suited for large datasets. However, its additional memory requirements and overhead for small datasets make it less suitable for certain applications.","position":{"start":{"line":20,"column":1},"end":{"line":20,"column":1}},"key":"kMrfUow0sS"}],"key":"cLFRVMmukk"}],"key":"FSxfU9syMi"}],"key":"fVq3gXY1WX"},"references":{"cite":{"order":[],"data":{}}},"footer":{"navigation":{"prev":{"title":"Bubble Sort","url":"/sort-bubble","group":"Basic Algorithms"},"next":{"title":"Merge Sort - Demo Code","url":"/mergesort-reva","group":"Basic Algorithms"}}},"domain":"http://localhost:3000"}