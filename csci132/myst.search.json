{"version":"1","records":[{"hierarchy":{"lvl1":""},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":""},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Array Add and Delete Data"},"type":"lvl1","url":"/xarrayadddeletedata","position":0},{"hierarchy":{"lvl1":"Array Add and Delete Data"},"content":"","type":"content","url":"/xarrayadddeletedata","position":1},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Key Ideas"},"type":"lvl2","url":"/xarrayadddeletedata#key-ideas","position":2},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Key Ideas"},"content":"In working with arrays, keeping data continuous is a good practice the majority of the time.  If data in an element is deleted, the data in the elements to the right should be shifted left to remove the empty space.\n\nAlso, there may be times when data has to be inserted into an array that has continuous data elements.  In this case, data is shifted to the right to create a space where the new data can be inserted.\n\nTip\n\nIn many cases, arrays are usually set to have more elements than is needed. Therefore, it is important to create a variable that will alway track the number of items in the array.","type":"content","url":"/xarrayadddeletedata#key-ideas","position":3},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Lecture Code"},"type":"lvl2","url":"/xarrayadddeletedata#lecture-code","position":4},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Lecture Code"},"content":"/*\n *\n * Project: Add Delete In an Array\n * Programmer: J Goudy\n \n */\n\n\npublic class DS_ArraysAddDelete {\n\n    static String[] arrString;\n    static int arrStrDataCount = 0;\n\n    static void loadStringArray() {\n    // this is a helper function to setup our example array\n        \n        String[] names = {\"Adam\", \"Bobby\", \"Howard\", \"Mary\", \"Zuzu\"};\n\n        //load names\n        for (int c = 0; c < names.length; c++) {\n            arrString[c] = names[c];\n        }\n\n\t\t//set our number of data items\n        arrStrDataCount = names.length;\n\n        // print number of items\n        System.out.println(\"DataCount = \" + arrStrDataCount);\n\n        printArray(arrString, arrStrDataCount);\n\n    }\n\n    static void printArray(String[] theArray, int dataCount) {\n    // This function prints the array. \n    // Note that an array is being passed to it.\n        \n        // for spacing\n        System.out.println();\n        \n        // iterate through the array and print the data\n        for (int i = 0; i < dataCount; i++) {\n            System.out.print(theArray[i] + \" \");\n        }\n\n        System.out.println(\"\\n------------\\n\");\n\n    }\n\n    static void insertStringByPos(int pos, String aName) {\n        // ---------- Do some checks ---------------------\n\n        // check if position is withing array bounds\n        if (pos > arrStrDataCount) {\n            System.out.println(\"Error out array bounds\");\n\n            // exit the function\n            return;\n        }\n\n        // check if the array is full\n        if (arrStrDataCount >= arrString.length) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n\n        // -------------- Insert Code --------------------------\n        // shift to right\n        // note that the loop is starting at the end and \n        // working backwards to the insert spot (pos)\n        for (int i = arrStrDataCount; i > pos; i--) {\n\n            arrString[i] = arrString[i - 1];\n        }\n\n        // insert the new name\n        arrString[pos] = aName;\n\n        // increment our data Count\n        arrStrDataCount++;\n\n        // print the array to show data was inserted\n        printArray(arrString, arrStrDataCount);\n\n    }\n\n    static void deleteByPos(int pos) {\n        // check if there is contents\n        if (arrStrDataCount <= 0) {\n            System.out.println(\"Array is empty\\n\");\n            return;\n        }\n\n        // check if the position to delete is out of bounds\n        if (pos >= arrStrDataCount) {\n            System.out.println(\"Pos is out of bounds\\n\");\n            return;\n        }\n\n        // -----------  Delete Code ---------------------\n        // shift loop\n        // note that the loop starts at the element location \n        // that is being deleted\n        for (int i = pos; i < arrStrDataCount; i++) {\n            arrString[i] = arrString[i + 1];\n        }\n\n        // decrease the item count by 1\n        arrStrDataCount--;\n\n        printArray(arrString, arrStrDataCount);\n\n    }\n\n    public static void main(String[] args) {\n\n        // instantiate the data array\n        arrString = new String[8];\n\n        try {\n            \n            // setup the demo array\n            loadStringArray();\n\n            // insert \"Bubba\" in the third positon of the array\n            insertStringByPos(2, \"Bubba\");\n\n            // delete the data in the second \n            // element/position of the array\n            deleteByPos(1);\n            \n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n        \n        System.out.println(\"\\n\\nbye\\n\");\n    }\n}\n\n\nEnd Of Topic","type":"content","url":"/xarrayadddeletedata#lecture-code","position":5},{"hierarchy":{"lvl1":"Array Techniques"},"type":"lvl1","url":"/xarraytechniques","position":0},{"hierarchy":{"lvl1":"Array Techniques"},"content":"Array Wrap Around\n\nArray Add and Delete Data Continuously\n\nEnd of Topic","type":"content","url":"/xarraytechniques","position":1},{"hierarchy":{"lvl1":"Array Warp Around"},"type":"lvl1","url":"/xarraywarparound","position":0},{"hierarchy":{"lvl1":"Array Warp Around"},"content":"","type":"content","url":"/xarraywarparound","position":1},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Key Ideas"},"type":"lvl2","url":"/xarraywarparound#key-ideas","position":2},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Key Ideas"},"content":"Place data in an array.\n\nIf the data element is “full/occupied”,  look to the right for the next empty element and wrap around to the beginning element if at the end.","type":"content","url":"/xarraywarparound#key-ideas","position":3},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Lecture Code"},"type":"lvl2","url":"/xarraywarparound#lecture-code","position":4},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Lecture Code"},"content":"/*\n * DS132SU_WrapAround\n *\n * Programmer: Jim Goudy\n * Project: Wrap Around Array\n This shows how to wrap around in an around.\n Meaning, the program looks to see if an array\n element is open. If it is not, then look to\n the right. Continue looking to the right,\n till the next available element is open.\n \n *\n */\n\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class DS_WrapAround {\n\n    static int ArrayLength = 8;\n    static String[] myArray = new String[ArrayLength];\n    static int maxVal = ArrayLength;\n\t\n    static Scanner myScan = new Scanner(System.in);\n\tstatic Random RNG = new Random();\n    \n    static int myRNG() {\n        // Generate a random number \n        // within the number of array elements\n        return RNG.nextInt(maxVal);\n    }\n\n    static void printArray() {\n        // print the array\n        \n        for (int c = 0; c < myArray.length; c++) {\n            if (myArray[c] == null) {\n                System.out.print(\" - |\");\n            } else {\n                System.out.print(myArray[c] + \" |\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n\n        String run = \"y\";\n        int aIndex = -1;\n        boolean check = true;\n        int boxCntr = 0;\n\n        String quit = \"y\";\n        \n        // assign values to the array - go to right if occupied\n        // this loops continues till the array is full\n        while (run.equals(\"y\")) {\n            aIndex = myRNG();\n            System.out.print(\"\\nComputer chooses \" + aIndex + \"\\n\");\n\n            // fill the array element\n            while (check) {\n                if (myArray[aIndex] == null) {\n                    //array index(box) is empty\n                    myArray[aIndex] = \" X\";\n                    \n                    // this variable keeps track of \n                    // the total number of elments that\n                    // are occupied/filled\n                    boxCntr++;\n                    \n                    // sets variable to exit \n                    // the inner while loop\n                    check = false;\n                    \n                    // check if all the array elements are filled\n                    if (boxCntr == myArray.length) {\n                        run = \"n\";\n                    }\n                } else {\n                    // array index (box) is not empty \n                    aIndex++;\n                    System.out.println(\"move right \" + aIndex);\n                    \n                    // if the index is at the end of the array\n                    // wrap around to the first element 0\n                    if (aIndex == myArray.length) {\n                        aIndex = 0;\n                        System.out.println(\"move right \" + aIndex);\n                    }\n                }\n            }\n            \n            check = true;\n            printArray();\n        }\n\n    }\n}\n/*\nNote: Since the computer use a random generator to pick numbers - individual results will vary\nExample Output: \nComputer chooses 5\n - | - | - | - | - | X | - | - |\nComputer chooses 6\n - | - | - | - | - | X | X | - |\nComputer chooses 7\n - | - | - | - | - | X | X | X |\nComputer chooses 7\nmove right 8\nmove right 0\n X | - | - | - | - | X | X | X |\nComputer chooses 6\nmove right 7\nmove right 8\nmove right 0\nmove right 1\n X | X | - | - | - | X | X | X |\nComputer chooses 3\n X | X | - | X | - | X | X | X |\nComputer chooses 0\nmove right 1\nmove right 2\n X | X | X | X | - | X | X | X |\nComputer chooses 5\nmove right 6\nmove right 7\nmove right 8\nmove right 0\nmove right 1\nmove right 2\nmove right 3\nmove right 4\n X | X | X | X | X | X | X | X |\n------------------------------------------------------------------------\n*/\n\nEnd Of Topic","type":"content","url":"/xarraywarparound#lecture-code","position":5},{"hierarchy":{"lvl1":"Arrays Core Functionality"},"type":"lvl1","url":"/xarrayscorefunctionality","position":0},{"hierarchy":{"lvl1":"Arrays Core Functionality"},"content":"","type":"content","url":"/xarrayscorefunctionality","position":1},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"sort(int[] SampleData, boolean printData)"},"type":"lvl2","url":"/xarrayscorefunctionality#sort-int-sampledata-boolean-printdata","position":2},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"sort(int[] SampleData, boolean printData)"},"content":"This method implements an Insertion Sort algorithm. Unlike a traditional in-place Insertion Sort, this version copies elements from the input SampleData array into a new array, SortedData, inserting each element into its correct, sorted position within the SortedData array as it iterates. The sorted array is returned. If the printData flag is true, it prints the partially sorted array after each insertion.","type":"content","url":"/xarrayscorefunctionality#sort-int-sampledata-boolean-printdata","position":3},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"reverse(int[] arr)"},"type":"lvl2","url":"/xarrayscorefunctionality#reverse-int-arr","position":4},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"reverse(int[] arr)"},"content":"This function reverses the order of elements in the given array in-place. It uses a two-pointer approach, with one pointer starting at the beginning (start) and the other at the end (end) of the array, iteratively swapping the elements they point to until the pointers meet or cross. The array itself is modified, and nothing is returned.","type":"content","url":"/xarrayscorefunctionality#reverse-int-arr","position":5},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByValue(int[] arr, int valueToDelete)"},"type":"lvl2","url":"/xarrayscorefunctionality#deletebyvalue-int-arr-int-valuetodelete","position":6},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByValue(int[] arr, int valueToDelete)"},"content":"This method finds the first occurrence of a specified valueToDelete in the array. If found, it delegates the actual deletion to the deleteByPosition function. If the value is not found, it prints a message and returns the original array unchanged. Because Java arrays have a fixed size, this function (via deleteByPosition) returns a new array that is one element shorter than the original.","type":"content","url":"/xarrayscorefunctionality#deletebyvalue-int-arr-int-valuetodelete","position":7},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByPosition(int[] theArray, int pos)"},"type":"lvl2","url":"/xarrayscorefunctionality#deletebyposition-int-thearray-int-pos","position":8},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByPosition(int[] theArray, int pos)"},"content":"This is a utility function for deleting an element at a specific index (pos). It creates a new array that is one element smaller and copies all elements from the original array into the new one, skipping the element at the specified position and shifting subsequent elements left to fill the gap. The new, smaller array is returned.","type":"content","url":"/xarrayscorefunctionality#deletebyposition-int-thearray-int-pos","position":9},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"printArray(int[] theArray, int dataLength)"},"type":"lvl2","url":"/xarrayscorefunctionality#printarray-int-thearray-int-datalength","position":10},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"printArray(int[] theArray, int dataLength)"},"content":"A simple utility function used to print the elements of an array from the beginning up to the specified dataLength.","type":"content","url":"/xarrayscorefunctionality#printarray-int-thearray-int-datalength","position":11},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"Program Execution in main"},"type":"lvl2","url":"/xarrayscorefunctionality#program-execution-in-main","position":12},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"Program Execution in main"},"content":"The main method orchestrates a demonstration of these functions using an initial data array: {9,1,8,2,7,3,6,5,3}.\n\nInsertion Sort: It first sorts the initial data, printing the array after each insertion, resulting in a sorted array: {1,2,3,3,5,6,7,8,9}.\n\nReverse: It then reverses the resulting sorted array in-place, yielding: {9,8,7,6,5,3,3,2,1}.\n\nDelete by Value: It deletes the first occurrence of the value 3 from the reversed array, returning a new array: {9,8,7,6,5,3,2,1}.\n\nDelete by Position: Finally, it deletes the element at index 2 (which is the value 7) from the array resulting from the previous step, producing the final array: {9,8,6,5,3,2,1}.package instinsertinorder;\n\npublic class InstInsertInOrder {\n\n    // Insertion-sort into a NEW array; optionally print after each insert.\n    static int[] sort(int[] SampleData, boolean printData) {\n        int[] SortedData = new int[SampleData.length];\n        int elementsSorted = 0; // size of the sorted prefix\n\n        // For each element in SampleData\n        for (int i = 0; i < SampleData.length; i++) {\n            int key = SampleData[i];\n            int j = elementsSorted - 1;\n\n            // While items > key, shift them right\n            while (j >= 0 && SortedData[j] > key) {\n                SortedData[j + 1] = SortedData[j];\n                j--;\n            }\n\n            // Insert key at correct position\n            SortedData[j + 1] = key;\n            elementsSorted++;\n\n            if (printData) // If enabled, show current sorted portion\n                printArray(SortedData, elementsSorted);\n        }\n        return SortedData;\n    }\n\n    /** Reverse array in place using two pointers. */\n    static void reverse(int[] arr) {\n        int start = 0, end = arr.length - 1;\n        while (start < end) { // While pointers haven't crossed\n            int tmp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = tmp;\n            start++; end--;\n        }\n    }\n\n    /**\n     * Delete first occurrence of value; returns NEW array (length-1).\n     * If not found, return original.\n     */\n    static int[] deleteByValue(int[] arr, int valueToDelete) {\n        int indexToDelete = -1;\n\n        // For each element, check for match\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == valueToDelete) { // Found target\n                indexToDelete = i;\n                break;\n            }\n        }\n\n        if (indexToDelete == -1) { // If value not found\n            System.out.println(\"Value \" + valueToDelete + \" not found.\");\n            return arr;\n        }\n\n        return deleteByPosition(arr, indexToDelete);\n    }\n\n    /**\n     * Delete element at index 'pos'; returns NEW array (length-1).\n     */\n    static int[] deleteByPosition(int[] theArray, int pos) {\n        int[] temp = new int[theArray.length - 1];\n\n        // Copy elements, skipping the deleted position\n        for (int i = 0; i < temp.length; i++) {\n            if (i >= pos) // If past delete index, shift left\n                temp[i] = theArray[i + 1];\n            else          // Otherwise copy directly\n                temp[i] = theArray[i];\n        }\n        return temp;\n    }\n\n    // Print first dataLength elements on one line.\n    static void printArray(int[] theArray, int dataLength) {\n        System.out.print(\"Array: \");\n        for (int i = 0; i < dataLength; i++) // Print up to given length\n            System.out.print(theArray[i] + \" \");\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int[] SampleData = {9, 1, 8, 2, 7, 3, 6, 5, 3};\n\n        System.out.println(\"--- 1. Insertion Sort  ---\");\n        int[] sortedArray = sort(SampleData, true);\n\n        System.out.println(\"\\n--- 2. Reverse Function  ---\");\n        printArray(sortedArray, sortedArray.length);\n        reverse(sortedArray);\n        System.out.print(\"Array after reverse: \");\n        printArray(sortedArray, sortedArray.length);\n\n        System.out.println(\"\\n--- 3. Delete by Value  (Value 3) ---\");\n        int[] arrayAfterValueDelete = deleteByValue(sortedArray, 3);\n        System.out.print(\"Array after deleting first '3': \");\n        printArray(arrayAfterValueDelete, arrayAfterValueDelete.length);\n\n        System.out.println(\"\\n--- 4. Delete by Position  (Index 2) ---\");\n        int[] finalArray = deleteByPosition(arrayAfterValueDelete, 2);\n        System.out.print(\"Array after deleting element \\nat index 2 (Value 7): \");\n        printArray(finalArray, finalArray.length);\n\n        System.out.println(\"\\nbye\\n\");\n    }\n}\n\n\n10/2025","type":"content","url":"/xarrayscorefunctionality#program-execution-in-main","position":13},{"hierarchy":{"lvl1":"Big O Notation"},"type":"lvl1","url":"/xbigonotation","position":0},{"hierarchy":{"lvl1":"Big O Notation"},"content":"","type":"content","url":"/xbigonotation","position":1},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Key Ideas"},"type":"lvl2","url":"/xbigonotation#key-ideas","position":2},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Key Ideas"},"content":"Big O Notation\n\nNote\n\n\n\nBig O notation is used in Computer Science to describe the performance or complexity of an algorithm. Big O specifically describes the worst-case scenario and can be used to describe the execution time required or the space used (e.g. in memory or on disk) by an algorithm. - \n\nRob Bell","type":"content","url":"/xbigonotation#key-ideas","position":3},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Reading"},"type":"lvl2","url":"/xbigonotation#reading","position":4},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Reading"},"content":"ON_Visualizing Big O Notation","type":"content","url":"/xbigonotation#reading","position":5},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Videos"},"type":"lvl2","url":"/xbigonotation#videos","position":6},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Videos"},"content":"\n\nhttps://​youtu​.be​/v4cd1O4zkGw\n\nhttps://​youtu​.be​/Q​_1M2JaijjQ\n\nEnd Of Topic","type":"content","url":"/xbigonotation#videos","position":7},{"hierarchy":{"lvl1":"Big O Notation - Explained"},"type":"lvl1","url":"/xbigonotationexplained","position":0},{"hierarchy":{"lvl1":"Big O Notation - Explained"},"content":"Note\n\n\n\nBig O notation is the language we use for talking about how long an algorithm takes to run (time complexity) or how much memory is used by an algorithm (space complexity).\n\nNote\n\n\n\nBig O notation is generally referencing worst case scenario for the algorithm","type":"content","url":"/xbigonotationexplained","position":1},{"hierarchy":{"lvl1":"Big O Notation - Explained","lvl2":"O(1) -  Constant Time"},"type":"lvl2","url":"/xbigonotationexplained#o-1-constant-time","position":2},{"hierarchy":{"lvl1":"Big O Notation - Explained","lvl2":"O(1) -  Constant Time"},"content":"O(1) means that it takes a constant time to run an algorithm, regardless of the size of the input. In programming, a lot of operations are constant.\n\nHere are some examples:\n\nmath operations\n\naccessing an array via the index\n\naccessing a hash via the key\n\npushing and popping on a stack\n\ninsertion and removal from a queue\n\nreturning a value from a functionint theArray = new int[Integer.MAX_VALUE]\n\nfor(int c = 0; c < Integer.MAX_VALUE; c++)\n{\n    // This step is O(1)\n    theArray[c] = c;\n}","type":"content","url":"/xbigonotationexplained#o-1-constant-time","position":3},{"hierarchy":{"lvl1":"Big O Notation - Explained","lvl2":"O(n) - Linear Time"},"type":"lvl2","url":"/xbigonotationexplained#o-n-linear-time","position":4},{"hierarchy":{"lvl1":"Big O Notation - Explained","lvl2":"O(n) - Linear Time"},"content":"O(n) means that the run-time increases at the rate/size as the input.// n is some integer\n\n// The for statement is 0(n)\n// if n is small, it will take less time\n// if n is very large number, it will take more time\n\nfor(int c = 0; c < n; c++)\n{\n    // This step is O(1)\n    System.out.println(c)\n}","type":"content","url":"/xbigonotationexplained#o-n-linear-time","position":5},{"hierarchy":{"lvl1":"Big O Notation - Explained","lvl2":"O(n²) -  Quadratic Time"},"type":"lvl2","url":"/xbigonotationexplained#o-n-quadratic-time","position":6},{"hierarchy":{"lvl1":"Big O Notation - Explained","lvl2":"O(n²) -  Quadratic Time"},"content":"O(n^2^) means that the calculation runs in quadratic time.\n\nExamples of algorithms having worst-case run times of  O(n^2^):\n\nBubble Sort\n\nInsertion Sort\n\nSelection Sort\n\nTip\n\nThe general pattern is a for statement within a for statement// Bubble Sort\n\n/*\n * Programmer: James Goudy\n * Project: Bubble Sort\n */\npackage com.mycompany.bubblesort_lecturecode;\n\nimport java.util.Random;\n\nclass BubbleSort {\n\n    // arrInt is an array of integers\n    // numDataElements is the actual count \n    // of elements of data in the array\n    // algorithm assumes the data is contiguous\n    int arrInt[];\n    int numDataElments;\n\n    public BubbleSort(int[] arrInt, int numDataElments) {\n        this.arrInt = arrInt;\n        this.numDataElments = numDataElments;\n    }\n\n    public void Sort() {\n        // \n        int n = numDataElments;\n\n        for (int c = 0; c < n; c++) {\n            for (int j = 1; j < (n); j++) {\n                \n                // check if the left element is \n                // greater to the one on the right\n                // \"Bubble\" the lowest to the left\n\n                if (arrInt[j - 1] > arrInt[j]) {\n                    // swap left element arr[j-1]\n                    // with the one on the right and arr[j]\n                    \n                    // store left one in temp\n                    int temp = arrInt[j - 1];\n                    //copy the right into the left\n                    arrInt[j - 1] = arrInt[j];\n                    //copy the left into the right\n                    arrInt[j] = temp;\n                }\n            }\n        }\n    }\n\n}\n\npublic class BubbleSort_LectureCode {\n\n    static int arrSize = 8;\n    //static int theArray[] = new int[arrSize];\n    static int theArray[] ={3,60,35,2,45,320,5,1}; \n    \n    static void fillTheArray()\n    {\n        Random RNG  = new Random();\n        for(int c = 0; c < arrSize; c++)\n        {\n            theArray[c] = RNG.nextInt(0,(arrSize*10));\n        }\n    }\n    \n    static void printArray(int anArray[], int numOfDataElements)\n    {\n        System.out.println(\"\");\n        for (int i = 0; i < numOfDataElements; i++) {\n            System.out.print(anArray[i] + \" \");\n        }\n        System.out.println(\"\\n--------------\\n\");\n        \n    }\n    \n    public static void main(String[] args) {\n       \n        // option to randomly fill the array\n        //fillTheArray();\n        \n        printArray(theArray, arrSize);\n        \n        BubbleSort bs = new BubbleSort(theArray, arrSize);\n        bs.Sort();\n        \n        printArray(theArray, arrSize);\n    \n    }\n}\n\n/*\n3 60 35 2 45 320 5 1 \n--------------\n\n\n1 2 3 5 35 45 60 320 \n--------------\n*/\n\nhttps://​betterprogramming​.pub​/big​-o​-notation​-a​-simple​-explanation​-with​-examples​-a56347d1daca\n\nEnd Of Topic","type":"content","url":"/xbigonotationexplained#o-n-quadratic-time","position":7},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class"},"type":"lvl1","url":"/xcircularlinkedlist","position":0},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class"},"content":"","type":"content","url":"/xcircularlinkedlist","position":1},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Key Ideas"},"type":"lvl2","url":"/xcircularlinkedlist#key-ideas","position":2},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Key Ideas"},"content":"The doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nIn a circular doubly-linked list the last node (next) points to the first. The first node (previous) points to the last node.\n\nThe doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nNote\n\nNot all languages support subclasses.","type":"content","url":"/xcircularlinkedlist#key-ideas","position":3},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Lecture Code"},"type":"lvl2","url":"/xcircularlinkedlist#lecture-code","position":4},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Lecture Code"},"content":"package com.mycompany.linkedlistcircular;\n\n/*\n * Programmer: James Goudy\n * Project Circular LinkedList\n *\n * NOTE: last link is referenced as first.prev\n */\nclass CircularLinkedList {\n\n    Link first = new Link(\"\");\n\n    // ---------------------------------\n    // sub class - Link / Nodes\n    // NOTE: this can be a separate class as well\n    class Link {\n\n        Link first = null;\n\n        // data\n        String city = null;\n\n        // link navigation\n        Link next = null;\n        Link prev = null;\n\n        // constructor\n        Link(String city) {\n            this.city = city;\n            this.next = null;\n            this.prev = null;\n        }\n\n        public void displayNode() {\n            System.out.print(city + \" \");\n        }\n    } // end of link\n    // ---------------------------------\n\n    // constructor\n    public CircularLinkedList() {\n\n        first = null;\n    }\n\n    // add link at the beginning of the list\n    public boolean addFirst(String city) {\n\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            // empty list\n            newLink.next = newLink;\n            newLink.prev = newLink;\n\n            first = newLink;\n\n        } else {\n\n            // connect the newLink references\n            newLink.next = first;\n\n            newLink.prev = first.prev;\n\n            first.prev = newLink;\n\n            // move first to the new link\n            first = newLink;\n\n            // point the last link to the new first\n            first.prev.next = first;\n\n        }\n\n        return true;\n    }\n\n    // add link to the end of the list\n    public boolean addLast(String city) {\n\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            //list is empty\n            first = newLink;\n        } else {\n            // set new link references\n            newLink.next = first;\n\n            newLink.prev = first.prev;\n\n            // last link is (first.prev)\n            first.prev.next = newLink;\n\n            first.prev = newLink;\n\n        }\n\n        return true;\n    }\n\n    public boolean findCity(String citySearch) {\n\n        if (first == null) {\n\n            // if list is empty\n            return false;\n        } else {\n            Link current = first;\n\n            do {\n                if (current.city.equals(citySearch)) {\n                    return true;\n                }\n                current = current.next;\n\n            } while (current != first);\n\n            return false;\n        }\n    }\n\n    public boolean insertAfter(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check if last link\n                    if (current.next == first.prev) {\n                        // check if last link\n                        current.next = newLink;\n                        newLink.prev = current;\n\n                        first.prev = newLink;\n\n                    } else {\n                        newLink.next = current.next;\n                        newLink.prev = current;\n\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n\n    }\n\n    public boolean insertBefore(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check for first link\n                    if (current.prev == null) {\n                        // check if last link\n                        current.prev = newLink;\n                        newLink.next = current;\n\n                        first = newLink;\n\n                    } else {\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n    }\n\n    public boolean deleteCity(String citySearch) {\n\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            do {\n                if (current.city.equals(citySearch)) {\n\n                    if (current.prev == null) {\n                        // first node\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true;\n                    } else if (current.next == null) {\n                        // last node\n                        current.prev.next = null;\n                        first.prev = current;\n                        current = null;\n                        return true;\n                    } else {\n                        // a center node\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n\n                        return true;\n                    }\n                }\n\n                current = current.next;\n            } while (current != first);\n\n            return false;\n        }\n    } //end of function\n\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\\n** Display List Forward To Back **\");\n\n        do {\n            current.displayNode();\n            current = current.next;\n            if (current == first) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.next != null);\n\n    } // end of method\n\n    public void displayList(String startCity) {\n\n        Link current = first;\n        Link start = null;\n\n        System.out.println(\"\\n ** Display List Forward To Back\"\n                + \" starting at \" + startCity + \"**\");\n\n        // find the city in the list\n        do {\n            if (current.city.equals(startCity)) {\n                break;\n            }\n\n            current = current.next;\n\n            if (current == first) {\n                System.out.println(\"City Not Found\");\n                return;\n            }\n\n        } while (current.next != null);\n\n        System.out.println(\"\");\n\n        start = current;\n\n        do {\n            current.displayNode();\n            current = current.next;\n            if (current == start) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.next != null);\n\n    } // end of method\n\n    public void displayListReverse() {\n\n        Link current = first.prev;\n\n        System.out.println(\"\\n** Display List in Reverse **\\n\");\n\n        do {\n            current.displayNode();\n            current = current.prev;\n            if (current == first.prev) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.prev != null);\n    } // end of method\n\n    public void displayListReverse(String startCity) {\n\n        Link current = first;\n        Link start = null;\n\n        System.out.println(\"\\n ** Display list in reverse\"\n                + \" starting at \" + startCity + \"**\");\n\n        // find the city in the list\n        do {\n            if (current.city.equals(startCity)) {\n                break;\n            }\n\n            current = current.next;\n\n            if (current == first) {\n                System.out.println(\"City Not Found\");\n                return;\n            }\n\n        } while (current.next != null);\n\n        System.out.println(\"\");\n\n        start = current;\n\n        do {\n            current.displayNode();\n            current = current.prev;\n            if (current == start) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.prev != null);\n    } // end of method\n\n} // end of class\n\npublic class DS_LinkedListCircular {\n\n    static CircularLinkedList dl = new CircularLinkedList();\n\n    public static void citySearch(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.findCity(searchCity)) {\n            System.out.println(\"\\n\" + searchCity + \" is in list\");\n        } else {\n            System.out.println(\"\\n\" + searchCity + \" not found\");\n        }\n\n    }\n\n    public static void deleteCity(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.deleteCity(searchCity)) {\n            System.out.println(searchCity + \" was deleted\");\n        } else {\n            System.out.println(searchCity + \" was NOT deleted\");\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        String searchCity = \"\";\n        String insertCity = \"\";\n\n        // insert data at front of list\n        dl.addFirst(\"Kali\");\n        dl.addFirst(\"Polson\");\n        dl.addFirst(\"Missoula\");\n        dl.addFirst(\"Whitefish\");\n        dl.addFirst(\"Plains\");\n\n        // insert data at end of list\n        dl.addLast(\"Chicago\");\n        dl.addLast(\"Denver\");\n        dl.addLast(\"Sandiego\");\n\n        dl.displayList();\n        dl.displayListReverse();\n\n        dl.displayList(\"Missoula\");\n        dl.displayList(\"Wolfcreek\");\n\n        dl.displayListReverse();\n        dl.displayListReverse(\"Missoula\");\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        citySearch(searchCity);\n\n        searchCity = \"Bozeman\";\n        citySearch(searchCity);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchCity = \"Polson\";\n        deleteCity(searchCity);\n\n        searchCity = \"Bozeman\";\n        deleteCity(searchCity);\n\n        searchCity = \"Sandiego\";\n        deleteCity(searchCity);\n\n        searchCity = \"Whitefish\";\n        deleteCity(searchCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Insert After Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        insertCity = \"Dayton\";\n        dl.insertAfter(searchCity, insertCity);\n\n        searchCity = \"Denver\";\n        insertCity = \"Boulder\";\n        dl.insertAfter(searchCity, insertCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Insert After Examples------\\n\");\n\n        searchCity = \"Chicago\";\n        insertCity = \"Springfield\";\n        dl.insertBefore(searchCity, insertCity);\n\n        searchCity = \"Missoula\";\n        insertCity = \"Libby\";\n        dl.insertBefore(searchCity, insertCity);\n\n        dl.displayList();\n        System.out.println(\"\\nbye\");\n    }\n}\n/*\n * output\n *\n ** Display List Forward To Back **\n * Plains Whitefish Missoula Polson Kali Chicago Denver Sandiego\n * -----------\n *\n *\n ** Display List in Reverse **\n *\n * Sandiego Denver Chicago Kali Polson Missoula Whitefish Plains\n * -----------\n *\n *\n ** Display List Forward To Back starting at Missoula**\n *\n * Missoula Polson Kali Chicago Denver Sandiego Plains Whitefish\n * -----------\n *\n *\n ** Display List Forward To Back starting at Wolfcreek**\n * City Not Found\n *\n ** Display List in Reverse **\n *\n * Sandiego Denver Chicago Kali Polson Missoula Whitefish Plains\n * -----------\n *\n *\n ** Display list in reverse starting at Missoula**\n *\n * Missoula Whitefish Plains Sandiego Denver Chicago Kali Polson\n * -----------\n *\n *\n * ----- Find Examples------\n *\n *\n * Missoula is in list\n *\n * Bozeman not found\n *\n * ----- Delete Examples------\n *\n * Polson was deleted\n * Bozeman was NOT deleted\n * Sandiego was deleted\n * Whitefish was deleted\n *\n ** Display List Forward To Back **\n * Plains Missoula Kali Chicago Denver\n * -----------\n *\n *\n * ----- Insert After Examples------\n *\n *\n ** Display List Forward To Back **\n * Plains Missoula Dayton Kali Chicago Denver Boulder\n * -----------\n *\n *\n * ----- Insert After Examples------\n *\n *\n ** Display List Forward To Back **\n * Plains Libby Missoula Dayton Kali Springfield Chicago Denver Boulder\n * -----------\n *\n *\n * bye\n *\n */\n\n\nEnd Of Topic","type":"content","url":"/xcircularlinkedlist#lecture-code","position":5},{"hierarchy":{"lvl1":"Data Structures and Algorithms"},"type":"lvl1","url":"/xdatastructuresandalgorithms","position":0},{"hierarchy":{"lvl1":"Data Structures and Algorithms"},"content":"","type":"content","url":"/xdatastructuresandalgorithms","position":1},{"hierarchy":{"lvl1":"Data Structures and Algorithms","lvl2":"Textbooks and Online Sources"},"type":"lvl2","url":"/xdatastructuresandalgorithms#textbooks-and-online-sources","position":2},{"hierarchy":{"lvl1":"Data Structures and Algorithms","lvl2":"Textbooks and Online Sources"},"content":"\n\nData Structures and Algorithms in Java\nSecond Edition\nRobert Lafore\n\nData Structures and Algorithms in Java 6th Edition\nMichael T. Goodrich\n\nAlgorithms (4th Edition) 4th Edition by Robert Sedgewick and Kevin Wayne\n\nOpen Data Structures    |\n\nEnd Of Topic","type":"content","url":"/xdatastructuresandalgorithms#textbooks-and-online-sources","position":3},{"hierarchy":{"lvl1":"Doubly Linked List"},"type":"lvl1","url":"/xdoublylinkedlist","position":0},{"hierarchy":{"lvl1":"Doubly Linked List"},"content":"","type":"content","url":"/xdoublylinkedlist","position":1},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Key Ideas"},"type":"lvl2","url":"/xdoublylinkedlist#key-ideas","position":2},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Key Ideas"},"content":"The doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nA doubly linked list is a type of linked list in which each node contains three parts:\n\nData: The value stored in the node.\n\nPointer to the next node: A reference to the next node in the list.\n\nPointer to the previous node: A reference to the previous node in the list.","type":"content","url":"/xdoublylinkedlist#key-ideas","position":3},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Structure:","lvl2":"Key Ideas"},"type":"lvl3","url":"/xdoublylinkedlist#structure","position":4},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Structure:","lvl2":"Key Ideas"},"content":"In a doubly linked list, each node is connected to both its next and previous nodes, creating a two-way linkage.\n\nThe first node (head) has its previous pointer set to null, and the last node (tail) has its next pointer set to null.","type":"content","url":"/xdoublylinkedlist#structure","position":5},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Benefits of a Doubly Linked List:","lvl2":"Key Ideas"},"type":"lvl3","url":"/xdoublylinkedlist#benefits-of-a-doubly-linked-list","position":6},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Benefits of a Doubly Linked List:","lvl2":"Key Ideas"},"content":"Bidirectional Traversal: You can easily traverse the list in both forward and backward directions.\n\nEfficient Deletion: Insertion and deletion of nodes can be more efficient since you can easily access the previous node.","type":"content","url":"/xdoublylinkedlist#benefits-of-a-doubly-linked-list","position":7},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Lecture Code"},"type":"lvl2","url":"/xdoublylinkedlist#lecture-code","position":8},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Lecture Code"},"content":"/*\n * Programmer: James Goudy\n * Project: Doubly Linked List \n */\n\n// Define a class representing each link/node in the doubly linked list\nclass Link {\n\n    // Pointers for the first and last nodes in the list\n    Link first = null;\n    Link last = null;\n\n    // Data stored in the node\n    String city = null;\n\n    // Pointers for the next and previous nodes\n    Link next = null;\n    Link prev = null;\n\n    // Constructor to initialize a node with the city name\n    Link(String city) {\n        this.city = city;\n        this.next = null;\n        this.prev = null;\n    }\n\n    // Display the data of the current node\n    public void displayNode() {\n        System.out.print(city + \" \");\n    }\n} // End of Link class\n\n// Define a class representing the doubly linked list itself\nclass Doubly {\n\n    // References to the first and last nodes in the list\n    Link first = null;\n    Link last = null;\n\n    // Constructor to initialize an empty doubly linked list\n    public Doubly() {\n        first = null;\n        last = null;\n    }\n\n    // Method to add a node at the beginning of the list\n    public boolean addFirst(String city) {\n        Link newLink = new Link(city);\n\n        // If list is empty, set first and last to the new node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            // Otherwise, update pointers for the new node and the current first node\n            newLink.next = first;\n            first.prev = newLink;\n            first = newLink;\n        }\n\n        return true;\n    }\n\n    // Method to add a node at the end of the list\n    public boolean addLast(String city) {\n        Link newLink = new Link(city);\n\n        // If list is empty, set first and last to the new node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            // Otherwise, update pointers for the new node and the current last node\n            newLink.prev = last;\n            last.next = newLink;\n            last = newLink;\n        }\n\n        return true;\n    }\n\n    // Method to find a city in the list\n    public boolean findCity(String citySearch) {\n\n        // If list is empty, return false\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            // Traverse the list to search for the city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n                    return true; // City found\n                }\n                current = current.next;\n            }\n\n            return false; // City not found\n        }\n    }\n\n    // Method to insert a new node after a given city\n    public boolean insertAfter(String citySearch, String insertCity) {\n        Link newLink = new Link(insertCity);\n\n        // If list is empty, add the new node as the only node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            Link current = first;\n\n            // Traverse the list to find the specified city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // If the city is the last node, update last\n                    if (current.next == null) {\n                        current.next = newLink;\n                        newLink.prev = current;\n                        last = newLink;\n                    } else {\n                        // Update pointers for inserting in the middle\n                        newLink.next = current.next;\n                        newLink.prev = current;\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true; // City inserted\n                }\n                current = current.next;\n            }\n        }\n\n        return false; // City not found\n    }\n\n    // Method to insert a new node before a given city\n    public boolean insertBefore(String citySearch, String insertCity) {\n        Link newLink = new Link(insertCity);\n\n        // If list is empty, add the new node as the only node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            Link current = first;\n\n            // Traverse the list to find the specified city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // If the city is the first node, update first\n                    if (current.prev == null) {\n                        current.prev = newLink;\n                        newLink.next = current;\n                        first = newLink;\n                    } else {\n                        // Update pointers for inserting in the middle\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true; // City inserted\n                }\n                current = current.next;\n            }\n        }\n\n        return false; // City not found\n    }\n\n    // Method to delete a node with a specified city\n    public boolean deleteCity(String citySearch) {\n\n        // If list is empty, return false\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            // Traverse the list to find the specified city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // If the city is the first node\n                    if (current.prev == null) {\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true; // City deleted\n                    } else if (current.next == null) {\n                        // If the city is the last node\n                        current.prev.next = null;\n                        last = current.prev;\n                        current = null;\n                        return true; // City deleted\n                    } else {\n                        // If the city is in the middle\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n                        return true; // City deleted\n                    }\n                }\n                current = current.next;\n            }\n\n            return false; // City not found\n        }\n    }\n\n    // Method to display the entire list\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode(); // Display each node\n            current = current.next; // Move to next node\n        }\n        System.out.println(\"\");\n    }\n}\n\n// Main class to demonstrate doubly linked list functionality\npublic class DS_DoublyLinkedList {\n\n    // Create an instance of the Doubly linked list\n    static Doubly dl = new Doubly();\n\n    // Method to search for a city\n    public static void citySearch(String searchCity) {\n        if (dl.findCity(searchCity)) {\n            System.out.println(\"\\n\" + searchCity + \" is in the list\");\n        } else {\n            System.out.println(\"\\n\" + searchCity + \" not found\");\n        }\n    }\n\n    // Method to delete a city\n    public static void deleteCity(String searchCity) {\n        if (dl.deleteCity(searchCity)) {\n            System.out.println(searchCity + \" was deleted\");\n        } else {\n            System.out.println(searchCity + \" was NOT deleted\");\n        }\n    }\n\n    // Main method to execute the program\n    public static void main(String[] args) {\n\n        String searchCity = \"\";\n        String insertCity = \"\";\n\n        // Insert data at the front of the list\n        dl.addFirst(\"Kali\");\n        dl.addFirst(\"Polson\");\n        dl.addFirst(\"Missoula\");\n        dl.addFirst(\"Whitefish\");\n\n        // Insert data at the end of the list\n        dl.addLast(\"Chicago\");\n        dl.addLast(\"Denver\");\n        dl.addLast(\"Sandiego\");\n\n        dl.displayList(); // Display the list\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchCity = \"Chicago\";\n        citySearch(searchCity);\n\n        searchCity = \"Bozeman\";\n        citySearch(searchCity);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchCity = \"Polson\";\n        deleteCity(searchCity);\n\n        searchCity = \"Bozeman\";\n        deleteCity(searchCity);\n\n        searchCity = \"Sandiego\";\n        deleteCity(searchCity);\n\n        searchCity = \"Whitefish\";\n        deleteCity(searchCity);\n\n        dl.displayList(); // Display the list\n\n        System.out.println(\"\\n----- Insert Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        insertCity = \"Dayton\";\n        dl.insertAfter(searchCity, insertCity);\n\n        searchCity = \"Denver\";\n        insertCity = \"Boulder\";\n        dl.insertAfter(searchCity, insertCity);\n\n        dl.displayList(); // Display the list\n\n        searchCity = \"Chicago\";\n        insertCity = \"Springfield\";\n        dl.insertBefore(searchCity, insertCity);\n\n        searchCity = \"Missoula\";\n        insertCity = \"Libby\";\n        dl.insertBefore(searchCity, insertCity);\n\n        dl.displayList(); // Display the list\n\n        System.out.println(\"\\nbye\");\n    }\n}\n\n/*\n * OUTPUT  *\n * Whitefish Missoula Polson Kali Chicago Denver Sandiego  *\n * ----- Find Examples------\n *\n *\n * Chicago is in list\n *\n * Bozeman not found\n *\n * ----- Delete Examples------\n *\n * Polson was deleted\n * Bozeman was NOT deleted\n * Sandiego was deleted\n * Whitefish was deleted\n *\n * Missoula Kali Chicago Denver  *\n * ----- Insert Examples------\n *\n *\n * Missoula Dayton Kali Chicago Denver Boulder  *\n * Libby Missoula Dayton Kali Springfield Chicago Denver Boulder  *\n * bye\n *\n */\n\n\n\nEnd Of Topic","type":"content","url":"/xdoublylinkedlist#lecture-code","position":9},{"hierarchy":{"lvl1":"C# Linked List Class"},"type":"lvl1","url":"/xdoublylinkedlistcsharp","position":0},{"hierarchy":{"lvl1":"C# Linked List Class"},"content":"Here’s the revised version, adding information about ArrayList in Section 3:","type":"content","url":"/xdoublylinkedlistcsharp","position":1},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"1. What is a Linked List?"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-1-what-is-a-linked-list","position":2},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"1. What is a Linked List?"},"content":"A linked list is a data structure used to store a sequence of elements, where each element is called a node. In the case of a doubly linked list:\n\nData: Each node contains the data or value.\n\nPointers: Each node has two pointers—one pointing to the next node and one pointing to the previous node.\n\nC# has a built-in generic LinkedList<T> class that represents a doubly linked list, supporting dynamic memory allocation and efficient insertions and deletions.","type":"content","url":"/xdoublylinkedlistcsharp#id-1-what-is-a-linked-list","position":3},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"2. Real-Life Applications of Linked Lists"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-2-real-life-applications-of-linked-lists","position":4},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"2. Real-Life Applications of Linked Lists"},"content":"Music Playlists: Linked lists can manage playlists, where songs can be accessed or rearranged using the next and previous pointers.\n\nUndo Functionality in Applications: Applications like text editors can use linked lists to maintain a history of changes.\n\nWeb Browser History: Browsers can use linked lists to manage navigation history, allowing forward and backward traversal.\n\nDynamic Memory Allocation: Operating systems can use linked lists to manage memory blocks, making memory allocation and deallocation efficient.\n\nAdjacency Lists in Graphs: In graphs, adjacency lists are often implemented using linked lists for efficient traversal of vertices and edges.","type":"content","url":"/xdoublylinkedlistcsharp#id-2-real-life-applications-of-linked-lists","position":5},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"3. ArrayList vs. LinkedList"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-3-arraylist-vs-linkedlist","position":6},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"3. ArrayList vs. LinkedList"},"content":"C# provides two main collections that can be used to manage dynamic sequences of elements: ArrayList and LinkedList<T>. Here’s a comparison:\n\nFeature\n\nArrayList\n\nLinkedList (C#)\n\nUnderlying Data Structure\n\nResizable array\n\nDoubly linked list\n\nMemory Allocation\n\nContiguous (requires resizing)\n\nNon-contiguous (nodes can be scattered)\n\nAccess Time\n\nO(1) for index-based access\n\nO(n) (must traverse nodes)\n\nInsertion/Deletion\n\nO(n) for shifting elements\n\nO(1) at ends; O(n) for middle\n\nMemory Overhead\n\nLess (just array)\n\nMore (extra pointers for each node)\n\nSearch Complexity\n\nO(n) (linear search)\n\nO(n) (linear search)\n\nThread Safety\n\nNot synchronized (not thread-safe)\n\nNot synchronized (not thread-safe)","type":"content","url":"/xdoublylinkedlistcsharp#id-3-arraylist-vs-linkedlist","position":7},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Key Differences:","lvl2":"3. ArrayList vs. LinkedList"},"type":"lvl3","url":"/xdoublylinkedlistcsharp#key-differences","position":8},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Key Differences:","lvl2":"3. ArrayList vs. LinkedList"},"content":"Access Speed:\n\nArrayList provides faster access due to contiguous memory allocation, allowing elements to be accessed directly via index.\n\nLinkedList<T> requires traversal from the head to access an element by index, making it slower for random access.\n\nInsertion and Deletion:\n\nArrayList has slower insertion and deletion times (O(n) in the worst case) because elements need to be shifted.\n\nLinkedList<T> excels in insertions and deletions at both ends (O(1)), making it ideal for scenarios where these operations are frequent.\n\nMemory Usage:\n\nArrayList typically uses less memory since it only stores the elements.\n\nLinkedList<T> uses more memory due to the extra pointers needed for each node.","type":"content","url":"/xdoublylinkedlistcsharp#key-differences","position":9},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Use Cases:","lvl2":"3. ArrayList vs. LinkedList"},"type":"lvl3","url":"/xdoublylinkedlistcsharp#use-cases","position":10},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Use Cases:","lvl2":"3. ArrayList vs. LinkedList"},"content":"ArrayList: Better suited for scenarios where fast access to elements is needed and the size of the data structure is stable or grows infrequently.\n\nLinkedList: Ideal for applications that require frequent insertions and deletions, such as queues, stacks, and dynamic data management.","type":"content","url":"/xdoublylinkedlistcsharp#use-cases","position":11},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"4. Use Cases"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-4-use-cases","position":12},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"4. Use Cases"},"content":"ArrayList: Best for fast access and stable size.\n\nLinkedList: Ideal for scenarios involving frequent insertions and deletions, particularly at the ends.","type":"content","url":"/xdoublylinkedlistcsharp#id-4-use-cases","position":13},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"5. C# Linked List Methods"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-5-c-linked-list-methods","position":14},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"5. C# Linked List Methods"},"content":"Here’s a breakdown of common methods in the C# LinkedList<T> class:\n\nC# Method\n\nDescription\n\nAddLast(T value)\n\nAdds an element to the end of the list.\n\nAddFirst(T value)\n\nAdds an element at the start of the list.\n\nRemove(T value)\n\nRemoves the first occurrence of the specified element.\n\nRemoveFirst()\n\nRemoves and returns the first element.\n\nRemoveLast()\n\nRemoves and returns the last element.\n\nCount\n\nReturns the number of elements in the list.","type":"content","url":"/xdoublylinkedlistcsharp#id-5-c-linked-list-methods","position":15},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"6. Demo Code"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-6-demo-code","position":16},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"6. Demo Code"},"content":"Here’s a C# code example that performs basic operations with LinkedList<T>:using System;\nusing System.Collections.Generic;\n\npublic class LinkedListDemo\n{\n    public static void Main(string[] args)\n    {\n        // Create a LinkedList\n        LinkedList<string> list = new LinkedList<string>();\n\n        // Add elements to the LinkedList\n        list.AddLast(\"Apple\");\n        list.AddLast(\"Banana\");\n        list.AddLast(\"Cherry\");\n        list.AddFirst(\"Mango\");\n        list.AddLast(\"Orange\");\n\n        // Display the LinkedList\n        Console.WriteLine(\"Initial LinkedList: \" + string.Join(\", \", list));\n\n        // Access elements in the LinkedList\n        Console.WriteLine(\"First element: \" + list.First.Value);\n        Console.WriteLine(\"Last element: \" + list.Last.Value);\n\n        // Check the size of the LinkedList\n        Console.WriteLine(\"Size of LinkedList: \" + list.Count);\n\n        // Remove elements from the LinkedList\n        list.RemoveFirst();\n        list.RemoveLast();\n        list.Remove(\"Banana\");\n\n        // Display the LinkedList after removals\n        Console.WriteLine(\"LinkedList after removals: \" + string.Join(\", \", list));\n\n        // Check if LinkedList contains a specific element\n        if (list.Contains(\"Cherry\"))\n        {\n            Console.WriteLine(\"LinkedList contains Cherry\");\n        }\n        else\n        {\n            Console.WriteLine(\"LinkedList does not contain Cherry\");\n        }\n\n        // Clear the LinkedList\n        list.Clear();\n        Console.WriteLine(\"LinkedList after clearing: \" + (list.Count == 0 ? \"Empty\" : string.Join(\", \", list)));\n    }\n}","type":"content","url":"/xdoublylinkedlistcsharp#id-6-demo-code","position":17},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"7. Iterator with LinkedList in C#"},"type":"lvl2","url":"/xdoublylinkedlistcsharp#id-7-iterator-with-linkedlist-in-c","position":18},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"7. Iterator with LinkedList in C#"},"content":"Iterators allow sequential traversal through a linked list in C#, facilitating the processing of each element.","type":"content","url":"/xdoublylinkedlistcsharp#id-7-iterator-with-linkedlist-in-c","position":19},{"hierarchy":{"lvl1":"C# Linked List Class","lvl4":"Example Code Using Iterator with LinkedList:","lvl2":"7. Iterator with LinkedList in C#"},"type":"lvl4","url":"/xdoublylinkedlistcsharp#example-code-using-iterator-with-linkedlist","position":20},{"hierarchy":{"lvl1":"C# Linked List Class","lvl4":"Example Code Using Iterator with LinkedList:","lvl2":"7. Iterator with LinkedList in C#"},"content":"using System;\nusing System.Collections.Generic;\n\npublic class LinkedListIteratorDemo\n{\n    public static void Main(string[] args)\n    {\n        LinkedList<string> list = new LinkedList<string>(new[] { \"Apple\", \"Banana\", \"Cherry\", \"Mango\" });\n\n        // Get an enumerator for the LinkedList\n        var enumerator = list.GetEnumerator();\n\n        Console.WriteLine(\"Traversing the LinkedList:\");\n        while (enumerator.MoveNext())\n        {\n            string element = enumerator.Current;\n            Console.WriteLine(element);\n\n            // Remove \"Banana\" during iteration\n            if (element == \"Banana\")\n            {\n                list.Remove(element);\n                Console.WriteLine(\"\\\"Banana\\\" has been removed\");\n            }\n        }\n\n        // Display the LinkedList after iteration\n        Console.WriteLine(\"\\nLinkedList after iteration: \" + string.Join(\", \", list));\n    }\n}","type":"content","url":"/xdoublylinkedlistcsharp#example-code-using-iterator-with-linkedlist","position":21},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"8. Why Use an Iterator with LinkedList in C#?","lvl2":"7. Iterator with LinkedList in C#"},"type":"lvl3","url":"/xdoublylinkedlistcsharp#id-8-why-use-an-iterator-with-linkedlist-in-c","position":22},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"8. Why Use an Iterator with LinkedList in C#?","lvl2":"7. Iterator with LinkedList in C#"},"content":"Efficient Traversal: Iterators (or enumerators) provide an efficient way to traverse through linked list nodes.\n\nModification During Traversal: Enumerators allow safe modification of elements during traversal, making them useful for dynamic data handling.","type":"content","url":"/xdoublylinkedlistcsharp#id-8-why-use-an-iterator-with-linkedlist-in-c","position":23},{"hierarchy":{"lvl1":"Java Linked List Class"},"type":"lvl1","url":"/xdoublylinkedlistjava","position":0},{"hierarchy":{"lvl1":"Java Linked List Class"},"content":"","type":"content","url":"/xdoublylinkedlistjava","position":1},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"What is a Linked List?"},"type":"lvl2","url":"/xdoublylinkedlistjava#what-is-a-linked-list","position":2},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"What is a Linked List?"},"content":"A linked list is a data structure used to store a collection of elements (nodes). Each node contains two parts:\n\nData: The actual value or information.\n\nPointer (or Reference): A link to the next node in the sequence (and optionally, a link to the previous node in the case of doubly linked lists).\n\nLinked lists allow for dynamic memory allocation and efficient insertions and deletions since nodes can be added or removed without reorganizing the entire structure. Unlike arrays, linked lists do not require a contiguous block of memory, making them more flexible.","type":"content","url":"/xdoublylinkedlistjava#what-is-a-linked-list","position":3},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Real-Life Applications of Linked Lists"},"type":"lvl2","url":"/xdoublylinkedlistjava#real-life-applications-of-linked-lists","position":4},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Real-Life Applications of Linked Lists"},"content":"Music Playlists:\n\nA music player can use a linked list to manage a playlist. Each song can be a node, and the player can easily move forward or backward through the playlist (using next and previous pointers), allowing for easy manipulation of the song order.\n\nUndo Functionality in Applications:\n\nMany applications, like text editors, implement an undo feature using a linked list. Each action can be stored as a node in the list, allowing users to navigate backward through their actions and revert to previous states.\n\nWeb Browser History:\n\nBrowsers use linked lists to maintain the history of visited pages. Each page can be a node, and users can navigate forward and backward through their browsing history easily.\n\nDynamic Memory Allocation:\n\nOperating systems often use linked lists for managing memory. For instance, free memory blocks can be stored as nodes, allowing the OS to allocate and deallocate memory efficiently as processes start and finish.\n\nAdjacency Lists in Graphs:\n\nIn graph data structures, linked lists are often used to represent adjacency lists. Each node in the list represents a vertex, and its linked nodes represent the edges connecting to other vertices, allowing for efficient traversal of graph data.\n\nThese applications highlight the versatility and efficiency of linked lists in various scenarios, particularly where dynamic data management is essential.","type":"content","url":"/xdoublylinkedlistjava#real-life-applications-of-linked-lists","position":5},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"ArrayList vs. LinkedList"},"type":"lvl2","url":"/xdoublylinkedlistjava#arraylist-vs-linkedlist","position":6},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"ArrayList vs. LinkedList"},"content":"Feature\n\nArrayList\n\nLinkedList\n\nUnderlying Data Structure\n\nResizable array\n\nDoubly linked list\n\nMemory Allocation\n\nContiguous memory (requires resizing when full)\n\nNon-contiguous memory (nodes can be scattered)\n\nAccess Time\n\nO(1) for index-based access\n\nO(n) for index-based access (must traverse nodes)\n\nInsertion/Deletion\n\nO(n) in the worst case (shifting elements needed)\n\nO(1) for adding/removing at ends; O(n) for middle (traversal needed)\n\nMemory Overhead\n\nLess overhead (just the array)\n\nMore overhead (extra pointers for each node)\n\nPerformance for Large Data\n\nBetter for large datasets with frequent access\n\nBetter for large datasets with frequent insertions/deletions\n\nSearch Complexity\n\nO(n) (linear search)\n\nO(n) (linear search)\n\nThread Safety\n\nNot synchronized (not thread-safe by default)\n\nNot synchronized (not thread-safe by default)\n\nUse Cases\n\nBest for frequent access, fewer insertions/deletions\n\nBest for frequent insertions/deletions, less access\n\nIteration\n\nFaster for sequential access due to locality of reference\n\nSlower for sequential access (due to pointers)","type":"content","url":"/xdoublylinkedlistjava#arraylist-vs-linkedlist","position":7},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Summary of Key Differences","lvl2":"ArrayList vs. LinkedList"},"type":"lvl3","url":"/xdoublylinkedlistjava#summary-of-key-differences","position":8},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Summary of Key Differences","lvl2":"ArrayList vs. LinkedList"},"content":"Access Speed:\n\nArrayList allows for faster access due to its contiguous memory allocation. You can directly access any element via its index.\n\nLinkedList requires traversal from the head to access an element by index, making it slower for random access.\n\nInsertion and Deletion:\n\nArrayList has slower insertion and deletion times (O(n) in the worst case) because elements may need to be shifted.\n\nLinkedList excels in insertions and deletions at both ends (O(1)), making it ideal for scenarios where these operations are frequent.\n\nMemory Usage:\n\nArrayList typically uses less memory per element since it only stores the elements.\n\nLinkedList uses more memory due to the extra pointers needed for each node.","type":"content","url":"/xdoublylinkedlistjava#summary-of-key-differences","position":9},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Use Cases","lvl2":"ArrayList vs. LinkedList"},"type":"lvl3","url":"/xdoublylinkedlistjava#use-cases","position":10},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Use Cases","lvl2":"ArrayList vs. LinkedList"},"content":"ArrayList: Ideal for scenarios where you need fast access to elements and the size of the data structure is stable or grows infrequently.\n\nLinkedList: Better suited for applications that involve frequent insertions and deletions, such as queues or stacks.","type":"content","url":"/xdoublylinkedlistjava#use-cases","position":11},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Conclusion","lvl2":"ArrayList vs. LinkedList"},"type":"lvl3","url":"/xdoublylinkedlistjava#conclusion","position":12},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Conclusion","lvl2":"ArrayList vs. LinkedList"},"content":"Choosing between an ArrayList and a LinkedList depends on the specific use case and performance needs. If you need frequent access and stable size, go for ArrayList. If your application requires a lot of insertions and deletions, opt for LinkedList.","type":"content","url":"/xdoublylinkedlistjava#conclusion","position":13},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Java Linked List Methods"},"type":"lvl2","url":"/xdoublylinkedlistjava#java-linked-list-methods","position":14},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Java Linked List Methods"},"content":"Method\n\nDescription\n\nadd(E e)\n\nAppends the specified element to the end of the list.\n\nadd(int index, E element)\n\nInserts the specified element at the specified position.\n\naddFirst(E e)\n\nInserts the specified element at the beginning of the list.\n\naddLast(E e)\n\nAppends the specified element to the end of the list.\n\nremove(Object o)\n\nRemoves the first occurrence of the specified element.\n\nremove(int index)\n\nRemoves the element at the specified position.\n\nremoveFirst()\n\nRemoves and returns the first element of the list.\n\nremoveLast()\n\nRemoves and returns the last element of the list.\n\nget(int index)\n\nReturns the element at the specified position.\n\nset(int index, E element)\n\nReplaces the element at the specified position with the given element.\n\nsize()\n\nReturns the number of elements in the list.\n\nisEmpty()\n\nReturns true if the list is empty, false otherwise.\n\nclear()\n\nRemoves all elements from the list.\n\ncontains(Object o)\n\nReturns true if the list contains the specified element.\n\nindexOf(Object o)\n\nReturns the index of the first occurrence of the specified element, or -1 if not found.\n\nlastIndexOf(Object o)\n\nReturns the index of the last occurrence of the specified element, or -1 if not found.\n\nlistIterator()\n\nReturns a list iterator over the elements in the list.\n\niterator()\n\nReturns an iterator over the elements in the list.\n\ntoArray()\n\nReturns an array containing all elements in the list.\n\ntoArray(T[] a)\n\nReturns an array containing all elements in the list; the runtime type of the returned array is that of the specified array.\n\naddAll(Collection<? extends E> c)\n\nAppends all elements in the specified collection to the end of the list.\n\naddAll(int index, Collection<? extends E> c)\n\nInserts all elements in the specified collection at the specified position.\n\nremoveAll(Collection<?> c)\n\nRemoves all elements in this list that are contained in the specified collection.\n\nretainAll(Collection<?> c)\n\nRetains only the elements in this list that are contained in the specified collection.\n\nclone()\n\nReturns a shallow copy of the list.","type":"content","url":"/xdoublylinkedlistjava#java-linked-list-methods","position":15},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Demo Code"},"type":"lvl2","url":"/xdoublylinkedlistjava#demo-code","position":16},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Demo Code"},"content":"Here is a Java program that demonstrates the most frequently used methods in the LinkedList class. This program showcases common operations such as adding, removing, accessing elements, and checking the size of the list:import java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] args) {\n        // Create a LinkedList\n        LinkedList<String> list = new LinkedList<>();\n        \n        // Add elements to the LinkedList\n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Cherry\");\n        list.addFirst(\"Mango\"); // Adds element at the start\n        list.addLast(\"Orange\"); // Adds element at the end\n        \n        // Display the LinkedList\n        System.out.println(\"Initial LinkedList: \" + list);\n\n        // Access elements in the LinkedList\n        System.out.println(\"First element: \" + list.getFirst());\n        System.out.println(\"Last element: \" + list.getLast());\n        System.out.println(\"Element at index 2: \" + list.get(2));\n\n        // Check the size of the LinkedList\n        System.out.println(\"Size of LinkedList: \" + list.size());\n\n        // Remove elements from the LinkedList\n        list.removeFirst(); // Removes the first element\n        list.removeLast();  // Removes the last element\n        list.remove(1);     // Removes element at index 1\n        \n        // Display the LinkedList after removals\n        System.out.println(\"LinkedList after removals: \" + list);\n\n        // Check if LinkedList contains a specific element\n        if (list.contains(\"Banana\")) {\n            System.out.println(\"LinkedList contains Banana\");\n        } else {\n            System.out.println(\"LinkedList does not contain Banana\");\n        }\n\n        // Clear the LinkedList\n        list.clear();\n        System.out.println(\"LinkedList after clearing: \" + list);\n    }\n}","type":"content","url":"/xdoublylinkedlistjava#demo-code","position":17},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation of the Methods Used:","lvl2":"Demo Code"},"type":"lvl3","url":"/xdoublylinkedlistjava#explanation-of-the-methods-used","position":18},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation of the Methods Used:","lvl2":"Demo Code"},"content":"add(element) - Adds an element to the end of the list.\n\naddFirst(element) - Adds an element at the beginning of the list.\n\naddLast(element) - Adds an element at the end of the list.\n\nget(index) - Returns the element at the specified position.\n\ngetFirst() / getLast() - Returns the first or last element, respectively.\n\nsize() - Returns the number of elements in the list.\n\nremove(index) - Removes the element at the specified position.\n\nremoveFirst() / removeLast() - Removes the first or last element, respectively.\n\ncontains(element) - Checks if the list contains the specified element.\n\nclear() - Removes all the elements from the list.","type":"content","url":"/xdoublylinkedlistjava#explanation-of-the-methods-used","position":19},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"LinkedList Iterator"},"type":"lvl2","url":"/xdoublylinkedlistjava#linkedlist-iterator","position":20},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"LinkedList Iterator"},"content":"The LinkedList Iterator in Java is an object that allows you to traverse the elements of a LinkedList sequentially. The Iterator is part of the Java Collections Framework and provides methods to iterate through the list, remove elements during iteration, and check for more elements.","type":"content","url":"/xdoublylinkedlistjava#linkedlist-iterator","position":21},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Key Methods of the Iterator:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/xdoublylinkedlistjava#key-methods-of-the-iterator","position":22},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Key Methods of the Iterator:","lvl2":"LinkedList Iterator"},"content":"hasNext(): Returns true if there are more elements to iterate.\n\nnext(): Returns the next element in the iteration.\n\nremove(): Removes the last element returned by the iterator (optional operation).","type":"content","url":"/xdoublylinkedlistjava#key-methods-of-the-iterator","position":23},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Example Code Using Iterator with LinkedList:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/xdoublylinkedlistjava#example-code-using-iterator-with-linkedlist","position":24},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Example Code Using Iterator with LinkedList:","lvl2":"LinkedList Iterator"},"content":"Here’s a sample Java program that demonstrates how to use the Iterator to traverse a LinkedList:import java.util.LinkedList;\nimport java.util.Iterator;\n\npublic class LinkedListIteratorDemo {\n    public static void main(String[] args) {\n        // Create a LinkedList\n        LinkedList<String> list = new LinkedList<>();\n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Cherry\");\n        list.add(\"Mango\");\n\n        // Get the iterator from the LinkedList\n        Iterator<String> iterator = list.iterator();\n\n        // Iterate through the LinkedList\n        System.out.println(\"Traversing the LinkedList:\");\n        while (iterator.hasNext()) {\n            String element = iterator.next();\n            System.out.println(element);\n            \n            // Remove \"Banana\" during iteration\n            if (element.equals(\"Banana\")) {\n                iterator.remove();\n                System.out.println(\"\\\"Banana\\\" has been removed\");\n            }\n        }\n\n        // Display the LinkedList after iteration\n        System.out.println(\"\\nLinkedList after iteration: \" + list);\n    }\n}","type":"content","url":"/xdoublylinkedlistjava#example-code-using-iterator-with-linkedlist","position":25},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Output:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/xdoublylinkedlistjava#output","position":26},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Output:","lvl2":"LinkedList Iterator"},"content":"Traversing the LinkedList:\nApple\nBanana\n\"Banana\" has been removed\nCherry\nMango\n\nLinkedList after iteration: [Apple, Cherry, Mango]","type":"content","url":"/xdoublylinkedlistjava#output","position":27},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/xdoublylinkedlistjava#explanation","position":28},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation:","lvl2":"LinkedList Iterator"},"content":"Create a LinkedList:\n\nWe create a LinkedList of strings and add elements to it.\n\nGet an iterator:\n\nThe iterator() method of LinkedList is used to obtain an Iterator for the list.\n\nUse the iterator to traverse:\n\nWe loop through the list using hasNext() and next(), which ensure that each element is processed one by one.\n\nRemove an element during iteration:\n\nThe remove() method removes the last element returned by the iterator.\n\nIn this case, if the current element is \"Banana\", it is removed from the list.","type":"content","url":"/xdoublylinkedlistjava#explanation","position":29},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Why Use an Iterator with LinkedList?","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/xdoublylinkedlistjava#why-use-an-iterator-with-linkedlist","position":30},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Why Use an Iterator with LinkedList?","lvl2":"LinkedList Iterator"},"content":"Efficient Traversal: Iterators are efficient for traversing and manipulating lists because they maintain the state of traversal.\n\nModification During Traversal: Unlike using a for loop or enhanced for loop, an Iterator allows safe removal of elements during traversal, avoiding ConcurrentModificationException.\n\nThe iterator is a flexible and powerful way to navigate through and manipulate LinkedList elements in Java.","type":"content","url":"/xdoublylinkedlistjava#why-use-an-iterator-with-linkedlist","position":31},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List"},"type":"lvl1","url":"/xdoublylinkedlistreaddataintoll","position":0},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List"},"content":"","type":"content","url":"/xdoublylinkedlistreaddataintoll","position":1},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List","lvl2":"Lecture Code"},"type":"lvl2","url":"/xdoublylinkedlistreaddataintoll#lecture-code","position":2},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List","lvl2":"Lecture Code"},"content":"/*\nProgrammer: James Goudy\nProject: Reading a csv file into a linked list\n */\n\n\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nclass Link {\n\n    Link first = null;\n    Link last = null;\n\n    // data\n    String id = null;\n    String firstname;\n    String lastname;\n    String pet;\n    \n\n    // link navigation\n    Link next = null;\n    Link prev = null;\n\n    // constructor\n    public Link(String id, String firstname, String lastname, String pet) {\n        this.id = id;\n        this.firstname = firstname;\n        this.lastname = lastname;\n        this.pet = pet;\n    }\n\n\n    public void displayNode() {\n        System.out.println(\"{\"+ firstname + \" \" + lastname + \" \"\n                            +pet+ \" \" + id +\" } \" );\n    }\n} // end of link\n\n\n\n\nclass Doubly {\n\n    Link first = null;\n    Link last = null;\n\n    // constructor\n    public Doubly() {\n\n        first = null;\n        last = null;\n    }\n\n    // add link at the beginning of the list\n    public boolean addFirst(String id,String firstname, \n            String lastname, String pet) {\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.next = first;\n            first.prev = newLink;\n            first = newLink;\n        }\n\n        return true;\n    }\n\n    // add link to the end of the list\n    public boolean addLast(String id,String firstname, \n            String lastname, String pet) {\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.prev = last;\n            last.next = newLink;\n            last = newLink;\n        }\n\n        return true;\n    }\n\n    public boolean findId(String searchID) {\n\n        if (first == null) {\n\n            // if list is empty\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchID)) {\n                    return true;\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    }\n\n    public boolean insertAfter(String searchId, String id,String firstname, \n            String lastname, String pet) {\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchId)) {\n\n                    // check if last link\n                    if (current.next == null) {\n                        // check if last link\n                        current.next = newLink;\n                        newLink.prev = current;\n\n                        last = newLink;\n\n                    } else {\n                        newLink.next = current.next;\n                        newLink.prev = current;\n\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n\n    }\n\n    public boolean insertBefore(String searchId, String id,String firstname, \n            String lastname, String pet) {\n\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchId)) {\n\n                    // check for first link\n                    if (current.prev == null) {\n                        // check if last link\n                        current.prev = newLink;\n                        newLink.next = current;\n\n                        first = newLink;\n\n                    } else {\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n    }\n\n    public boolean deleteId(String searchID) {\n\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchID)) {\n\n                    if (current.prev == null) {\n                        // first node\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true;\n                    } else if (current.next == null) {\n                        // last node\n                        current.prev.next = null;\n                        last = current;\n                        current = null;\n                        return true;\n                    } else {\n                        // a center node\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n\n                        return true;\n                    }\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    } //end of function\n\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode();\n            current = current.next;\n        }\n        System.out.println(\"\");\n\n    }\n}\n\npublic class DS_ReadDataIntoLinkedList {\n\n    static Doubly dl = new Doubly();\n\n    public static void idSearch(String searchId) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.findId(searchId)) {\n            System.out.println(\"\\n\" + searchId + \" is in list\");\n        } else {\n            System.out.println(\"\\n\" + searchId + \" not found\");\n        }\n\n    }\n\n    public static void deleteID(String searchId) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.deleteId(searchId)) {\n            System.out.println(searchId + \" was deleted\");\n        } else {\n            System.out.println(searchId + \" was NOT deleted\");\n        }\n\n    }\n    \n    \n    public static boolean addData(String filePath)\n    {\n        BufferedReader br;\n        FileReader fr;\n        String inputLine;\n        \n        try {\n            // create buffered reader\n            br = new BufferedReader(new FileReader(filePath));\n            \n            // skip the header line\n            br.readLine();\n            \n            while((inputLine = br.readLine()) != null)\n            {\n                String[] inputArray = inputLine.split(\",\");\n                dl.addLast(inputArray[0],\n                           inputArray[1],\n                           inputArray[2],\n                           inputArray[3]);\n            \n            }\n            \n            br.close();\n            \n        } catch (FileNotFoundException ex) {\n            System.out.println(ex.getMessage());\n            return false;\n        }catch (Exception e)\n        {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        \n        \n        return true;\n    }\n    \n\n    public static void main(String[] args) {\n\n        String searchID = \"\";\n        String insertCity = \"\";\n        \n        String filePath = \"c:\\\\z\\\\peoplePets.csv\";\n\n        addData(filePath);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchID = \"10\";\n        idSearch(searchID);\n\n        searchID = \"AAA\";\n        idSearch(searchID);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchID = \"10\";\n        deleteID(searchID);\n\n        searchID = \"AA\";\n        deleteID(searchID);\n\n\n        System.out.println(\"\\n----- Insert Examples------\\n\");\n\n        searchID = \"140\";\n        dl.insertAfter(searchID, \"1440\",\"Duke\",\"Ellington\", \"Phoenix\");\n\n\n        searchID = \"145\";\n        dl.insertBefore(searchID, \"1455\",\"John\",\"Coletrane\", \"Hydra\");\n\n\n        dl.displayList();\n\n        System.out.println(\"\\nbye\");\n    }\n}\n\n/* peoplePet.csv\n\nid,firstname,lastname,pet\n1,Wini,Gwinnett,Crowned hawk-eagle\n2,Birgit,Tabb,Silver gull\n3,Alfonso,Moyle,Ring-tailed possum\n4,Ode,Buckwell,Leopard\n5,Francene,Zanazzi,Wambenger\n6,Willie,Hakking,Butterfly\n7,Carlie,Pizey,Northern fur seal\n8,Cobby,Chittock,Great white pelican\n9,Ingamar,Cardenoza,Puma\n10,Brady,Vowles,Red meerkat\n11,Nonna,Betser,Lesser mouse lemur\n12,Antonina,Dovey,Insect\n13,Erastus,Crackett,Cow\n14,Lucien,Cardenosa,Yellow baboon\n15,Leon,Storm,Blue catfish\n16,Reinaldos,Welberry,Common grenadier\n17,Cherice,Coleson,Shrike\n18,Elyn,Antill,Echidna\n19,Dicky,Guppie,Puna ibis\n20,Erasmus,Pauncefort,White-necked stork\n21,Stewart,Pettifer,Starling\n22,Brand,Tytcomb,Raccoon\n23,Edwina,Cosens,Radiated tortoise\n24,Martelle,Barkus,Cormorant\n25,Blithe,Prevett,Kafue flats lechwe\n26,Abbie,Ferber,Common wombat\n27,Antonin,Sayes,Small-clawed otter\n28,Vaughan,Barzen,Hawk-eagle\n29,Elwira,Braemer,Monkey\n30,Sibelle,Vennings,Javanese cormorant\n31,Mavra,Bulter,Lemur\n32,Darrelle,Sanford,Beisa oryx\n33,Rodney,Whapples,Gull\n34,Horace,Gerwood,Tropical buckeye butterfly\n35,Garvin,Pestell,Bleu\n36,Lauralee,Crowdace,Dama wallaby\n37,Farica,Juara,Penguin\n38,Bucky,Taylo,Crab\n39,Carlynne,Pleasaunce,Common genet\n40,Dana,Percy,White-throated kingfisher\n41,Esma,McKerley,Southern ground hornbill\n42,Hube,Grills,Flamingo\n43,Hersch,Schneidau,Kangaroo\n44,Hildy,Matfin,Gull\n45,Lelia,Donaghy,American marten\n46,Eric,Tydd,Bahama pintail\n47,Clim,Tetsall,Spur-winged goose\n48,Berke,Brotherwood,Little cormorant\n49,Steve,Bride,Turtle\n50,Christiane,Stoppe,Fox\n51,Riley,Badgers,Swallow\n52,Leonidas,Pughsley,Roseate cockatoo\n53,Richard,Baudon,White-browed owl\n54,Marline,Tousey,Indian mynah\n55,Margarita,Breche,Phalarope\n56,Gerek,Aspinwall,Great horned owl\n57,Mabelle,Aronin,Grouse\n58,Curtice,Provost,Indian mynah\n59,Nikolaos,Cass,Desert tortoise\n60,Edmund,Pogosian,Grenadier\n61,Cindi,Vell,Catfish\n62,Davis,Roberts,Three-banded plover\n63,Clayborne,Jennrich,Roe deer\n64,Malory,Iwanicki,Snowy owl\n65,Toddy,Vannuchi,Arboral spiny rat\n66,Terri,Dudson,Malachite kingfisher\n67,Gabriel,Prine,Possum\n68,Jeannine,Westwick,Gecko\n69,Conney,Mattke,Stork\n70,Eulalie,Wapplington,Flamingo\n71,Darrick,Porcas,Rat\n72,Matty,Marchment,Deer\n73,Fedora,Semper,Nighthawk\n74,Barnebas,Wychard,Flying fox\n75,Edmund,Whitton,Squirrel\n76,Oliver,Dragoe,Parrot\n77,Carly,Royden,Lourie\n78,Cairistiona,Brothwell,Chestnut weaver\n79,Barnabas,Eastby,Lion\n80,Clementina,McCoish,European stork\n81,Rupert,Goosnell,Boa\n82,Jerrylee,Keir,Lizard\n83,Cariotta,Strettell,Little blue penguin\n84,Onida,Wysome,White-rumped vulture\n85,Reggis,Thursby,Cape wild cat\n86,Sharleen,Yele,Gazer\n87,Obadias,Rosedale,Vine snake\n88,Jodie,Harmond,Boat-billed heron\n89,Jonie,Goodricke,Brush-tailed phascogale\n90,Carissa,Clorley,Elk\n91,Jacki,Belhome,Northern elephant seal\n92,Virgina,Jarrette,House sparrow\n93,Hasheem,Cordeiro,Oystercatcher\n94,Roseann,Hussy,Fairy penguin\n95,Emmeline,Saurat,Bee-eater\n96,Ashlin,Ollerhead,Grey lourie\n97,Frannie,Sailes,Jungle kangaroo\n98,Shelden,Imason,Woodpecker\n99,Nicole,Cattle,Starling\n100,Bennie,Selliman,Ant\n101,Monroe,Sturzaker,Wild turkey\n102,Lou,Drew-Clifton,Ferruginous hawk\n103,Gerladina,Broadbere,Yellow-billed stork\n104,Laney,Scartifield,Common zebra\n105,Rolfe,Dressel,Cape Barren goose\n106,Clarita,Zylbermann,Red-legged pademelon\n107,Ev,Buckston,Kite\n108,Vidovic,Lawson,Buffalo\n109,Daloris,Grzesiak,Southern brown bandicoot\n110,Pier,Sproson,Brocket\n111,Edwina,Barlace,Giant girdled lizard\n112,Elvin,Birchwood,Deer\n113,Jedediah,Lazonby,Wallaby\n114,Ambur,Lochead,Gila monster\n115,Mirabella,Ferron,Possum\n116,Dougy,Gianinotti,Openbill\n117,Cher,Sivill,Dog\n118,Durante,Wissby,Genet\n119,Rora,Shord,Dove\n120,Dame,Jennison,Red-billed toucan\n121,Ira,Karolowski,Eurasian red squirrel\n122,Juliet,Hobson,Greylag goose\n123,Natale,Tattersdill,Starling\n124,Caitlin,Leggett,Ring-necked pheasant\n125,Hamnet,Danelut,South African hedgehog\n126,Christye,Stores,Porcupine\n127,Vince,Paolo,Kangaroo\n128,Cristy,Fesby,Starling\n129,Britney,Standfield,Burrowing owl\n130,Kaleena,Volkers,Langur\n131,Averil,Kimbell,Rhea\n132,Carmelita,Gehrels,Spotted-tailed quoll\n133,Cory,Sreenan,Hyrax\n134,Sybille,Filippone,Dove\n135,Delia,Forkan,Agama lizard\n136,Sigfried,Cattlemull,Eastern dwarf mongoose\n137,Rowena,James,Fox\n138,Shane,Naisey,Jaguarundi\n139,Janine,Ielden,Eastern fox squirrel\n140,Beverlie,Biggerstaff,Fox\n141,Menard,Archbould,Roe deer\n142,Darline,Keating,Caribou\n143,Heall,Chritchley,Beaver\n144,Corenda,Bunnell,Glossy starling\n145,Town,Mandal,White-winged tern\n146,Pietrek,Primmer,Superb starling\n147,Guillemette,Jasper,Gemsbok\n148,Diane,Mewes,Civet\n149,Hatty,Liddle,Grouse\n150,Ange,Beardwell,Deer\n\n */\n\nEnd Of Topic","type":"content","url":"/xdoublylinkedlistreaddataintoll#lecture-code","position":3},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class"},"type":"lvl1","url":"/xdoublylinkedlistsubclass","position":0},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class"},"content":"","type":"content","url":"/xdoublylinkedlistsubclass","position":1},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Key Ideas"},"type":"lvl2","url":"/xdoublylinkedlistsubclass#key-ideas","position":2},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Key Ideas"},"content":"The doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nNote\n\nNot all languages support subclasses.","type":"content","url":"/xdoublylinkedlistsubclass#key-ideas","position":3},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Lecture Code"},"type":"lvl2","url":"/xdoublylinkedlistsubclass#lecture-code","position":4},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Lecture Code"},"content":"/*\n * Programmer: James Goudy\n * Project: Doubly Linked List written\n * with  Links / Nodes as SubClass\n */\n\nclass Doubly {\n\n    Link first = null;\n    Link last = null;\n\n    // ---------------------------------\n    // sub class - Link / Nodes\n    // NOTE: this can be a separate class as well\n    \n    class Link {\n\n        Link first = null;\n        Link last = null;\n\n        // data\n        String city = null;\n\n        // link navigation\n        Link next = null;\n        Link prev = null;\n\n        // constructor\n        Link(String city) {\n            this.city = city;\n            this.next = null;\n            this.prev = null;\n        }\n\n        public void displayNode() {\n            System.out.print(city + \" \");\n        }\n    } // end of link\n    // ---------------------------------\n\n    // constructor\n    public Doubly() {\n\n        first = null;\n        last = null;\n    }\n\n    // add link at the beginning of the list\n    public boolean addFirst(String city) {\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.next = first;\n            first.prev = newLink;\n            first = newLink;\n        }\n\n        return true;\n    }\n\n    // add link to the end of the list\n    public boolean addLast(String city) {\n\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.prev = last;\n            last.next = newLink;\n            last = newLink;\n        }\n\n        return true;\n    }\n\n    public boolean findCity(String citySearch) {\n\n        if (first == null) {\n\n            // if list is empty\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n                    return true;\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    }\n\n    public boolean insertAfter(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n            \n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check if last link\n                    if (current.next == null) {\n                        // check if last link\n                        current.next = newLink;\n                        newLink.prev = current;\n\n                        last = newLink;\n\n                    } else {\n                        newLink.next = current.next;\n                        newLink.prev = current;\n\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n\n    }\n\n    public boolean insertBefore(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n            \n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check for first link\n                    if (current.prev == null) {\n                        // check if last link\n                        current.prev = newLink;\n                        newLink.next = current;\n\n                        first = newLink;\n\n                    } else {\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n    }\n\n    public boolean deleteCity(String citySearch) {\n\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    if (current.prev == null) {\n                        // first node\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true;\n                    } else if (current.next == null) {\n                        // last node\n                        current.prev.next = null;\n                        last = current;\n                        current = null;\n                        return true;\n                    } else {\n                        // a center node\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n\n                        return true;\n                    }\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    } //end of function\n\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode();\n            current = current.next;\n        }\n        System.out.println(\"\");\n    }\n        \n    public void displayListBackwards() {\n        Link current = last;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode();\n            current = current.prev;\n        }\n        System.out.println(\"\");\n    }\n    \n}\n\npublic class J2_SubClass {\n\n    static Doubly dl = new Doubly();\n\n    public static void citySearch(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.findCity(searchCity)) {\n            System.out.println(\"\\n\" + searchCity + \" is in list\");\n        } else {\n            System.out.println(\"\\n\" + searchCity + \" not found\");\n        }\n\n    }\n\n    public static void deleteCity(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.deleteCity(searchCity)) {\n            System.out.println(searchCity + \" was deleted\");\n        } else {\n            System.out.println(searchCity + \" was NOT deleted\");\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        String searchCity = \"\";\n        String insertCity = \"\";\n\n        // insert data at front of list\n        dl.addFirst(\"Kali\");\n        dl.addFirst(\"Polson\");\n        dl.addFirst(\"Missoula\");\n        dl.addFirst(\"Whitefish\");\n\n        // insert data at end of list\n        dl.addLast(\"Chicago\");\n        dl.addLast(\"Denver\");\n        dl.addLast(\"Sandiego\");\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchCity = \"Chicago\";\n        citySearch(searchCity);\n\n        searchCity = \"Bozeman\";\n        citySearch(searchCity);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchCity = \"Polson\";\n        deleteCity(searchCity);\n\n        searchCity = \"Bozeman\";\n        deleteCity(searchCity);\n\n        searchCity = \"Sandiego\";\n        deleteCity(searchCity);\n\n        searchCity = \"Whitefish\";\n        deleteCity(searchCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Insert Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        insertCity = \"Dayton\";\n        dl.insertAfter(searchCity, insertCity);\n\n        searchCity = \"Denver\";\n        insertCity = \"Boulder\";\n        dl.insertAfter(searchCity, insertCity);\n\n        dl.displayList();\n\n        searchCity = \"Chicago\";\n        insertCity = \"Springfield\";\n        dl.insertBefore(searchCity, insertCity);\n\n        searchCity = \"Missoula\";\n        insertCity = \"Libby\";\n        dl.insertBefore(searchCity, insertCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\nbye\");\n    }\n}\n\n/*\n OUTPUT \n \n Whitefish Missoula Polson Kali Chicago Denver Sandiego \n\n----- Find Examples------\n\n\nChicago is in list\n\nBozeman not found\n\n----- Delete Examples------\n\nPolson was deleted\nBozeman was NOT deleted\nSandiego was deleted\nWhitefish was deleted\n\nMissoula Kali Chicago Denver \n\n----- Insert Examples------\n\n\nMissoula Dayton Kali Chicago Denver Boulder \n\nLibby Missoula Dayton Kali Springfield Chicago Denver Boulder \n\nbye\n \n */\n\nEnd Of Topic","type":"content","url":"/xdoublylinkedlistsubclass#lecture-code","position":5},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation"},"type":"lvl1","url":"/xencapsulationnonencapsulation","position":0},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation"},"content":"This program is a Java demonstration designed to illustrate the core Object-Oriented Programming (OOP) concept of Encapsulation using the contrast between private and public access modifiers. It primarily shows how data hiding and controlled access are used to maintain an object’s integrity.","type":"content","url":"/xencapsulationnonencapsulation","position":1},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Encapsulated Person Class (Good Practice)"},"type":"lvl2","url":"/xencapsulationnonencapsulation#the-encapsulated-person-class-good-practice","position":2},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Encapsulated Person Class (Good Practice)"},"content":"The Person class exemplifies proper encapsulation, also known as data hiding.\n\nPrivate Data Fields: The class’s data (firstName and lastName) are declared as private. This prevents any code outside the class from directly reading or modifying them, effectively protecting the data.\n\nPublic Accessors (Getters and Setters): The class provides public methods—getters (like getFirstName()) for safely reading the data, and setters (like setFirstName()) for safely writing the data.\n\nControlled Integrity: The key benefit is that the setFirstName() method includes validation logic. If an external caller attempts to set a first name that is null or shorter than two characters, the setter detects the invalid input, prints an error message, and prevents the private field from being changed. This ensures the Person object remains in a valid, consistent state.","type":"content","url":"/xencapsulationnonencapsulation#the-encapsulated-person-class-good-practice","position":3},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Non-Encapsulated Dog Class (Risky Practice)"},"type":"lvl2","url":"/xencapsulationnonencapsulation#the-non-encapsulated-dog-class-risky-practice","position":4},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Non-Encapsulated Dog Class (Risky Practice)"},"content":"The Dog class demonstrates the pitfalls of breaking encapsulation by using public fields.\n\nPublic Data Fields: The class’s data (dogName and dogBreed) are declared as public. Any external code can directly access and modify these variables without any mediation.\n\nNo Control or Validation: Because external code bypasses any methods to change the data, the Dog class has no opportunity to validate the new values. As demonstrated in the main method, an external caller can directly set the dogName to a potentially disastrous value like null. This makes the object’s internal state vulnerable and potentially invalid, and the class cannot prevent it.","type":"content","url":"/xencapsulationnonencapsulation#the-non-encapsulated-dog-class-risky-practice","position":5},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The main Demonstration"},"type":"lvl2","url":"/xencapsulationnonencapsulation#the-main-demonstration","position":6},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The main Demonstration"},"content":"The main method creates instances of both classes to showcase the difference:\n\nIt attempts to set an invalid, short first name (“S”) on the encapsulated Person object. The setter rejects the change, and the object’s name remains the previous valid value (“Jane Doe”).\n\nIt directly sets an invalid, null name on the non-encapsulated Dog object. The public field is directly overwritten, allowing the object to enter an inconsistent, invalid state (“null Mutt”), demonstrating the lack of control.","type":"content","url":"/xencapsulationnonencapsulation#the-main-demonstration","position":7},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"Demo Code"},"type":"lvl2","url":"/xencapsulationnonencapsulation#demo-code","position":8},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"Demo Code"},"content":"/*\n * Developer: James Goudy\n *\n * This file demonstrates the key Object-Oriented Programming (OOP)\n * concept of ENCAPSULATION using access modifiers (private vs. public).\n */\npackage classpublicprivateelements;\n\n// The Person class demonstrates ENCAPSULATION (Data Hiding)\nclass Person {\n\n    // 1. Data Hiding: The fields are private, protecting them from\n    // direct external modification. This forces users to go through\n    // our controlled public interface.\n    private String firstName;\n    private String lastName;\n\n    public Person() {\n    }\n    \n    public Person(String firstName, String lastName) {\n        // Use setters in the constructor to ensure validation runs!\n        setFirstName(firstName);\n        setLastName(lastName);\n    }\n\n    // Getters: Public methods to safely READ the private data.\n    public String getFirstName() {\n        return firstName;\n    }\n\n    // 2. Controlled Access (Setters): Public methods to safely WRITE \n    // the private data. Setters give you the opportunity to VALIDATE\n    // data and maintain the object's integrity. If the input is \n    // invalid, the field is not changed.\n    public void setFirstName(String firstName) {\n        // ENHANCEMENT: Simple validation logic\n        if (firstName != null && firstName.length() >= 2) {\n            this.firstName = firstName;\n        } else {\n            // Note: In real production code, you might throw an\n            // IllegalArgumentException.\n            System.out.println(\"Error: First name '\" + firstName + \n                               \"' is invalid. Value ignored.\");\n        }\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        \n        // The same checks as setFirstName could also be applied here.\n        this.lastName = lastName; \n    }\n    \n    public String allInfo() {\n        return (this.firstName + \" \" + this.lastName);\n    }\n}\n\n// The Dog class demonstrates the dangers of PUBLIC ACCESS\nclass Dog {\n\n    // 1. Public Fields: The elements are PUBLIC - they can be accessed \n    // and changed directly by any external code. This breaks \n    // encapsulation.\n    public String dogName;\n    public String dogBreed;\n\n    // THERE IS NO OPPORTUNITY TO VALIDATE! A user can set these fields\n    // to any value (like null or an empty string), potentially making\n    // the object's state INVALID without the class having any control.\n    \n    public Dog() {\n    }\n\n    public Dog(String dogName, String dogBreed) {\n        // If we wanted validation here, we would have to duplicate the\n        // logic in every constructor, instead of just using a Setter.\n        this.dogName = dogName;\n        this.dogBreed = dogBreed;\n    }\n    \n    public String allInfo() {\n        return (this.dogName + \" \" + this.dogBreed);\n    }\n}\n\npublic class ClassPublicPrivateElements {\n\n    public static void main(String[] args) {\n        \n        // --- Demonstration of Encapsulation (Person) ---\n        Person p1 = new Person();\n        \n        // Use the public interface (Setters) to change the private fields.\n        p1.setFirstName(\"Jane\");\n        p1.setLastName(\"Doe\");\n        System.out.println(\"Person 1 (Initial Set): \" + p1.allInfo());\n        \n        // Attempting to set an invalid value - The Setter PROTECTS the data!\n        System.out.println(\"\\nAttempting to set an INVALID first name ('S'):\");\n        p1.setFirstName(\"S\"); \n        \n        // The field remains unchanged because of the validation in the setter.\n        System.out.println(\"Person 1 (After Invalid Set): \" + p1.allInfo()); \n        \n        // --- Demonstration of Public Access (Dog) ---\n        \n        Dog dog = new Dog();\n        \n        // Directly setting the public elements - NO validation possible.\n        dog.dogName = \"Fido\";\n        dog.dogBreed = \"Mutt\";\n        System.out.println(\"\\nDog (Initial Set): \" + dog.allInfo());\n        \n        // Directly setting an invalid value - The public field is VULNERABLE!\n        System.out.println(\"Directly setting an INVALID name (null):\");\n        \n        // This is legal but potentially disastrous!\n        dog.dogName = null; \n        \n        // The object's state is now inconsistent, and the Dog class \n        // could not prevent it.\n        System.out.println(\"Dog (After Invalid Set): \" + dog.allInfo()); \n    }\n}\n\n10/2025","type":"content","url":"/xencapsulationnonencapsulation#demo-code","position":9},{"hierarchy":{"lvl1":"Linked Lists"},"type":"lvl1","url":"/xlinkedlists","position":0},{"hierarchy":{"lvl1":"Linked Lists"},"content":"Definition\n\nLinked List is a set of nodes where each node contains a data field(s) and a reference(link) to the next node in the list.","type":"content","url":"/xlinkedlists","position":1},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Benefits of a linked list"},"type":"lvl2","url":"/xlinkedlists#benefits-of-a-linked-list","position":2},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Benefits of a linked list"},"content":"Not limited to a specific data space amount.\n\nEasy to add and delete data","type":"content","url":"/xlinkedlists#benefits-of-a-linked-list","position":3},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Disadvantages of a linked list"},"type":"lvl2","url":"/xlinkedlists#disadvantages-of-a-linked-list","position":4},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Disadvantages of a linked list"},"content":"The retrieval time of stored data is dependent on the size of the list and the position/node of the data in the list. O(n)","type":"content","url":"/xlinkedlists#disadvantages-of-a-linked-list","position":5},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Types of linked lists"},"type":"lvl2","url":"/xlinkedlists#types-of-linked-lists","position":6},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Types of linked lists"},"content":"Singly linked lists\n\nDoubly linked lists\n\nDoubly linked lists with links as sub class\n\nCircular linked lists\n\nEnd of Topic","type":"content","url":"/xlinkedlists#types-of-linked-lists","position":7},{"hierarchy":{"lvl1":"Merge Sort"},"type":"lvl1","url":"/xmergesort","position":0},{"hierarchy":{"lvl1":"Merge Sort"},"content":"Here’s a summary of the pros and cons of merge sort presented in bullet points:\n\nPros of Merge Sort:\n\nEfficient for large datasets: Merge sort’s average and worst-case time complexities are O(n log n), making it highly efficient for sorting large datasets.\n\nStable sorting algorithm: Merge sort preserves the original order of equal elements, making it a stable sorting algorithm. This is particularly useful when sorting data that contains multiple instances of the same value.\n\nAdaptable to external sorting: Merge sort can be adapted for external sorting, where the data to be sorted is too large to fit into main memory.\n\nHighly parallelizable: Merge sort can be effectively parallelized, making it suitable for multithreaded and distributed computing environments.\n\nCons of Merge Sort:\n\nAdditional memory usage: Merge sort requires additional memory to store the temporary sublists created during the sorting process.\n\nOverhead for small datasets: For small datasets, the overhead of recursion and merging can make merge sort less efficient than simpler algorithms like insertion sort.\n\nNot in-place sorting: Merge sort is not an in-place sorting algorithm, meaning it requires additional memory to store the sorted result.\n\nOverall, merge sort is a versatile and efficient sorting algorithm that is particularly well-suited for large datasets. However, its additional memory requirements and overhead for small datasets make it less suitable for certain applications.","type":"content","url":"/xmergesort","position":1},{"hierarchy":{"lvl1":"Merge Sort - Demo Code"},"type":"lvl1","url":"/xmergesort-reva","position":0},{"hierarchy":{"lvl1":"Merge Sort - Demo Code"},"content":"","type":"content","url":"/xmergesort-reva","position":1},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"How Merge Sort Works"},"type":"lvl3","url":"/xmergesort-reva#how-merge-sort-works","position":2},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"How Merge Sort Works"},"content":"Merge sort is a divide-and-conquer sorting algorithm. It recursively divides the array into two halves until each subarray has only one element (which is trivially sorted). Then it merges these sorted halves back together, comparing elements and building a larger sorted array step by step. This merging process continues until the entire array is reassembled in sorted order.\n\nThe algorithm has a consistent time complexity of O(n log n) — it divides the array (log n times) and merges n elements at each level. Merge sort is stable and efficient but requires extra space proportional to the array size due to its temporary workspace array.","type":"content","url":"/xmergesort-reva#how-merge-sort-works","position":3},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Arrays"},"type":"lvl2","url":"/xmergesort-reva#arrays","position":4},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Arrays"},"content":"","type":"content","url":"/xmergesort-reva#arrays","position":5},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Arrays"},"type":"lvl3","url":"/xmergesort-reva#demo-code","position":6},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Arrays"},"content":"/*\nEngineer: James Goduy\n */\npackage mergesort_rev;\n\nimport java.util.Random;\n\n\n/*\n * The Sorter interface defines a contract that all sorting classes must follow.\n * Any class that implements Sorter must provide concrete versions of insert(),\n * sort(), and displayArray(). These are method signatures only—no code \n * is written here.\n *\n * Using an interface allows us to treat different sorting algorithms (e.g.,\n * recursive and iterative merge sorts) as the same \"type.\" This is an example\n * of polymorphism: we can write one block of code that works with any object\n * implementing Sorter, regardless of how it performs the sorting internally.\n *\n * In short, the interface provides a common structure (what must be done),\n * while each class defines its own behavior (how it is done).\n */\n\ninterface Sorter {\n    void insert(int value);\n    void sort();\n    void displayArray();\n}\n\n\nclass MergeSort implements Sorter {\n\n    private int[] theArray;  // Main array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum capacity of the array\n\n    // Constructor: initializes the array and tracking variables\n    public MergeSort(int max) {\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n    // Check if array is full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert a value into the array (if space allows)\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        theArray[nElems++] = value; // Place value and increment element count\n    }\n\n    // Public method to start the merge sort process\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary workspace for merging\n        recMergeSort(workspace, 0, nElems - 1); // Begin recursive sorting\n    }\n\n    // Recursive function that splits and sorts subarrays\n    private void recMergeSort(int[] workspace, int lowerBound, int upperBound) {\n        if (lowerBound >= upperBound) return; // Base case: one element\n\n        int mid = (lowerBound + upperBound) / 2; // Find midpoint\n\n        // Recursively sort left and right halves\n        recMergeSort(workspace, lowerBound, mid);\n        recMergeSort(workspace, mid + 1, upperBound);\n\n        // Merge the two sorted halves\n        merge(workspace, lowerBound, mid + 1, upperBound);\n    }\n\n    // Merge two sorted halves into a single sorted run\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                   // Index for workspace\n        int lowerBound = lowPtr;     // Start index of left half\n        int mid = highPtr - 1;       // End index of left half\n        int n = upperBound - lowerBound + 1; // Total elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr <= mid && highPtr <= upperBound) {\n            workspace[j++] = (theArray[lowPtr] <= theArray[highPtr])\n                    ? theArray[lowPtr++]\n                    : theArray[highPtr++];\n        }\n\n        // Copy any remaining elements from the left half\n        if (lowPtr <= mid) {\n            System.arraycopy(theArray, lowPtr, workspace, j, mid - lowPtr + 1);\n            j += (mid - lowPtr + 1);\n        }\n\n        // Copy any remaining elements from the right half\n        if (highPtr <= upperBound) {\n            System.arraycopy(theArray, highPtr, workspace, j, upperBound - highPtr + 1);\n        }\n\n        // Copy merged elements back into the original array\n        System.arraycopy(workspace, 0, theArray, lowerBound, n);\n    }\n\n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n} // End Of Class\n\nclass MergeSort_Iterative implements Sorter {\n\n    // Instance Variables\n    private int[] theArray;  // The array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum array capacity (limit)\n\n    // Constructor\n    public MergeSort_Iterative (int max) {\n        // Initialize the array and size counters\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n\n    // Utility Method\n    // Checks whether the array is already full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert Method\n    // Adds a value to the array if space is available\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        // Store value and increase the element count\n        theArray[nElems++] = value;\n    }\n\n\n    // Iterative Merge Sort\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary array used during merging\n        \n        // subSize represents the size of subarrays being merged each pass\n        // Start with subarrays of size 1 and double the size each iteration\n        for (int subSize = 1; subSize < nElems; subSize *= 2) {\n            \n            // Process and merge all pairs of subarrays of the current subSize\n            for (int leftStart = 0; leftStart < nElems - subSize; leftStart += 2 * subSize) {\n                \n                // leftStart: beginning index of left subarray\n                int mid = leftStart + subSize - 1; // Last index of left subarray\n                \n                // Ensure the right subarray does not exceed array bounds\n                int rightEnd = Math.min(leftStart + 2 * subSize - 1, nElems - 1);\n                \n                // Merge the two adjacent sorted subarrays into one\n                merge(workspace, leftStart, mid + 1, rightEnd);\n            }\n        }\n    }\n\n\n    // Merge Method\n    // Merges two sorted halves into a single sorted section\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                    // Index for workspace array\n        int lowerBound = lowPtr;      // Start index of the left half\n        int mid = highPtr - 1;        // End index of the left half\n        int n = upperBound - lowerBound + 1; // Total number of elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr <= mid && highPtr <= upperBound) {\n            if (theArray[lowPtr] <= theArray[highPtr])\n                workspace[j++] = theArray[lowPtr++]; // Copy from left half\n            else\n                workspace[j++] = theArray[highPtr++]; // Copy from right half\n        }\n\n        // Copy any remaining elements from the left half\n        while (lowPtr <= mid) {\n            workspace[j++] = theArray[lowPtr++];\n        }\n\n        // Copy any remaining elements from the right half\n        while (highPtr <= upperBound) {\n            workspace[j++] = theArray[highPtr++];\n        }\n\n        // Copy merged elements back into the original array\n        for (int k = 0; k < n; k++) {\n            theArray[lowerBound + k] = workspace[k];\n        }\n    }\n    \n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n}\n\n\npublic class MergeSort_Rev {\n\n\n    public static void main(String[] args)\n    {\n        \n        int maxSize = 15    ;\n        int sampleSize =  (int)(maxSize * .9);\n        int choice = 2;\n        \n        Sorter ms;\n        \n        // create the object\n        if(choice == 1)\n        {\n            // recursive\n        \tms = new MergeSort(maxSize);\n        }\n        else\n        {\n            // iterative - loops\n            ms = new MergeSort_Iterative (maxSize);\n        }\n\n        // Create RNG\n        Random RNG = new Random();\n\n        // insert random numbers\n        for(int c = 0 ; c < sampleSize; c++)\n        {\n            ms.insert(RNG.nextInt(0,maxSize));\n        }\n      \n        // display the orignal array\n        ms.displayArray();\n\n        \n        // sort the list\n        ms.sort();\n        \n        // spacing\n        System.out.println();\n\n        // display the sorted list\n        ms.displayArray();\n\n        System.out.println(\"\\nbye\\n\");\n    }\n    \n}","type":"content","url":"/xmergesort-reva#demo-code","position":7},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Linked Lists"},"type":"lvl2","url":"/xmergesort-reva#linked-lists","position":8},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Linked Lists"},"content":"","type":"content","url":"/xmergesort-reva#linked-lists","position":9},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Linked Lists"},"type":"lvl3","url":"/xmergesort-reva#demo-code-1","position":10},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Linked Lists"},"content":"/*\n * Example program demonstrating two implementations of Merge Sort\n * for a linked list of people (first name, last name, city).\n * \n * Both recursive (top-down) and iterative (bottom-up) versions\n * implement a common interface (Sorter) for interchangeable use.\n *\n * Author: [Your Name]\n * Course: [Your Class Name or Section]\n */\n\npackage mergesortlinkedlist;\n\n// ----------------------------------------------------------------------\n// Interface Definition\n// ----------------------------------------------------------------------\n\n/**\n * The Sorter interface defines a simple contract for\n * inserting, sorting, and displaying a collection.\n * \n * Both recursive and iterative merge sort classes\n * will implement this interface to ensure consistent usage.\n */\ninterface Sorter {\n    void insert(String fn, String ln, String cty);\n    void sort();\n    void displayList();\n}\n\n// ----------------------------------------------------------------------\n// Recursive Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Recursive\n * \n * Uses a recursive (top-down) merge sort approach.\n * The list is divided into halves until single nodes remain,\n * then merged back together in sorted order by last name.\n */\nclass MergeSortLinkedList_Recursive implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     * Each node stores a person's first name, last name, and city.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head;  // Head pointer for the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public sort method — initiates recursive merge sort.\n     */\n    public void sort() {\n        head = mergeSort(head);\n    }\n\n    /**\n     * Recursive merge sort: splits the list, sorts each half, and merges them.\n     */\n    private Node mergeSort(Node h) {\n        // Base case: 0 or 1 element\n        if (h == null || h.next == null) return h;\n\n        // Split the list into two halves\n        Node middle = getMiddle(h);\n        Node nextOfMiddle = middle.next;\n        middle.next = null; // Split into two sublists\n\n        // Recursively sort both halves\n        Node left = mergeSort(h);\n        Node right = mergeSort(nextOfMiddle);\n\n        // Merge the two sorted halves\n        return sortedMerge(left, right);\n    }\n\n    /**\n     * Merges two sorted linked lists into one (sorted by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n\n        Node result;\n\n        // Compare by last name (case-insensitive)\n        if (a.lastName.compareToIgnoreCase(b.lastName) <= 0) {\n            result = a;\n            result.next = sortedMerge(a.next, b);\n        } else {\n            result = b;\n            result.next = sortedMerge(a, b.next);\n        }\n\n        return result;\n    }\n\n    /**\n     * Finds the middle node of a linked list using the fast/slow pointer method.\n     */\n    private Node getMiddle(Node h) {\n        if (h == null) return h;\n\n        Node slow = h, fast = h;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Iterative Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Iterative\n * \n * Uses an iterative (bottom-up) merge sort approach.\n * Starts by merging small sorted sublists of size 1, then doubles\n * the size of the sublists (1, 2, 4, 8...) until the full list is sorted.\n */\nclass MergeSortLinkedList_Iterative implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head; // Head of the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public method to start iterative merge sort.\n     */\n    public void sort() {\n        head = mergeSortIterative(head);\n    }\n\n    /**\n     * Iterative (loop-based) merge sort implementation.\n     * Uses sublist merging of increasing size to avoid recursion.\n     */\n    private Node mergeSortIterative(Node head) {\n        if (head == null || head.next == null) return head;\n\n        int n = getSize(head);\n\n        // Dummy node simplifies pointer management during merging\n        Node dummy = new Node(\"\", \"\", \"\");\n        dummy.next = head;\n\n        // Merge sublists of size 1, 2, 4, 8, etc.\n        for (int step = 1; step < n; step *= 2) {\n            Node prev = dummy;\n            Node current = dummy.next;\n\n            while (current != null) {\n                Node left = current;\n                Node right = split(left, step);\n                current = split(right, step);\n\n                Node merged = sortedMerge(left, right);\n                prev.next = merged;\n\n                // Move 'prev' to the end of the merged sublist\n                while (prev.next != null)\n                    prev = prev.next;\n            }\n        }\n\n        return dummy.next;\n    }\n\n    /**\n     * Splits the list after 'size' nodes and returns the next sublist.\n     */\n    private Node split(Node head, int size) {\n        if (head == null) return null;\n        for (int i = 1; head.next != null && i < size; i++)\n            head = head.next;\n\n        Node second = head.next;\n        head.next = null;\n        return second;\n    }\n\n    /**\n     * Merges two sorted linked lists (by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        Node dummy = new Node(\"\", \"\", \"\");\n        Node tail = dummy;\n\n        while (a != null && b != null) {\n            if (a.lastName.compareToIgnoreCase(b.lastName) <= 0) {\n                tail.next = a;\n                a = a.next;\n            } else {\n                tail.next = b;\n                b = b.next;\n            }\n            tail = tail.next;\n        }\n\n        tail.next = (a != null) ? a : b;\n        return dummy.next;\n    }\n\n    /**\n     * Counts the number of nodes in the list.\n     */\n    private int getSize(Node head) {\n        int count = 0;\n        while (head != null) {\n            count++;\n            head = head.next;\n        }\n        return count;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Driver Class\n// ----------------------------------------------------------------------\n\n/**\n * Main driver class.\n * \n * Demonstrates the use of both recursive and iterative\n * linked list merge sort implementations via the Sorter interface.\n */\npublic class MergeSortLinkedList {\n\n    public static void main(String[] args) {\n\n        Sorter list;\n\n        int choice = 1;  // 1 = Recursive, 2 = Iterative\n\n        if (choice == 1)\n            list = new MergeSortLinkedList_Recursive();\n        else\n            list = new MergeSortLinkedList_Iterative();\n\n        // Insert sample data\n        list.insert(\"Alice\", \"Zimmer\", \"Chicago\");\n        list.insert(\"Bob\", \"Anderson\", \"Kalispell\");\n        list.insert(\"Cathy\", \"Johnson\", \"Seattle\");\n        list.insert(\"Daniel\", \"Brown\", \"Denver\");\n\n        // Display before sorting\n        System.out.println(\"Before Sorting:\");\n        list.displayList();\n\n        // Sort and display results\n        list.sort();\n        System.out.println(\"After Sorting by Last Name:\");\n        list.displayList();\n    }\n}\n","type":"content","url":"/xmergesort-reva#demo-code-1","position":11},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"When To Use"},"type":"lvl2","url":"/xmergesort-reva#when-to-use","position":12},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"When To Use"},"content":"","type":"content","url":"/xmergesort-reva#when-to-use","position":13},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Quick summary","lvl2":"When To Use"},"type":"lvl3","url":"/xmergesort-reva#quick-summary","position":14},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Quick summary","lvl2":"When To Use"},"content":"Both are O(n log n) time, stable, and O(1) extra space on the list (recursive adds O(log n) call-stack space).\n\nRecursive = simpler to read/teach; Iterative = no recursion, often better constants and safer for huge inputs.","type":"content","url":"/xmergesort-reva#quick-summary","position":15},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl3","url":"/xmergesort-reva#strengths-vs-weaknesses","position":16},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"","type":"content","url":"/xmergesort-reva#strengths-vs-weaknesses","position":17},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Recursive (top-down)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/xmergesort-reva#recursive-top-down","position":18},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Recursive (top-down)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"How it works: repeatedly split with fast/slow pointers (getMiddle), then merge.\n\nStrengths\n\nClarity & pedagogy: mirrors the textbook definition; very readable for students.\n\nNatural structure: the “divide → conquer → combine” flow matches the mental model of merge sort.\n\nEasy to parallelize: left and right halves can be sorted concurrently if you go multi-threaded later.\n\nStable by construction: merge step preserves order of equals.\n\nWeaknesses\n\nCall-stack use: O(log n) stack frames. Usually fine, but it’s still extra memory and can matter on very tight stacks or unusual environments.\n\nFunction-call overhead: many small recursive calls; minor but measurable on some JVMs.\n\nMiddle finding every level: each split uses fast/slow pointers; total cost stays O(n log n) but the constant factor isn’t free.","type":"content","url":"/xmergesort-reva#recursive-top-down","position":19},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Iterative (bottom-up)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/xmergesort-reva#iterative-bottom-up","position":20},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Iterative (bottom-up)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"How it works: repeatedly merge runs of size 1, 2, 4, 8, … using loops; uses pointer “splicing” (split, merge) and a dummy head.\n\nStrengths\n\nNo recursion: avoids stack growth entirely; safer for very large lists or constrained runtimes.\n\nGood constants: one linear pass per run size; practical throughput often edges out recursive on linked lists.\n\nPredictable control flow: all in loops; easy to bound and instrument.\n\nStill stable: merge loop preserves order of equals.\n\nWeaknesses\n\nMore pointer surgery: more places to make off-by-one / null-next mistakes; trickier to get right first time.\n\nSlightly less intuitive to newcomers: bottom-up run doubling is less obvious than “split in half”.\n\nNeeds size or tail walking: typical pattern computes n up front or advances pointers carefully; again, more book-keeping.","type":"content","url":"/xmergesort-reva#iterative-bottom-up","position":21},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Performance & resource notes","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/xmergesort-reva#performance-resource-notes","position":22},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Performance & resource notes","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"Time complexity: both O(n log n) on singly linked lists.\n\nSpace: both in-place on nodes; recursive adds O(log n) call stack, iterative doesn’t.\n\nCache locality: neither is great (linked lists aren’t cache-friendly), but iterative’s fewer function calls can help a bit.\n\nStability: both remain stable as long as your merge uses <= (or equivalent) and never reorders equals.","type":"content","url":"/xmergesort-reva#performance-resource-notes","position":23},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"When to pick which","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/xmergesort-reva#when-to-pick-which","position":24},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"When to pick which","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"Teaching / readability / quick correctness: Recursive.\n\nProduction on huge lists / tight memory / maximum robustness: Iterative.\n\nParallel sort of very large lists: Recursive lends itself to parallelizing the two halves.","type":"content","url":"/xmergesort-reva#when-to-pick-which","position":25},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Practical checklist","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/xmergesort-reva#practical-checklist","position":26},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Practical checklist","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"Need simple code? → Recursive.\n\nWorried about stack or sorting millions of nodes? → Iterative.","type":"content","url":"/xmergesort-reva#practical-checklist","position":27},{"hierarchy":{"lvl1":"Visualizing Big O notation"},"type":"lvl1","url":"/xon-visualizingbigonotation","position":0},{"hierarchy":{"lvl1":"Visualizing Big O notation"},"content":"From \n\nhttps://​mellowd​.co​.uk​/ccie​/​?p​=​6122\n\nAuthor: Darren O’Connor\n\nI’m currently learning as much computer science as I can on the side. I’ve come across \n\nBig O notation a few times already, and while I understand it, I’m much more of a visual guy.\n\nIt’s rather easy to use Python and matplotlib to graph out how a function’s execution time grows as the size of the input grows. The important thing to note is not total execution time, but rather how the runtime of that function grows in relation to the input size. This can be plotted onto a graph which should give us a nice representation of Big O notations.\n\nNote too that Big O notations always show the worst case. For this reason, I’ll ensure to use values which the function will have to do the most work for.","type":"content","url":"/xon-visualizingbigonotation","position":1},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(1)"},"type":"lvl2","url":"/xon-visualizingbigonotation#o-1","position":2},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(1)"},"content":"O(1) means constant time. No matter what size the input, the runtime will always be the same. A simple example is finding the middle number in a list. I’ll ensure that all code return the amount of time a command was run in the function. This may make the code look just a bit bloated, but for a good \n\nreason.To find the center of a list we simply divide the length of the list in two, and return that number. It does not matter if a list has 10 elements or 100 elements, the same amount of steps is performed:def O1(input):\n    count = 0\n    result = input[len(input) / 2]\n    count += 1\n    return count\n\nI have created 5 lists. The first is length 10, the second the length 20, and so on. I’ll get the returned values and plot them.","type":"content","url":"/xon-visualizingbigonotation#o-1","position":3},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(1) plot","lvl2":"O(1)"},"type":"lvl3","url":"/xon-visualizingbigonotation#o-1-plot","position":4},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(1) plot","lvl2":"O(1)"},"content":"As can be seen, it doesn’t matter the size of the input. It will always run at the same constant time.","type":"content","url":"/xon-visualizingbigonotation#o-1-plot","position":5},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(logN)"},"type":"lvl2","url":"/xon-visualizingbigonotation#o-logn","position":6},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(logN)"},"content":"O(logN) increases as the input size goes up. However, it goes up as a log of the input size. This means that you can exponentially increase your input size, without linearly increasing the processing time to match.def OlogN(input):\n    def search(length, count):\n        count += 1\n        length /= 2\n        if length == 1 or length == 0:\n            return 1 + count\n        else:\n            return 1 + search(length, count)\n    return 1 + search(len(input), 1)\n","type":"content","url":"/xon-visualizingbigonotation#o-logn","position":7},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(logN) plot","lvl2":"O(logN)"},"type":"lvl3","url":"/xon-visualizingbigonotation#o-logn-plot","position":8},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(logN) plot","lvl2":"O(logN)"},"content":"\n\nThe run time is going up but look at the size of the inputs at the bottom. I start with 10,000 and move up to 500,000. The number of steps has increased, but not significantly.","type":"content","url":"/xon-visualizingbigonotation#o-logn-plot","position":9},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N)"},"type":"lvl2","url":"/xon-visualizingbigonotation#o-n","position":10},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N)"},"content":"O(N) is linear. This means that the run time is linearly matched to the input size. They should increase at exactly the same rate.def ON(input, check):\n    count = 0\n    for number in input:\n        count += 1\n        if number == check:\n            return 1 + count\n","type":"content","url":"/xon-visualizingbigonotation#o-n","position":11},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N) plot","lvl2":"O(N)"},"type":"lvl3","url":"/xon-visualizingbigonotation#o-n-plot","position":12},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N) plot","lvl2":"O(N)"},"content":"\n\nThere is a 1:1 correlation between input size and run time. As expected this produces a linear graph.","type":"content","url":"/xon-visualizingbigonotation#o-n-plot","position":13},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^2^)"},"type":"lvl2","url":"/xon-visualizingbigonotation#o-n-2","position":14},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^2^)"},"content":"O(N^2^)’s runtime will go up as a square of the input size. The runtime goes up faster than your input sizes, so processing time increases rapidly. This is usually when you iterate through multiple loops at the same time like so:def ON2(input):\n    count = 0\n    for i in input:\n        count += 1\n        for j in input:\n            count += 1\n    return 1 + count\n","type":"content","url":"/xon-visualizingbigonotation#o-n-2","position":15},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^2^) plot","lvl2":"O(N^2^)"},"type":"lvl3","url":"/xon-visualizingbigonotation#o-n-2-plot","position":16},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^2^) plot","lvl2":"O(N^2^)"},"content":"","type":"content","url":"/xon-visualizingbigonotation#o-n-2-plot","position":17},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^3^)"},"type":"lvl2","url":"/xon-visualizingbigonotation#o-n-3","position":18},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^3^)"},"content":"O(N^3^)is merely O(N^2^) with another exponent. I wanted to show the difference by simply changing the exponent.def ON3(input):\n    count = 0\n    for i in input:\n        count += 1\n        for j in input:\n            count += 1\n            for k in input:\n                count +=1\n    return 1 + count\n","type":"content","url":"/xon-visualizingbigonotation#o-n-3","position":19},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^3^) plot","lvl2":"O(N^3^)"},"type":"lvl3","url":"/xon-visualizingbigonotation#o-n-3-plot","position":20},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^3^) plot","lvl2":"O(N^3^)"},"content":"Graphs increase rapidly as the exponent increases.","type":"content","url":"/xon-visualizingbigonotation#o-n-3-plot","position":21},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"Conclusions"},"type":"lvl2","url":"/xon-visualizingbigonotation#conclusions","position":22},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"Conclusions"},"content":"I’ve not shown every single type of algorithm, as I just wanted to show the ones I have the most experience with. It’s nice to have a visual representation of these things as it really drills down just how fast your runtime can increase with larger inputs.\n\nYou can find my code used over here.\n\n\nhttps://​github​.com​/mellowdrifter​/Blog​_Code​/tree​/master​/Big_O\n\nEnd Of Topic","type":"content","url":"/xon-visualizingbigonotation#conclusions","position":23},{"hierarchy":{"lvl1":"Priority Queue"},"type":"lvl1","url":"/xpriorityqueue","position":0},{"hierarchy":{"lvl1":"Priority Queue"},"content":"","type":"content","url":"/xpriorityqueue","position":1},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Key Ideas"},"type":"lvl2","url":"/xpriorityqueue#key-ideas","position":2},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Key Ideas"},"content":"Priority Queue\n\nDefinition\n\nA Priority Queue is a queue where there is a mechanism to place data at the start or in front of other data.","type":"content","url":"/xpriorityqueue#key-ideas","position":3},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Lecture Code"},"type":"lvl2","url":"/xpriorityqueue#lecture-code","position":4},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Lecture Code"},"content":"// priorityQ.java\n// demonstrates priority queue\n\n/**\n *\n * @author jgoudy\n */\nclass PriorityQ {\n\n    private int maxSize;\n    private int[] queArr;\n    private int nItems;\n\n    // constructor\n    public PriorityQ(int maxSize) {\n        this.maxSize = maxSize;\n        queArr = new int[maxSize];\n        nItems = 0;\n    }\n\n    public boolean isFull() {\n        return (nItems == maxSize);\n    }\n\n    public boolean isEmpty() {\n        return (nItems == 0);\n    }\n\n    // enqueue - add to queue\n    // lower numbers take a higher place in the queue\n    \n    public void enqueue(int key) {\n        int c;\n\n        if (isEmpty()) {\n            queArr[nItems++] = key;\n        } else {\n            for (c = nItems - 1; c >= 0; c--) {\n                if (key > queArr[c]) {\n                    queArr[c + 1] = queArr[c];\n                } else {\n                    break;\n                }\n            }// end of for\n\n            queArr[c + 1] = key;\n\n            nItems++;\n        }\n    }\n\n    // retreive the next item from the queue\n    // and remove it from the queue\n    public int dequeue() {\n        return queArr[--nItems];\n    }\n\n    // reteive the data from the next item in the queue\n    // but does NOT remove it\n    public int peek() {\n        return queArr[nItems - 1];\n    }\n\n    // print the queue\n    public void printPriorityQ() {\n        System.out.println();\n        for (int c = 0; c < nItems; c++) {\n            System.out.print(queArr[c] + \" \");\n        }\n        System.out.println();\n\n    }\n\n} // end of class\n\npublic class Ds_priorityQueue {\n\n    public static void main(String[] args) {\n\n// assumption lower the number - higher the priority\n        PriorityQ thePQ = new PriorityQ(10);\n\n        // add data items to the queue\n        thePQ.enqueue(30);\n        thePQ.enqueue(50);\n        thePQ.enqueue(10);\n        thePQ.enqueue(40);\n        thePQ.enqueue(20);\n        thePQ.enqueue(60);\n        thePQ.enqueue(5);\n\n        // print the queue\n        thePQ.printPriorityQ();\n\n        System.out.println(\"\\n-----------\\n\");\n\n        // peek at the next data item\n        System.out.println(\"Peek \" + thePQ.peek());\n\n        System.out.println(\"\\n-----------\\n\");\n\n        // remove all the items from the queue\n        while (!thePQ.isEmpty()) {\n            int x = thePQ.dequeue();\n            System.out.print(x + \" \");\n        }\n\n        System.out.println(\"\\n-----------\\n\");\n\n    }\n}\n\n/* Output\n  \n 60 50 40 30 20 10 5 \n\n-----------\n\nPeek 5\n\n-----------\n\n5 10 20 30 40 50 60 \n-----------\n \n */\n\nEnd Of Topic","type":"content","url":"/xpriorityqueue#lecture-code","position":5},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects"},"type":"lvl1","url":"/xqueueusingarrayofobjects","position":0},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects"},"content":"","type":"content","url":"/xqueueusingarrayofobjects","position":1},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Queue Methods"},"type":"lvl2","url":"/xqueueusingarrayofobjects#queue-methods","position":2},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Queue Methods"},"content":"Methods usually associated with a queue are as follows:\n\nEnqueue - add data to the queue.\n\nDequeue - remove data from the queue\n\nPeek - retrieves the next piece/“head” data from the queue, but does not remove it.\n\nisFull - this is used when making a queue with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the queue is empty.\n\nTip\n\nisFull is not needed if a Stack is created using a Linked List\n\nCheck This Out!\n\n// make a new queue object\n\nQueue theQue = new Queue(5);\n\n/*\nNOTICE THE CODE BELOW -\nmake an object from the sub class\n*/\n\nQueue.Town theTown = \n\ntheQue.new Town(“”, 0);\n\nDetails discussed \n\nhere","type":"content","url":"/xqueueusingarrayofobjects#queue-methods","position":3},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Lecture Code"},"type":"lvl2","url":"/xqueueusingarrayofobjects#lecture-code","position":4},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Lecture Code"},"content":"/*\n *Programmer: James Goudy\n *Project: Queue of Objects\n *\n */\npackage com.mycompany.ds132su_queue;\n\n/**\n *\n * @author jgoudy\n */\nclass Queue {\n\n    class Town {\n        // subclass\n        public String city;\n        public int population;\n\n        public Town(String city, int population) {\n            this.city = city;\n            this.population = population;\n        }\n\n        public void displayTown() {\n            System.out.print(\"{\" + city + \" - \" + population + \"} \");\n        }\n\n    }// end of town\n\n    private int maxSize;\n    private Town[] queArray;\n    private int numItems;\n    private int head;\n    private int tail;\n\n    // Queue Constructor\n    public Queue(int maxSize) {\n        this.maxSize = maxSize;\n        queArray = new Town[maxSize];\n        head = 0;\n        tail = -1;\n        numItems = 0;\n    }\n\n    public boolean isFull() {\n        return (numItems == maxSize);\n    }\n\n    public boolean isEmpty() {\n        return (numItems == 0);\n    }\n\n    public boolean enqueue(String city, int population) {\n\n        // insert at tail\n        // \"enqueue\"\n        if (isFull()) {\n            return false;\n        }\n\n        // create town\n        Town newTown = new Town(city, population);\n\n        // wrap to front if neccessary\n        if (tail == maxSize - 1) {\n            tail = -1;\n        }\n\n        // add object to array\n        queArray[++tail] = newTown;\n\n        // increment the count of objects in the array\n        numItems++;\n\n        return true;\n    }\n\n    public Town dequeue() {\n        // remove from the front - the head \n        // \"dequeue\"\n\n        if (isEmpty()) {\n            System.out.print(\"Queue is empty\");\n            return null;\n        }\n\n        // retreive the next in queue and move the head to\n        // the next data item.\n        Town temp = queArray[head++];\n\n        if (head == maxSize) {\n            head = 0;\n        }\n\n        // decrease the count of objects in the array\n        numItems--;\n\n        return temp;\n    }\n\n    public Town peek() {\n        // retreive the head information but do not remove \n        return queArray[head];\n    }\n\n    public void displayQueue() {\n        int cntr = 0;\n        int pos = head;\n        while (cntr < numItems) {\n            queArray[pos].displayTown();\n            cntr++;\n\n            pos++;\n            // loop to the start of the array if necessary\n            if (pos == maxSize) {\n                pos = 0;\n            }\n\n        }\n        System.out.println(\"\\n\");\n    }\n\n} // end of queue\n\npublic class DS132SU_Queue {\n\n    public static void main(String[] args) {\n\n        // make a new queue object\n        Queue theQue = new Queue(5);\n\n        // make an object from the sub class\n        Queue.Town theTown = theQue.new Town(\"\", 0);\n\n        String acity;\n\n        theQue.enqueue(\"Bozeman\", 100000);\n        theQue.enqueue(\"Culver\", 100001);\n        theQue.enqueue(\"Dover\", 100002);\n        theQue.enqueue(\"Edger\", 100003);\n\n        System.out.println(\"\\n------ Queue--------\\n\");\n\n        theQue.displayQueue();\n\n        System.out.println(\"\\nDequeue the first two items in the queue\");\n\n        // return next item from the queue\n        theTown = theQue.dequeue();\n        System.out.println(\"\\n\" + theTown.city + \" - \" + theTown.population);\n\n        theTown = theQue.dequeue();\n        System.out.println(\"\\n\" + theTown.city + \" - \" + theTown.population);\n\n        System.out.println(\"\\n--------------\\n\");\n\n        System.out.println(\"\\nDequeue and retreive only the city\");\n\n        // another option to dequeue and retrieve city only\n        acity = theQue.dequeue().city;\n        System.out.println(acity);\n\n        System.out.println(\"\\n------ Queue--------\\n\");\n\n        theQue.displayQueue();\n\n        theQue.enqueue(\"Franklin\", 104);\n        theQue.enqueue(\"Georgetown\", 105);\n        theQue.enqueue(\"Highland\", 106);\n\n        System.out.println(\"\\n------- Queue -------\\n\");\n        theQue.displayQueue();\n\n        System.out.println(\"\\n----- Peek just city ---------\\n\");\n\n        acity = theQue.peek().city;\n        System.out.println(acity);\n\n        System.out.println(\"\\n----- Peek city population ---------\\n\");\n\n        theTown = theQue.peek();\n        System.out.println(\"\\n\" + theTown.city + \" - \" + theTown.population);\n\n        System.out.println(\"\\n------ Queue --------\\n\");\n        // notice that peek did not remove any towns\n        theQue.displayQueue();\n\n    }\n}\n\n/*\n Output\n \n------ Queue--------\n\n{Bozeman - 100000} {Culver - 100001} {Dover - 100002} {Edger - 100003} \n\n\nDequeue the first two items in the queue\n\nBozeman - 100000\n\nCulver - 100001\n\n--------------\n\n\nDequeue and retreive only the city\nDover\n\n------ Queue--------\n\n{Edger - 100003} \n\n\n------- Queue -------\n\n{Edger - 100003} {Franklin - 104} {Georgetown - 105} {Highland - 106} \n\n\n----- Peek just city ---------\n\nEdger\n\n----- Peek city population ---------\n\n\nEdger - 100003\n\n------ Queue --------\n\n{Edger - 100003} {Franklin - 104} {Georgetown - 105} {Highland - 106} \n  \n \n \n */\n\nEnd Of Topic","type":"content","url":"/xqueueusingarrayofobjects#lecture-code","position":5},{"hierarchy":{"lvl1":"Quick Sort"},"type":"lvl1","url":"/xquicksort","position":0},{"hierarchy":{"lvl1":"Quick Sort"},"content":"Quicksort is a highly efficient sorting algorithm that utilizes the divide-and-conquer strategy to recursively partition an array into smaller subarrays until the entire array is sorted. It’s a versatile algorithm applicable to various data types and input conditions, making it a popular choice for both educational and practical purposes.\n\nHere’s a step-by-step breakdown of how quicksort works:\n\nPivot Selection: Choose an element from the array as the pivot. This pivot will serve as a reference point for partitioning the array.\n\nPartitioning: Partition the array around the pivot, placing elements smaller than the pivot to its left and elements larger than the pivot to its right. This process involves moving elements from one end of the array to the other until the pivot is at its correct position in the sorted array.\n\nRecursion: Recursively apply the partitioning process to the two subarrays created in the previous step. This means treating each subarray as a new unsorted array and repeating the pivot selection and partitioning steps until all subarrays are sorted.\n\nBase Case: The recursion stops when a subarray contains only one element, as it is already sorted.\n\nThe efficiency of quicksort stems from its ability to divide the array into smaller and smaller subarrays, reducing the overall number of comparisons required for sorting. However, its worst-case performance is O(n^2), which occurs when the pivot selection consistently leads to unbalanced subarrays.\n\nIn summary, quicksort is a fast and effective sorting algorithm that works by recursively partitioning an array around a pivot element until the entire array is sorted. Its efficiency and simplicity make it a popular choice for various sorting tasks.\n\nHere is a list of the pros and cons of quicksort in bullet points:\n\nPros:\n\nEfficiency: Quicksort has an average time complexity of O(n log n), which is one of the best among sorting algorithms.\n\nSimplicity: Quicksort is relatively easy to understand and implement, making it a popular choice for teaching and practical applications.\n\nIn-place: Quicksort is an in-place sorting algorithm, meaning it does not require additional memory to store intermediate results.\n\nAdaptability: Quicksort can be adapted to handle various data types and input conditions.\n\nCons:\n\nWorst-case performance: Quicksort has a worst-case time complexity of O(n^2), which occurs when the pivot selection is consistently poor.\n\nInstability: Quicksort is unstable, meaning it does not preserve the original order of equal elements.\n\nMemory usage: Quicksort may require a significant amount of stack space for recursion, especially for large datasets.\n\nSensitivity to pivot selection: The performance of quicksort is heavily dependent on the choice of pivot, making it susceptible to variations in input data.\n\nOverall, quicksort is a versatile and efficient sorting algorithm with a proven track record in various applications. However, it is essential to consider its potential drawbacks, such as worst-case performance and instability, when selecting an appropriate sorting algorithm for a specific task.","type":"content","url":"/xquicksort","position":1},{"hierarchy":{"lvl1":"Quicksort Demo"},"type":"lvl1","url":"/xquicksortdemo","position":0},{"hierarchy":{"lvl1":"Quicksort Demo"},"content":"","type":"content","url":"/xquicksortdemo","position":1},{"hierarchy":{"lvl1":"Quicksort Demo","lvl2":"How QuickSort Works (Recursive Version)"},"type":"lvl2","url":"/xquicksortdemo#how-quicksort-works-recursive-version","position":2},{"hierarchy":{"lvl1":"Quicksort Demo","lvl2":"How QuickSort Works (Recursive Version)"},"content":"QuickSort is a divide-and-conquer sorting algorithm. The recursive version works like a rhythm of splitting and sorting:\n\nPick a pivot — usually the last element.\n\nPartition the array — move all smaller values to the left side, larger values to the right.\n\nRecursively sort the two halves — QuickSort calls itself on the left subarray, then on the right.\n\nBase case — when a segment has 0 or 1 elements, it’s already sorted.\n\nThe recursion naturally creates a call stack, breaking the array into smaller problems until each tiny piece is sorted. When the calls unwind, the entire array emerges in order.","type":"content","url":"/xquicksortdemo#how-quicksort-works-recursive-version","position":3},{"hierarchy":{"lvl1":"Quicksort Demo","lvl2":"How QuickSort Works (Iterative Version)"},"type":"lvl2","url":"/xquicksortdemo#how-quicksort-works-iterative-version","position":4},{"hierarchy":{"lvl1":"Quicksort Demo","lvl2":"How QuickSort Works (Iterative Version)"},"content":"The iterative version works the same way conceptually, but no recursion is used.\nInstead of letting the call stack manage sub-problems, we manage it ourselves:\n\nUse an explicit stack (an array) to store the index ranges that still need sorting.\n\nPush the initial full array range onto the stack.\n\nLoop while the stack isn’t empty:\n\nPop a range off the stack.\n\nPartition that section around a pivot.\n\nPush the left and right sub-ranges back onto the stack (if they exist).\n\nContinue until no unsorted sections remain.\n\nThis version exposes what recursion does behind the scenes. It sorts the same way—just with loops and a manually managed stack./*\nDeveloper James Goudy\n */\npackage quicksort_demo;\n\n\ninterface SortingAlgorithm {\n\n    // Method to sort the array in-place\n    void sort(int[] arr);\n\n}\n\n\n// -------------------------------------------------------------\n// QuickSort.java\n// A simple, teaching-friendly implementation of QuickSort.\n// This class contains ONLY the QuickSort logic.\n//\n// How it works\n// - QuickSort is a \"divide and conquer\" sorting algorithm.\n// - We pick a pivot, split the array into smaller/larger parts,\n//   then recursively sort each part.\n// - This version is NOT optimized. It's intentionally simple.\n// -------------------------------------------------------------\n\nclass QuickSort implements SortingAlgorithm {\n\n    @Override\n    public void sort(int[] arr) {\n        quickSort(arr, 0, arr.length - 1);\n    }\n    // Internal recursive method that performs the sorting\n    private static void quickSort(int[] arr, int low, int high)\n    {\n        if (low < high) {\n            // Partition the array and get the pivot index\n            int pivotIndex = partition(arr, low, high);\n\n            // Recursively sort the left side\n            quickSort(arr, low, pivotIndex - 1);\n\n            // Recursively sort the right side\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n\n    // ---------------------------------------------------------\n    // partition()\n    // This function:\n    //   • chooses a pivot (here we use the last element)\n    //   • rearranges elements so smaller values go left,\n    //     larger values go right\n    //   • returns the final position of the pivot\n    // ---------------------------------------------------------\n    private static int partition(int[] arr, int low, int high)\n    {\n        int pivot = arr[high]; // choose pivot\n        int i = low - 1;       // index of smaller element\n\n        // Move through the array and swap values as needed\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n\n                // swap arr[i] and arr[j]\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        // Move pivot to the correct location\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1; // return pivot position\n    }\n}\n// --------------------------------------------------------------\n\n// -------------------------------------------------------------\n// QuickSortIterative.java\n// A simple, teaching-friendly **iterative** QuickSort.\n// This version uses loops instead of recursion by manually\n// managing our own \"stack\" of sub-array ranges.\n//\n// -------------------------------------------------------------\n\nclass QuickSortIterative implements SortingAlgorithm {\n\n    @Override\n    public void sort(int[] arr) {\n        quickSort(arr);\n    }\n\n    // Iterative quicksort using manual stack\n    private static void quickSort(int[] arr) {\n        int low = 0;\n        int high = arr.length - 1;\n\n        // -----------------------------------------------------\n        // Our manual stack will hold pairs of (low, high) index\n        // ranges that still need to be processed.\n        // -----------------------------------------------------\n        int[] stack = new int[high - low + 1];\n\n        int top = -1;\n\n        // Push initial range onto stack\n        stack[++top] = low;\n        stack[++top] = high;\n\n        // -----------------------------------------------------\n        // Keep looping while we have ranges to process\n        // -----------------------------------------------------\n        while (top >= 0) {\n\n            // Pop the high and low indexes for the next segment\n            high = stack[top--];\n            low = stack[top--];\n\n            // Partition this segment\n            int pivotIndex = partition(arr, low, high);\n\n            // -------------------------------------------------\n            // PUSH RIGHT SIDE (if it exists)\n            // -------------------------------------------------\n            if (pivotIndex + 1 < high) {\n                stack[++top] = pivotIndex + 1;\n                stack[++top] = high;\n            }\n\n            // -------------------------------------------------\n            // PUSH LEFT SIDE (if it exists)\n            // -------------------------------------------------\n            if (pivotIndex - 1 > low) {\n                stack[++top] = low;\n                stack[++top] = pivotIndex - 1;\n            }\n        }\n    }\n\n    // ---------------------------------------------------------\n    // partition()\n    // Same idea as recursive QuickSort:\n    //   - Pick last element as pivot\n    //   - Move all smaller elements to the left\n    //   - Move pivot to its correct position\n    // ---------------------------------------------------------\n    private static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n\n        // Scan through and swap as necessary\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n\n                // Swap arr[i] and arr[j]\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n\n        // Move pivot into correct place\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n\n        return i + 1;\n    }\n}\n\n\n// --------------------------------------------------------------\n\npublic class QuickSort_Demo {\n    \n    static SortingAlgorithm sa;\n    \n    \n  \n\n    // Utility method to print an array\n    public static void printArray(int[] arr)\n    {\n        for (int num : arr) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args)\n    {\n        \n          int choice = 2;\n    \n        if (choice == 1) {\n            sa = new QuickSort();\n        } else {\n            sa = new QuickSortIterative();\n        }\n        \n        int[] data = {34, 7, 23, 32, 5, 62};\n\n        System.out.println(\"Original Array:\");\n        printArray(data);\n\n        // Call the QuickSort class\n        sa.sort(data);\n\n        System.out.println(\"\\nSorted Array:\");\n        printArray(data);\n    }\n\n}\n","type":"content","url":"/xquicksortdemo#how-quicksort-works-iterative-version","position":5},{"hierarchy":{"lvl1":"Quicksort - Linked Lists"},"type":"lvl1","url":"/xquicksortlinkedlists","position":0},{"hierarchy":{"lvl1":"Quicksort - Linked Lists"},"content":"Annotated/*\n * Quick Sort using Linked Lists\n * By James Goudy\n *\n * This program shows TWO different versions of QuickSort\n * for a singly linked list:\n *   1) A recursive version\n *   2) An iterative (loop-based) version that uses a Stack\n *\n * In main(), you can choose which version to run.\n */\n\npackage inst_quicksort_linklists;\n\nimport java.util.Stack;\n\n// -----------------------------------------------------\n// SortingAlgorithm interface\n// -----------------------------------------------------\n// An interface is like a \"contract\" that says:\n// \"Any class that implements me MUST have this method.\"\n// Here, any sorting class must have a quickSort() method\n// that takes the head of a linked list and returns\n// the (new) head of the sorted list.\n// -----------------------------------------------------\ninterface SortingAlgorithm {\n\n    Node quickSort(Node head);\n}\n\n// -----------------------------------------------------\n// Node class: a simple node for a singly linked list\n// -----------------------------------------------------\n// Each Node holds one integer (data) and a reference\n// (pointer) to the next Node in the list.\n// If next == null, this is the last node in the list.\n// -----------------------------------------------------\nclass Node {\n\n    int data;   // the value stored in this node\n    Node next;  // reference to the next node in the list\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n// -----------------------------------------------------\n// RecursiveQuickSortLinkedList\n// -----------------------------------------------------\n// This class uses a RECURSIVE version of QuickSort.\n//\n// Basic idea of QuickSort on a linked list:\n// 1) Choose a pivot (here: the first node).\n// 2) Split the list into:\n//    - nodes with values LESS than the pivot\n//    - nodes with values GREATER or EQUAL to the pivot\n// 3) Recursively sort the two smaller lists.\n// 4) Connect: less list + pivot + greater list\n// -----------------------------------------------------\nclass RecursiveQuickSortLinkedList implements SortingAlgorithm {\n\n    // Entry point for recursive QuickSort\n    public Node quickSort(Node head)\n    {\n        // Base Case:\n        // If the list is empty (head == null)\n        // OR has only one element (head.next == null),\n        // then it is already sorted.\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // Use the first node as the pivot\n        Node pivot = head;\n\n        // These will be the heads and tails of two new lists:\n        //  - less: nodes with data < pivot.data\n        //  - greater: nodes with data >= pivot.data\n        Node lessHead = null, lessTail = null;\n        Node greaterHead = null, greaterTail = null;\n\n        // Start from the node after the pivot\n        Node current = head.next;\n\n        // -------------------------------------------------\n        // Partition loop:\n        // Walk through the list, and put each node into\n        // either the \"less\" list or the \"greater\" list.\n        // -------------------------------------------------\n        while (current != null) {\n            if (current.data < pivot.data) {\n                // Goes into the \"less\" list\n                if (lessHead == null) {\n                    // First node in the less list\n                    lessHead = lessTail = current;\n                } else {\n                    // Append to the end of the less list\n                    lessTail.next = current;\n                    lessTail = current;\n                }\n            } else {\n                // Goes into the \"greater\" list\n                if (greaterHead == null) {\n                    // First node in the greater list\n                    greaterHead = greaterTail = current;\n                } else {\n                    // Append to the end of the greater list\n                    greaterTail.next = current;\n                    greaterTail = current;\n                }\n            }\n            // Move to the next node in the original list\n            current = current.next;\n        }\n\n        // -------------------------------------------------\n        // Important cleanup step:\n        // Make sure the less and greater lists have\n        // proper endings (tails point to null).\n        // This helps prevent accidental \"cycles\" in the list.\n        // -------------------------------------------------\n        if (lessTail != null) {\n            lessTail.next = null;\n        }\n        if (greaterTail != null) {\n            greaterTail.next = null;\n        }\n\n        // Recursively sort the two sublists:\n        //  - lessHead: all nodes < pivot\n        //  - greaterHead: all nodes >= pivot\n        lessHead = quickSort(lessHead);\n        greaterHead = quickSort(greaterHead);\n\n        // Finally, stitch everything together:\n        // less list + pivot + greater list\n        return concatenate(lessHead, pivot, greaterHead);\n    }\n\n    // -----------------------------------------------------\n    // concatenate()\n    // -----------------------------------------------------\n    // This helper method connects three pieces:\n    // 1) less list (may be null)\n    // 2) the pivot node (single node)\n    // 3) greater list (may be null)\n    //\n    // Returns the head of the new combined list.\n    // -----------------------------------------------------\n    private Node concatenate(Node less, Node pivot, Node greater)\n    {\n        // Pivot should point to the start of the greater list\n        pivot.next = greater;\n\n        // If there is no \"less\" list, pivot is the new head\n        if (less == null) {\n            return pivot;\n        }\n\n        // Otherwise, walk to the end of the less list\n        Node current = less;\n        while (current.next != null) {\n            current = current.next;\n        }\n\n        // Attach pivot (and greater) to the end of less\n        current.next = pivot;\n\n        // The head of the combined list is still \"less\"\n        return less;\n    }\n\n    // -----------------------------------------------------\n    // printList()\n    // -----------------------------------------------------\n    // Utility method to print the linked list in a friendly\n    // format like: 8 -> 3 -> 7 -> null\n    // -----------------------------------------------------\n    public void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n// ---------------------------------------------------------\n// IterativeQuickSortLinkedList\n// ---------------------------------------------------------\n// This class uses an ITERATIVE version of QuickSort.\n// Instead of using recursion, we use a Stack to keep\n// track of which part (range) of the list we still\n// need to process.\n// ---------------------------------------------------------\nclass IterativeQuickSortLinkedList implements SortingAlgorithm {\n\n    // -----------------------------------------------------\n    // Range class:\n    // A small helper class that stores a \"sub-list\" using\n    // two pointers:\n    //   start: first node in the range\n    //   end:   one past the last node (EXCLUSIVE)\n    //\n    // The range is [start, end), meaning:\n    //   start is included, end is NOT included.\n    // -----------------------------------------------------\n    private static class Range {\n        Node start, end; // end is EXCLUSIVE\n        Range(Node s, Node e) {\n            start = s;\n            end   = e;\n        }\n    }\n\n    @Override\n    public Node quickSort(Node head) {\n\n        // Base case: empty or single-node list is already sorted\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // -------------------------------------------------\n        // Use a Stack to store the ranges we need to sort.\n        // We start with the entire list: [head, null)\n        // (null means \"go all the way to the end\").\n        // -------------------------------------------------\n        Stack<Range> stack = new Stack<>();\n        stack.push(new Range(head, null)); // whole list: [head, null)\n\n        // -------------------------------------------------\n        // While there are still ranges to process\n        // -------------------------------------------------\n        while (!stack.isEmpty()) {\n            Range r = stack.pop();\n            Node start = r.start;\n            Node end   = r.end;\n\n            // If the range has 0 or 1 elements, it is already sorted.\n            // Conditions:\n            //  - start == null: empty\n            //  - start == end: empty\n            //  - start.next == end: exactly one element\n            if (start == null || start == end || start.next == end) {\n                continue;\n            }\n\n            // ---- Partition [start, end) around pivot = start ----\n            Node pivot = start;\n            Node lessH = null, lessT = null;        // \"less than pivot\" list\n            Node greaterH = null, greaterT = null;  // \"greater or equal\" list\n\n            // Start from the node after the pivot\n            Node curr = pivot.next;\n\n            // Walk through the range [pivot.next, end)\n            while (curr != end) {\n                Node next = curr.next; // Save next node before re-linking\n\n                if (curr.data < pivot.data) {\n                    // Goes in the \"less\" list\n                    if (lessH == null) {\n                        lessH = lessT = curr;\n                    } else {\n                        lessT.next = curr;\n                        lessT = curr;\n                    }\n                } else {\n                    // Goes in the \"greater or equal\" list\n                    if (greaterH == null) {\n                        greaterH = greaterT = curr;\n                    } else {\n                        greaterT.next = curr;\n                        greaterT = curr;\n                    }\n                }\n\n                // Move to the next node in the original range\n                curr = next;\n            }\n\n            // ---- Re-link the nodes in sorted order within this range ----\n            // We want: less list -> pivot -> greater list -> end\n\n            // Attach pivot AFTER less list (if it exists)\n            if (lessT != null) {\n                lessT.next = pivot;\n            }\n\n            // Pivot should point to the start of the greater list\n            pivot.next = greaterH;\n\n            // If there is a greater list, its tail should point to end\n            if (greaterT != null) {\n                greaterT.next = end;\n            } else {\n                // No greater list: pivot should point directly to end\n                pivot.next = end;\n            }\n\n            // newStart is the first node in this now-partially-sorted range\n            Node newStart = (lessH != null) ? lessH : pivot;\n\n            // ---- Fix list head or previous pointer ----\n            // If this range started at the overall head of the list,\n            // then we need to update the head.\n            if (start == head) {\n                head = newStart;\n            } else {\n                // Otherwise, find the node whose next was 'start'\n                // and make it point to newStart.\n                Node prev = head;\n                while (prev != null && prev.next != start) {\n                    prev = prev.next;\n                }\n                if (prev != null) {\n                    prev.next = newStart;\n                }\n            }\n\n            // ---- Push the two new subranges onto the stack ----\n            // Right subrange: [pivot.next, end)\n            if (pivot.next != null && pivot.next != end) {\n                stack.push(new Range(pivot.next, end));\n            }\n\n            // Left subrange: [newStart, pivot)\n            if (newStart != pivot) {\n                stack.push(new Range(newStart, pivot));\n            }\n        }\n\n        // When the stack is empty, everything is sorted\n        return head;\n    }\n\n    // Utility: print list (same idea as above)\n    public void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n// ---------------------------------------------------------\n// Inst_quicksort_linklists (Main Class)\n// ---------------------------------------------------------\n// This is the class with the main() method.\n// It builds a sample linked list, lets you choose which\n// QuickSort version to use (recursive or iterative),\n// and then prints the original and sorted lists.\n// ---------------------------------------------------------\npublic class Inst_quicksort_linklists {\n\n    // -----------------------------------------------------\n    // Helper: buildList()\n    // -----------------------------------------------------\n    // Takes a regular int[] array and builds a linked list\n    // with the same values in the same order.\n    // Returns the head of that new linked list.\n    // -----------------------------------------------------\n    private static Node buildList(int[] arr)\n    {\n        if (arr.length == 0) {\n            return null;\n        }\n\n        // First node becomes the head\n        Node head = new Node(arr[0]);\n        Node curr = head;\n\n        // Attach the rest of the nodes\n        for (int i = 1; i < arr.length; i++) {\n            curr.next = new Node(arr[i]);\n            curr = curr.next;\n        }\n\n        return head;\n    }\n\n    // -----------------------------------------------------\n    // Helper: printList()\n    // -----------------------------------------------------\n    // Another simple print method for convenience.\n    // -----------------------------------------------------\n    private static void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args)\n    {\n        // Sample data to be sorted\n        int[] data = {8, 3, 7, 1, 9, 2, 6, 5};\n\n        // --------------------------------------------------\n        // CHOICE VARIABLE\n        // --------------------------------------------------\n        // 1 = use the RECURSIVE QuickSort\n        // any other value = use the ITERATIVE QuickSort\n        //\n        // Try changing this to 1 and 2 and see how both\n        // versions behave with the same data.\n        // --------------------------------------------------\n        int choice = 10;     // <<< change this to 1 for recursive, 2 for iterative\n\n        SortingAlgorithm sorter;\n\n        // Decide which sorting algorithm to use\n        if (choice == 1) {\n            System.out.println(\"Running Recursive QuickSort...\");\n            sorter = new RecursiveQuickSortLinkedList();\n        } else {\n            System.out.println(\"Running Iterative QuickSort...\");\n            sorter = new IterativeQuickSortLinkedList();\n        }\n\n        // Build the original linked list from the array\n        Node list = buildList(data);\n\n        System.out.println(\"Original List:\");\n        printList(list);\n\n        // Sort the list using the selected algorithm\n        Node sorted = sorter.quickSort(list);\n\n        System.out.println(\"\\nSorted List:\");\n        printList(sorted);\n    }\n\n}\n\n\nNon Annotated/*\n\nQuick Sort using Linked Lists\nBy James Goudy\n\n */\npackage inst_quicksort_linklists;\n\nimport java.util.Stack;\n\ninterface SortingAlgorithm {\n\n    Node quickSort(Node head);\n}\n\n// Simple node for a singly linked list\nclass Node {\n\n    int data;\n    Node next;\n\n    Node(int data)\n    {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nclass RecursiveQuickSortLinkedList implements SortingAlgorithm {\n\n    // QuickSort Entry Point\n    public Node quickSort(Node head)\n    {\n        // Base Case\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        // Partition using head as pivot\n        Node pivot = head;\n        Node lessHead = null, lessTail = null;\n        Node greaterHead = null, greaterTail = null;\n\n        Node current = head.next;\n\n        while (current != null) {\n            if (current.data < pivot.data) {\n                if (lessHead == null) {\n                    lessHead = lessTail = current;\n                } else {\n                    lessTail.next = current;\n                    lessTail = current;\n                }\n            } else {\n                if (greaterHead == null) {\n                    greaterHead = greaterTail = current;\n                } else {\n                    greaterTail.next = current;\n                    greaterTail = current;\n                }\n            }\n            current = current.next;\n        }\n\n        // Prevent accidental list cycles\n        if (lessTail != null) {\n            lessTail.next = null;\n        }\n        if (greaterTail != null) {\n            greaterTail.next = null;\n        }\n\n        // Recursively sort sublists\n        lessHead = quickSort(lessHead);\n        greaterHead = quickSort(greaterHead);\n\n        // Stitch together: less + pivot + greater\n        return concatenate(lessHead, pivot, greaterHead);\n    }\n\n    // Helper: combine lists\n    private Node concatenate(Node less, Node pivot, Node greater)\n    {\n        pivot.next = greater;\n\n        if (less == null) {\n            return pivot;\n        }\n\n        Node current = less;\n        while (current.next != null) {\n            current = current.next;\n        }\n        current.next = pivot;\n\n        return less;\n    }\n\n    // Utility: print list\n    public void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n\nclass IterativeQuickSortLinkedList implements SortingAlgorithm {\n\n    private static class Range {\n        Node start, end; // end is EXCLUSIVE\n        Range(Node s, Node e) {\n            start = s;\n            end   = e;\n        }\n    }\n\n    @Override\n    public Node quickSort(Node head) {\n\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        Stack<Range> stack = new Stack<>();\n        stack.push(new Range(head, null)); // whole list: [head, null)\n\n        while (!stack.isEmpty()) {\n            Range r = stack.pop();\n            Node start = r.start;\n            Node end   = r.end;\n\n            // 0 or 1 element in this range\n            if (start == null || start == end || start.next == end) {\n                continue;\n            }\n\n            // ---- Partition [start, end) around pivot = start ----\n            Node pivot = start;\n            Node lessH = null, lessT = null;\n            Node greaterH = null, greaterT = null;\n\n            Node curr = pivot.next;\n\n            while (curr != end) {\n                Node next = curr.next; // save before re-linking\n\n                if (curr.data < pivot.data) {\n                    if (lessH == null) {\n                        lessH = lessT = curr;\n                    } else {\n                        lessT.next = curr;\n                        lessT = curr;\n                    }\n                } else {\n                    if (greaterH == null) {\n                        greaterH = greaterT = curr;\n                    } else {\n                        greaterT.next = curr;\n                        greaterT = curr;\n                    }\n                }\n                curr = next;\n            }\n\n            // ---- Re-link: less -> pivot -> greater -> end ----\n            if (lessT != null) {\n                lessT.next = pivot;\n            }\n            pivot.next = greaterH;\n            if (greaterT != null) {\n                greaterT.next = end;\n            } else {\n                // no greater list\n                pivot.next = end;\n            }\n\n            Node newStart = (lessH != null) ? lessH : pivot;\n\n            // ---- Fix list head or previous pointer ----\n            if (start == head) {\n                head = newStart;\n            } else {\n                // find node whose next was 'start' and re-point it\n                Node prev = head;\n                while (prev != null && prev.next != start) {\n                    prev = prev.next;\n                }\n                if (prev != null) {\n                    prev.next = newStart;\n                }\n            }\n\n            // ---- Push subranges: right then left ----\n            // Right: [pivot.next, end)\n            if (pivot.next != null && pivot.next != end) {\n                stack.push(new Range(pivot.next, end));\n            }\n            // Left: [newStart, pivot)\n            if (newStart != pivot) {\n                stack.push(new Range(newStart, pivot));\n            }\n        }\n\n        return head;\n    }\n\n    // Utility: print list\n    public void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n}\n\n\n\npublic class Inst_quicksort_linklists {\n\n    // Helper: build a linked list from an array\n    private static Node buildList(int[] arr)\n    {\n        if (arr.length == 0) {\n            return null;\n        }\n        Node head = new Node(arr[0]);\n        Node curr = head;\n        for (int i = 1; i < arr.length; i++) {\n            curr.next = new Node(arr[i]);\n            curr = curr.next;\n        }\n        return head;\n    }\n\n    // Helper: print list\n    private static void printList(Node head)\n    {\n        while (head != null) {\n            System.out.print(head.data + \" -> \");\n            head = head.next;\n        }\n        System.out.println(\"null\");\n    }\n\n    public static void main(String[] args)\n    {\n        int[] data = {8, 3, 7, 1, 9, 2, 6, 5};\n\n        // ------------------------------------------------------\n        // CHOICE VARIABLE\n        // 1 = recursive quicksort\n        // 2 = iterative quicksort\n        // ------------------------------------------------------\n        int choice = 10;     // <<< change this to 2 for iterative\n\n        SortingAlgorithm sorter;\n\n        if (choice == 1) {\n            System.out.println(\"Running Recursive QuickSort...\");\n            sorter = new RecursiveQuickSortLinkedList();\n        } else {\n            System.out.println(\"Running Iterative QuickSort...\");\n            sorter = new IterativeQuickSortLinkedList();\n        }\n\n        // Build original list\n        Node list = buildList(data);\n\n        System.out.println(\"Original List:\");\n        printList(list);\n\n        // Sort using selected algorithm\n        Node sorted = sorter.quickSort(list);\n\n        System.out.println(\"\\nSorted List:\");\n        printList(sorted);\n    }\n\n}\n","type":"content","url":"/xquicksortlinkedlists","position":1},{"hierarchy":{"lvl1":"Singly Linked List"},"type":"lvl1","url":"/xsinglylinkedlistrev3","position":0},{"hierarchy":{"lvl1":"Singly Linked List"},"content":"Ternary Operator\n\n[Singly Linked List](# Singly-Linked-List-Code)\n\nDefinition\n\nsingly linked list is a type of linked list that is unidirectional. It can be traversed in only one direction from the head to the last node (tail). The last node always points to null","type":"content","url":"/xsinglylinkedlistrev3","position":1},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Ternary Operator"},"type":"lvl2","url":"/xsinglylinkedlistrev3#ternary-operator","position":2},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Ternary Operator"},"content":"Ternary Operator is an instruction that consists of three parts.\nCondition Part - test if something is true or false\nTrue Part - what is returned if the condition is true\nFalse Part - what is returned if the condition is false\n\nx = **(Conditional Part) ** ? True Part : False Part;// Example\ny = 3;\nx = (y < 4) ? \"y is less than four\": \"y is greater than four\"\nSystem.out.write(x);\n\n// Output\n// y is less than four","type":"content","url":"/xsinglylinkedlistrev3#ternary-operator","position":3},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Lecture Code"},"type":"lvl2","url":"/xsinglylinkedlistrev3#lecture-code","position":4},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Lecture Code"},"content":"","type":"content","url":"/xsinglylinkedlistrev3#lecture-code","position":5},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List Code","lvl2":"Lecture Code"},"type":"lvl3","url":"/xsinglylinkedlistrev3#singly-linked-list-code","position":6},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List Code","lvl2":"Lecture Code"},"content":"The Link and the controlling Linked List are written as two separate classes/*\n * Singly Linked List\n *\n * singlylinkedlists_rev3\n * Programmer: James Goudy\n *\n */\npackage singlylinkedlists_rev3;\n\nclass Link\n{\n\n    // Data goes here\n    public String city = \"\";\n    public int population = 0;\n\n    // link to next node\n    public Link next;\n\n    // constructor\n    public Link(String city, int population)\n    {\n        this.city = city;\n        this.population = population;\n    }\n\n    // display the link\n    public void displayLink()\n    {\n        System.out.print(\"{\" + city + \", \" + population + \"} \");\n    }\n\n}\n\n\nclass LinkedList\n{\n\n    // first is a reference / \"address\" of the first link\n    private Link first;\n\n    // constructor\n    public LinkedList()\n    {\n        first = null;\n    }\n\n    //Check if the list is empty\n    public boolean isEmpty()\n    {\n        return (first == null);\n    }\n\n    // insert at the front \n    // of the list (front[left] -- to --> back[right]) \n    public void insertFirst(String city, int population)\n    {\n\n        // create a new link\n        Link newLink = new Link(city, population);\n\n        // the new link is to the left or in front of first\n        // the new link will make first in the second spot\n        // so newLink.next has to point to the address first\n        newLink.next = first;\n\n        // now that the newLink.next is looking at the seond spot\n        // or the next spot, first can have the address of the newLink\n        first = newLink;\n\n    }\n\n    //This function displays the linked list\n    public void displayList()\n    {\n        System.out.print(\"\\nList\\n(first --> last): \");\n\n        //temp variable to hold first\n        Link current = first;\n\n        while (current != null)\n        {\n            current.displayLink();\n\n            // move to the next  link\n            current = current.next;\n        }\n\n        System.out.println();\n    } //end of display list\n\n    public boolean findCity(String city)\n    {\n        boolean found = false;\n\n        Link current = first;\n        // iterate through the loop\n        while (current != null)\n        {\n            // check if current city matches search city\n            // set found to true and break out of the loop\n            if (current.city.equals(city))\n            {\n                found = true;\n                break;\n            }\n\n            current = current.next;\n\n        }\n\n        return found;\n    }\n\n    // delete first\n    public Link deleteFirst()\n    {\n\n        // temp variable to hold first address\n        // temp is pointing to an address\n        Link temp = first;\n\n        if (!isEmpty())\n        {\n            // set variable to second spot\n            first = first.next;\n        }\n\n        // return a link to object \n        // in case calling program wants\n        // to retreive the deleted data\n        return temp;\n    }\n\n    public void deleteCity(String city)\n    {\n        // assumes the data does not have duplicates\n\n        //need to check if the city was found\n        boolean found = false;\n\n        Link current = first;\n        Link prev = first;\n        Link temp;\n\n        // check if city is in the first node\n        if (first.city.equals(city))\n        {\n            temp = first;\n            first = first.next;\n            temp = null;\n            System.out.println(\"City was deleted\");\n            return;\n        }\n\n        // start at the beginning of list\n        while (current != null)\n        {\n            // check if the current city matches the search city\n            if (current.city.equals(city))\n            {\n                found = true;\n\n                // break out of the while statement\n                break;\n            }\n\n            // set the prev variable\n            prev = current;\n\n            // move to the next node\n            current = current.next;\n        }\n\n        // check if the while statment made it to \n        // the end of the loop\n        if (found == false)\n        {\n            System.out.println(\"\\n*** City not found - Nothing deleted\");\n            return;\n        }\n\n        // delete process\n        prev.next = current.next;\n\n        current = null;\n        System.out.println(\"\\n*** City was successfully delete\");\n\n    }\n\n    public void deleteList()\n    {\n        while (first != null)\n        {\n            deleteFirst();\n        }\n\n    }\n\n    // city is the location of where the new data \n    // will be inserted (after)\n    // newCity and newPop are the new city and new population\n    public void insertAfter(String city, String newCity, int newPop)\n    {\n        boolean found = false;\n        Link current = first;\n\n        //create a new link\n        Link NewLink = new Link(newCity, newPop);\n\n        try\n        {\n            // iterate through loop\n            while (current != null)\n            {\n                // break out of the loop if found\n                // stops the loop at the found city\n                // sets found to true\n                if (current.city.equals(city))\n                {\n                    found = true;\n                    break;\n                }\n\n                // move to next node\n                current = current.next;\n            }\n\n            // insert process\n            NewLink.next = current.next;\n            current.next = NewLink;\n\n        } catch (Exception e)\n        {\n            System.out.println(\"**Error**\\n\" + e.getMessage() + \"\\n***\\n\");\n        }\n\n    }\n\n} // end of class\n\npublic class SinglyLinkedLists_Rev3\n{\n\n    public static void main(String[] args)\n    {\n        LinkedList theList = new LinkedList();\n\n\n        theList.insertFirst(\"Kali\", 32000);\n        theList.insertFirst(\"Whitefish\", 7700);\n        theList.insertFirst(\"Polson\", 20000);\n        theList.insertFirst(\"Chicago\", 13000000);\n        theList.insertFirst(\"Convoy\", 500);\n\n        theList.displayList();\n\n        System.out.println(\"Find Kali : \" + theList.findCity(\"Kali\"));\n\n        // ternary operator\n        String output = (theList.findCity(\"Polson\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Polson: \" + output);\n\n        output = (theList.findCity(\"Somers\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Somers: \" + output);\n\n        theList.deleteFirst();\n        theList.displayList();\n\n        theList.deleteCity(\"Chicago\");\n        theList.displayList();\n\n        theList.insertAfter(\"Polson\", \"New York\", 10000000);\n        theList.displayList();\n\n        theList.deleteList();\n        theList.displayList();\n    }\n\n}\n","type":"content","url":"/xsinglylinkedlistrev3#singly-linked-list-code","position":7},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List - Nested Link Class","lvl2":"Lecture Code"},"type":"lvl3","url":"/xsinglylinkedlistrev3#singly-linked-list-nested-link-class","position":8},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List - Nested Link Class","lvl2":"Lecture Code"},"content":"/*\n * Single Link List\n *\n * SingleLinkList_nested_Rev3\n * Programmer: James Goudy\n *\n */\npackage singlylinkedlists_nested_rev3;\n\nclass LinkedList\n{\n\n    class Link\n    {\n\n        // Data goes here\n        public String city = \"\";\n        public int population = 0;\n\n        // link to next node\n        public Link next;\n\n        // constructor\n        public Link(String city, int population)\n        {\n            this.city = city;\n            this.population = population;\n        }\n\n        // display the link\n        public void displayLink()\n        {\n            System.out.print(\"{\" + city + \", \" + population + \"} \");\n        }\n\n    }\n\n    // first is a reference / \"address\" of the first link\n    private Link first;\n\n    // constructor\n    public LinkedList()\n    {\n        first = null;\n    }\n\n    //Check if the list is empty\n    public boolean isEmpty()\n    {\n        return (first == null);\n    }\n\n    // insert at the front \n    // of the list (front[left] -- to --> back[right]) \n    public void insertFirst(String city, int population)\n    {\n\n        // create a new link\n        Link newLink = new Link(city, population);\n\n        // the new link is to the left or in front of first\n        // the new link will make first in the second spot\n        // so newLink.next has to point to the address first\n        newLink.next = first;\n\n        // now that the newLink.next is looking at the seond spot\n        // or the next spot, first can have the address of the newLink\n        first = newLink;\n\n    }\n\n    //This function displays the linked list\n    public void displayList()\n    {\n        System.out.print(\"\\nList\\n(first --> last): \");\n\n        //temp variable to hold first\n        Link current = first;\n\n        while (current != null)\n        {\n            current.displayLink();\n\n            // move to the next  link\n            current = current.next;\n        }\n\n        System.out.println();\n    } //end of display list\n\n    public boolean findCity(String city)\n    {\n        boolean found = false;\n\n        Link current = first;\n        // iterate through the loop\n        while (current != null)\n        {\n            // check if current city matches search city\n            // set found to true and break out of the loop\n            if (current.city.equals(city))\n            {\n                found = true;\n                break;\n            }\n\n            current = current.next;\n\n        }\n\n        return found;\n    }\n\n    // delete first\n    public Link deleteFirst()\n    {\n\n        // temp variable to hold first address\n        // temp is pointing to an address\n        Link temp = first;\n\n        if (!isEmpty())\n        {\n            // set variable to second spot\n            first = first.next;\n        }\n\n        // return a link to object \n        // in case calling program wants\n        // to retreive the deleted data\n        return temp;\n    }\n\n    public void deleteCity(String city)\n    {\n        // assumes the data does not have duplicates\n\n        //need to check if the city was found\n        boolean found = false;\n\n        Link current = first;\n        Link prev = first;\n        Link temp;\n\n        // check if city is in the first node\n        if (first.city.equals(city))\n        {\n            temp = first;\n            first = first.next;\n            temp = null;\n            System.out.println(\"City was deleted\");\n            return;\n        }\n\n        // start at the beginning of list\n        while (current != null)\n        {\n            // check if the current city matches the search city\n            if (current.city.equals(city))\n            {\n                found = true;\n\n                // break out of the while statement\n                break;\n            }\n\n            // set the prev variable\n            prev = current;\n\n            // move to the next node\n            current = current.next;\n        }\n\n        // check if the while statment made it to \n        // the end of the loop\n        if (found == false)\n        {\n            System.out.println(\"\\n*** City not found - Nothing deleted\");\n            return;\n        }\n\n        // delete process\n        prev.next = current.next;\n\n        current = null;\n        System.out.println(\"\\n*** City was successfully delete\");\n\n    }\n\n    public void deleteList()\n    {\n        while (first != null)\n        {\n            deleteFirst();\n        }\n\n    }\n\n    // city is the location of where the new data \n    // will be inserted (after)\n    // newCity and newPop are the new city and new population\n    public void insertAfter(String city, String newCity, int newPop)\n    {\n        boolean found = false;\n        Link current = first;\n\n        //create a new link\n        Link NewLink = new Link(newCity, newPop);\n\n        try\n        {\n            // iterate through loop\n            while (current != null)\n            {\n                // break out of the loop if found\n                // stops the loop at the found city\n                // sets found to true\n                if (current.city.equals(city))\n                {\n                    found = true;\n                    break;\n                }\n\n                // move to next node\n                current = current.next;\n            }\n\n            // insert process\n            NewLink.next = current.next;\n            current.next = NewLink;\n\n        } catch (Exception e)\n        {\n            System.out.println(\"**Error**\\n\" + e.getMessage() + \"\\n***\\n\");\n        }\n\n    }\n\n} // e\n\npublic class Singlylinkedlists_nested_rev3\n{\n\n    public static void main(String[] args)\n    {\n\n        LinkedList theList = new LinkedList();\n        \n        // how to create a Link from a nested class\n        // note that the new link has to be created from the\n        // outer link ('theList')\n        LinkedList.Link aLink =  theList.new Link(\"Detroit\", 2000000);\n        \n        // display the created link\n        System.out.println(\"Created Inner Link\");\n        aLink.displayLink();\n        System.out.println(\"\\n\\n\");\n        \n        \n\n        theList.insertFirst(\"Kali\", 32000);\n        theList.insertFirst(\"Whitefish\", 7700);\n        theList.insertFirst(\"Polson\", 20000);\n        theList.insertFirst(\"Chicago\", 13000000);\n        theList.insertFirst(\"Convoy\", 500);\n\n        theList.displayList();\n\n        System.out.println(\"Find Kali : \" + theList.findCity(\"Kali\"));\n\n        // ternary operator\n        String output = (theList.findCity(\"Polson\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Polson: \" + output);\n\n        output = (theList.findCity(\"Somers\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Somers: \" + output);\n\n        theList.deleteFirst();\n        theList.displayList();\n\n        theList.deleteCity(\"Chicago\");\n        theList.displayList();\n\n        theList.insertAfter(\"Polson\", \"New York\", 10000000);\n        theList.displayList();\n\n        theList.deleteList();\n        theList.displayList();\n\n    }\n\n}\n\n\nEnd Of Topic","type":"content","url":"/xsinglylinkedlistrev3#singly-linked-list-nested-link-class","position":9},{"hierarchy":{"lvl1":"Sorting Algorithms"},"type":"lvl1","url":"/xsortalgorithms","position":0},{"hierarchy":{"lvl1":"Sorting Algorithms"},"content":"Bubble Sort","type":"content","url":"/xsortalgorithms","position":1},{"hierarchy":{"lvl1":"Sorting Algorithms","lvl2":"Visualizations"},"type":"lvl2","url":"/xsortalgorithms#visualizations","position":2},{"hierarchy":{"lvl1":"Sorting Algorithms","lvl2":"Visualizations"},"content":"Visual Aglo\n\nToptal\n\nComparison Sorting Algorithms\n\nSort Visualizer\n\nEnd Of Topic","type":"content","url":"/xsortalgorithms#visualizations","position":3},{"hierarchy":{"lvl1":"Bubble Sort"},"type":"lvl1","url":"/xsort-bubble","position":0},{"hierarchy":{"lvl1":"Bubble Sort"},"content":"","type":"content","url":"/xsort-bubble","position":1},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Key Ideas"},"type":"lvl3","url":"/xsort-bubble#key-ideas","position":2},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Key Ideas"},"content":"Bubble Sort\n\nDefinition\n\nBubble Sort is a simple sorting algorithm that repeatedly iterates through the list or array. It compares adjacent elements and swaps them if they are in the wrong order. The algorithm repeatedly passes through the list until the list is sorted. It is a comparison sort and is named for the way smaller or larger elements “bubble” to the top of the list.","type":"content","url":"/xsort-bubble#key-ideas","position":3},{"hierarchy":{"lvl1":"Bubble Sort","lvl2":"Performance"},"type":"lvl2","url":"/xsort-bubble#performance","position":4},{"hierarchy":{"lvl1":"Bubble Sort","lvl2":"Performance"},"content":"Bubble sort has a worst-case and average complexity of On^2^.","type":"content","url":"/xsort-bubble#performance","position":5},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Visualizations","lvl2":"Performance"},"type":"lvl3","url":"/xsort-bubble#visualizations","position":6},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Visualizations","lvl2":"Performance"},"content":"Visual Aglo\n\nToptal\n\nComparison Sorting Algorithms\n\nSort Visualizer","type":"content","url":"/xsort-bubble#visualizations","position":7},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Videos","lvl2":"Performance"},"type":"lvl3","url":"/xsort-bubble#videos","position":8},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Videos","lvl2":"Performance"},"content":"\n\n---\n\n---","type":"content","url":"/xsort-bubble#videos","position":9},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Lecture Code","lvl2":"Performance"},"type":"lvl3","url":"/xsort-bubble#lecture-code","position":10},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Lecture Code","lvl2":"Performance"},"content":"/*\n * Programmer: James Goudy\n * Project: Bubble Sort\n */\npackage com.mycompany.bubblesort_lecturecode;\n\nimport java.util.Random;\n\nclass BubbleSort {\n\n    // arrInt is an array of integers\n    // numDataElements is the actual count \n    // of elements of data in the array\n    // algorithm assumes the data is contiguous\n    int arrInt[];\n    int numDataElments;\n\n    public BubbleSort(int[] arrInt, int numDataElments) {\n        this.arrInt = arrInt;\n        this.numDataElments = numDataElments;\n    }\n\n    public void Sort() {\n        // \n        int n = numDataElments;\n\n        for (int c = 0; c < n; c++) {\n            for (int j = 1; j < (n); j++) {\n                \n                // check if the left element is \n                // greater to the one on the right\n                // \"Bubble\" the lowest to the left\n\n                if (arrInt[j - 1] > arrInt[j]) {\n                    // swap left element arr[j-1]\n                    // with the one on the right and arr[j]\n                    \n                    // store left one in temp\n                    int temp = arrInt[j - 1];\n                    //copy the right into the left\n                    arrInt[j - 1] = arrInt[j];\n                    //copy the left into the right\n                    arrInt[j] = temp;\n                }\n            }\n        }\n    }\n\n}\n\npublic class BubbleSort_LectureCode {\n\n    static int arrSize = 8;\n    //static int theArray[] = new int[arrSize];\n    static int theArray[] ={3,60,35,2,45,320,5,1}; \n    \n    static void fillTheArray()\n    {\n        Random RNG  = new Random();\n        for(int c = 0; c < arrSize; c++)\n        {\n            theArray[c] = RNG.nextInt(0,(arrSize*10));\n        }\n    }\n    \n    static void printArray(int anArray[], int numOfDataElements)\n    {\n        System.out.println(\"\");\n        for (int i = 0; i < numOfDataElements; i++) {\n            System.out.print(anArray[i] + \" \");\n        }\n        System.out.println(\"\\n--------------\\n\");\n        \n    }\n    \n    public static void main(String[] args) {\n       \n        // option to randomly fill the array\n        //fillTheArray();\n        \n        printArray(theArray, arrSize);\n        \n        BubbleSort bs = new BubbleSort(theArray, arrSize);\n        bs.Sort();\n        \n        printArray(theArray, arrSize);\n               \n        \n    }\n}\n\n/*\n3 60 35 2 45 320 5 1 \n--------------\n\n\n1 2 3 5 35 45 60 320 \n--------------\n*/\n\nEnd Of Topic","type":"content","url":"/xsort-bubble#lecture-code","position":11},{"hierarchy":{"lvl1":"Heap Sort"},"type":"lvl1","url":"/xsort-heapsort","position":0},{"hierarchy":{"lvl1":"Heap Sort"},"content":"","type":"content","url":"/xsort-heapsort","position":1},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Introduction"},"type":"lvl2","url":"/xsort-heapsort#introduction","position":2},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Introduction"},"content":"Merge Sort works by taking the chaotic mess of an array and breaking it down into smaller and smaller pieces until each piece is trivially simple to sort. It follows a divide-and-conquer rhythm: first divide the array into two halves, then divide those halves again, and keep going until each sub-array contains just one element. A single element is, by definition, already sorted. Once everything is split into these tiny, manageable chunks, Merge Sort begins the conquer phase—carefully merging pairs of sorted sub-arrays back together. During each merge, it compares the fronts of both lists and chooses the smaller element, building a new, larger sorted list one element at a time.\n\nThe brilliance of Merge Sort lies in this merging step: it guarantees that every combination of two sorted lists becomes one sorted list, and it repeats this until the entire array is reconstructed in perfect order. Its performance is reliably O(n log n), regardless of the data’s original state, making it one of the most stable and predictable sorting algorithms in computer science. It does require extra memory—space to hold the temporary merged lists—but in exchange, it delivers elegant consistency and stability. Merge Sort doesn’t try to be clever; it just applies patient, mathematical discipline to tame disorder.","type":"content","url":"/xsort-heapsort#introduction","position":3},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"What Is a Heap? (With Diagrams)"},"type":"lvl2","url":"/xsort-heapsort#what-is-a-heap-with-diagrams","position":4},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"What Is a Heap? (With Diagrams)"},"content":"A heap is a special kind of binary tree stored inside an array.\nIt follows two rules:\n\nComplete tree (filled left to right)\n\nHeap property (max-heap = parent ≥ children)","type":"content","url":"/xsort-heapsort#what-is-a-heap-with-diagrams","position":5},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"How a max-heap is stored in an array","lvl2":"What Is a Heap? (With Diagrams)"},"type":"lvl3","url":"/xsort-heapsort#how-a-max-heap-is-stored-in-an-array","position":6},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"How a max-heap is stored in an array","lvl2":"What Is a Heap? (With Diagrams)"},"content":"If an element is at index i:\n\nLeft child: 2*i + 1\n\nRight child: 2*i + 2\n\nParent: (i-1) // 2","type":"content","url":"/xsort-heapsort#how-a-max-heap-is-stored-in-an-array","position":7},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Example Array","lvl2":"What Is a Heap? (With Diagrams)"},"type":"lvl3","url":"/xsort-heapsort#example-array","position":8},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Example Array","lvl2":"What Is a Heap? (With Diagrams)"},"content":"Index: 0  1  2  3  4\nValue: 4 10  3  5  1","type":"content","url":"/xsort-heapsort#example-array","position":9},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"As a Heap (Tree Form)","lvl2":"What Is a Heap? (With Diagrams)"},"type":"lvl3","url":"/xsort-heapsort#as-a-heap-tree-form","position":10},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"As a Heap (Tree Form)","lvl2":"What Is a Heap? (With Diagrams)"},"content":"          4 (0)\n       /        \\\n   10 (1)       3 (2)\n    /   \\\n  5(3)  1(4)\n\nRight now this is not a proper max heap.\nHeap Sort’s first job is to fix that.","type":"content","url":"/xsort-heapsort#as-a-heap-tree-form","position":11},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Phase 1: Building the Max Heap"},"type":"lvl2","url":"/xsort-heapsort#phase-1-building-the-max-heap","position":12},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Phase 1: Building the Max Heap"},"content":"We “heapify” from the bottom up.\n\nStarting at the last parent node: index (n//2 − 1)\n\nFor our array of 5 elements:\n\nLast parent = 5//2 - 1 = 1\n\nSo we heapify indices: 1, then 0","type":"content","url":"/xsort-heapsort#phase-1-building-the-max-heap","position":13},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Heapify index 1","lvl2":"Phase 1: Building the Max Heap"},"type":"lvl3","url":"/xsort-heapsort#heapify-index-1","position":14},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Heapify index 1","lvl2":"Phase 1: Building the Max Heap"},"content":"Node = 10\nChildren = 5 and 1\nAlready a valid max-heap section.          4\n       /     \\\n    10        3\n   /   \\\n  5     1\n\nNo changes.","type":"content","url":"/xsort-heapsort#heapify-index-1","position":15},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Heapify index 0","lvl2":"Phase 1: Building the Max Heap"},"type":"lvl3","url":"/xsort-heapsort#heapify-index-0","position":16},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Heapify index 0","lvl2":"Phase 1: Building the Max Heap"},"content":"Node 0 = 4\nChildren = 10 and 3\nLargest is 10, so swap 4 ↔ 10          10\n       /        \\\n     4           3\n   /   \\\n  5     1\n\nNow heapify the subtree rooted at index 1 (value 4):\n\nCompare 4 to its children (5 and 1):\n\nLargest is 5, so swap 4 ↔ 5:          10\n       /        \\\n     5           3\n   /   \\\n  4     1\n\nWe’re done—this is a proper max heap.","type":"content","url":"/xsort-heapsort#heapify-index-0","position":17},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Phase 2: Extracting the Maximum (Sorting)"},"type":"lvl2","url":"/xsort-heapsort#phase-2-extracting-the-maximum-sorting","position":18},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Phase 2: Extracting the Maximum (Sorting)"},"content":"Now we repeatedly:\n\nSwap root ↔ last element\n\nShrink heap size\n\nHeapify again\n\nEach diagram below shows the transformation.","type":"content","url":"/xsort-heapsort#phase-2-extracting-the-maximum-sorting","position":19},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Step 1: Swap Root With Last Element","lvl2":"Phase 2: Extracting the Maximum (Sorting)"},"type":"lvl3","url":"/xsort-heapsort#step-1-swap-root-with-last-element","position":20},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Step 1: Swap Root With Last Element","lvl2":"Phase 2: Extracting the Maximum (Sorting)"},"content":"Swap 10 ↔ 1Array: [1, 5, 3, 4, 10]\nHeap Size: 4\n\nTree:           1\n       /        \\\n     5           3\n   /   \n  4    \n\nNow heapify index 0.","type":"content","url":"/xsort-heapsort#step-1-swap-root-with-last-element","position":21},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Heapify →","lvl2":"Phase 2: Extracting the Maximum (Sorting)"},"type":"lvl3","url":"/xsort-heapsort#heapify","position":22},{"hierarchy":{"lvl1":"Heap Sort","lvl3":"Heapify →","lvl2":"Phase 2: Extracting the Maximum (Sorting)"},"content":"Largest child = 5 → swap 1 ↔ 5           5\n       /        \\\n     1           3\n   /\n  4\n\nHeapify index 1:\n\n1 < 4 → swap 1 ↔ 4           5\n       /        \\\n     4           3\n   /\n  1\n\nArray now:[5, 4, 3, 1, 10]","type":"content","url":"/xsort-heapsort#heapify","position":23},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Step 2: Swap Root With Element at Index 3"},"type":"lvl2","url":"/xsort-heapsort#step-2-swap-root-with-element-at-index-3","position":24},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Step 2: Swap Root With Element at Index 3"},"content":"Swap 5 ↔ 1:[1, 4, 3, 5, 10]\nHeap Size: 3\n\nTree:         1\n       /   \\\n     4       3\n\nHeapify index 0 → swap 1 ↔ 4:         4\n       /   \\\n     1       3\n\nArray becomes:[4, 1, 3, 5, 10]","type":"content","url":"/xsort-heapsort#step-2-swap-root-with-element-at-index-3","position":25},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Step 3: Swap Root With Element at Index 2"},"type":"lvl2","url":"/xsort-heapsort#step-3-swap-root-with-element-at-index-2","position":26},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Step 3: Swap Root With Element at Index 2"},"content":"Swap 4 ↔ 3:[3, 1, 4, 5, 10]\nHeap Size: 2\n\nHeapify index 0:\n\nCompare 3 and 1 → already valid.\n\nArray:[3, 1, 4, 5, 10]","type":"content","url":"/xsort-heapsort#step-3-swap-root-with-element-at-index-2","position":27},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Step 4: Swap Root With Element at Index 1"},"type":"lvl2","url":"/xsort-heapsort#step-4-swap-root-with-element-at-index-1","position":28},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Step 4: Swap Root With Element at Index 1"},"content":"Swap 3 ↔ 1:[1, 3, 4, 5, 10]\nHeap Size: 1\n\nSorting complete.","type":"content","url":"/xsort-heapsort#step-4-swap-root-with-element-at-index-1","position":29},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Final Sorted Array"},"type":"lvl2","url":"/xsort-heapsort#final-sorted-array","position":30},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Final Sorted Array"},"content":"[1, 3, 4, 5, 10]\n\nThe mountain of numbers has been carved into a perfect, ascending ridge.","type":"content","url":"/xsort-heapsort#final-sorted-array","position":31},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Complete Visual Summary"},"type":"lvl2","url":"/xsort-heapsort#complete-visual-summary","position":32},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Complete Visual Summary"},"content":"Start:          Build Max Heap:      Extract 1:         Extract 2:\n\n[4 10 3 5 1] →  [10 5 3 4 1] →       [5 4 3 1 10] →     [4 1 3 5 10]\n\nExtract 3:      Extract 4:           Sorted:\n\n[3 1 4 5 10] →  [1 3 4 5 10] →       [1 3 4 5 10]","type":"content","url":"/xsort-heapsort#complete-visual-summary","position":33},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Python Code"},"type":"lvl2","url":"/xsort-heapsort#python-code","position":34},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Python Code"},"content":"# heap_sort()\n# Performs Heap Sort on the provided array.\n# The process has two phases:\n#   1. Build a max-heap from the entire array.\n#   2. Repeatedly swap the root (largest value) with the last\n#      element in the heap and shrink the heap size.\n\ndef heap_sort(arr):\n\n    n = len(arr)    # Number of elements in the list\n\n\n    # Build the max heap (bottom-up)\n    # We start heapifying at the last parent node and move\n    # backwards toward the root. This ensures the entire array\n    # becomes a valid max-heap.\n\n    for i in range(n//2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n\n    # Extract elements from the heap one by one\n    # Each extraction moves the current maximum (index 0)\n    # to the end of the array. Then we reduce the heap size\n    # and restore the heap property.\n\n    for i in range(n-1, 0, -1):\n\n        # Move current largest value (arr[0]) to the end\n        arr[i], arr[0] = arr[0], arr[i]\n\n        # Restore heap property on the reduced heap (size i)\n        heapify(arr, i, 0)\n\n\n\n\n# heapify()\n# Ensures that the subtree rooted at index i follows the\n# max-heap property. If the parent is smaller than one of its\n# children, we swap it with the larger child and continue\n# heapifying downward.\n#\n# arr : the list we are treating as a heap\n# n   : the size of the heap section we're working with\n# i   : the index of the current parent node\n\ndef heapify(arr, n, i):\n\n    largest = i             # Assume the parent is the largest\n    left = 2*i + 1          # Index of the left child\n    right = 2*i + 2         # Index of the right child\n\n    # If the left child exists and is larger than the parent,\n    # mark it as the new largest.\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If the right child exists and is larger than the current\n    # largest value, update the largest.\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If the largest element is NOT the parent (i),\n    # swap parent with the largest child.\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n\n        # After the swap, the subtree rooted at 'largest'\n        # may now violate the heap property, so we fix it\n        # by heapifying again.\n        heapify(arr, n, largest)\n\n\n\n","type":"content","url":"/xsort-heapsort#python-code","position":35},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Java Code"},"type":"lvl2","url":"/xsort-heapsort#java-code","position":36},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Java Code"},"content":"// HeapSort class\npublic class HeapSort {\n\n\n    public void sort(int[] arr) {\n\n        int n = arr.length;   // Total number of elements\n\n\t\t/*\n\t\tBuild Heap\n        We start from the last parent node and move backward.\n        (n/2 - 1) is the index of the last non-leaf node.\n        Each heapify call ensures the subtree rooted at i\n        follows the max-heap property.\n        */\n        \n        \n        for (int i = n/2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n\n       \t/* Extract elements from heap\n        We repeatedly swap the max element (index 0)\n        with the last element in the heap.\n        After each swap, we shrink the heap size by 1\n        and restore heap order.\n        */\n        for (int i = n - 1; i >= 0; i--) {\n\n            // Move current root (largest value) to end\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n\n            // Restore heap property on the reduced heap\n            heapify(arr, i, 0);\n        }\n    }\n\n    /* Heapify\n    heapify(): Ensures the subtree rooted at index i\n    obeys the max-heap rule.\n    \n    arr   = array representing the heap\n    n     = size of the heap section we're working with\n    i     = index of the current root node\n    */\n    \n    void heapify(int[] arr, int n, int i) {\n\n        int largest = i;        // Assume the parent is the largest\n        int left = 2*i + 1;     // Index of left child\n        int right = 2*i + 2;    // Index of right child\n\n        // If the left child exists and is greater than the parent,\n        // mark it as the new largest.\n        if (left < n && arr[left] > arr[largest])\n            largest = left;\n\n        // If the right child exists and is greater than the current largest,\n        // update the largest value.\n        if (right < n && arr[right] > arr[largest])\n            largest = right;\n\n        // If the largest element is NOT the parent,\n        // swap them and continue heapifying downward.\n        if (largest != i) {\n\n            // Swap parent with the larger child\n            int swap = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = swap;\n\n            // Recursively heapify the affected subtree\n            heapify(arr, n, largest);\n        }\n    }\n}\n","type":"content","url":"/xsort-heapsort#java-code","position":37},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Best Use Cases for Heap Sort"},"type":"lvl2","url":"/xsort-heapsort#best-use-cases-for-heap-sort","position":38},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Best Use Cases for Heap Sort"},"content":"Heap Sort shines when you want predictable performance and tight memory discipline. Because it runs in a guaranteed O(n log n)—regardless of how ugly the input is—it’s a strong choice when you absolutely must avoid the worst-case meltdowns that plague something like QuickSort. It also sorts in place, which means it needs only constant extra space; this makes it ideal for memory-constrained environments such as embedded systems, older hardware, or large data sets that can’t afford the luxury of extra arrays. And since the algorithm is tightly aligned with the behavior of priority queues, it’s a natural fit whenever you are already working with heaps—like scheduling tasks, selecting the top-k elements, or managing simulations. When memory counts and guaranteed performance matters, Heap Sort is the reliable, strong-backed workhorse of the sorting world.","type":"content","url":"/xsort-heapsort#best-use-cases-for-heap-sort","position":39},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Worst Use Cases for Heap Sort"},"type":"lvl2","url":"/xsort-heapsort#worst-use-cases-for-heap-sort","position":40},{"hierarchy":{"lvl1":"Heap Sort","lvl2":"Worst Use Cases for Heap Sort"},"content":"But Heap Sort also has its rough edges. It is not stable, meaning equal elements can be reordered—a deal breaker in situations where order matters (such as sorting records by one field while preserving their sequence by another). It’s also cache-unfriendly; its constant jumping around in memory makes it slower in practice than algorithms like QuickSort or Merge Sort on modern hardware, even though they share the same theoretical time complexity. If you need blazing performance on real-world data, or if you’re sorting structures where preserving relative order matters, Heap Sort isn’t the hero—there are faster, smoother tools. And if your environment allows recursion, extra memory, or stable sorting, then Merge Sort or TimSort will leave Heap Sort sitting in the dust.","type":"content","url":"/xsort-heapsort#worst-use-cases-for-heap-sort","position":41},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers"},"type":"lvl1","url":"/xsortingvideosvisualizers","position":0},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers"},"content":"","type":"content","url":"/xsortingvideosvisualizers","position":1},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Quick Sort"},"type":"lvl2","url":"/xsortingvideosvisualizers#quick-sort","position":2},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Quick Sort"},"content":"https://​www​.youtube​.com​/watch​?v​=​Hoixgm4​-P4M\n\nhttps://​www​.youtube​.com​/watch​?v​=​PgBzjlCcFvc","type":"content","url":"/xsortingvideosvisualizers#quick-sort","position":3},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Merge Sort"},"type":"lvl2","url":"/xsortingvideosvisualizers#merge-sort","position":4},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Merge Sort"},"content":"https://​www​.youtube​.com​/watch​?v​=​4VqmGXwpLqc\n\nhttps://​www​.youtube​.com​/watch​?v​=​JSceec​-wEyw","type":"content","url":"/xsortingvideosvisualizers#merge-sort","position":5},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Insert Sort"},"type":"lvl2","url":"/xsortingvideosvisualizers#insert-sort","position":6},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Insert Sort"},"content":"https://​www​.youtube​.com​/watch​?v​=​JU767SDMDvA\n\nhttps://​www​.youtube​.com​/watch​?v​=​OGzPmgsI​-pQ","type":"content","url":"/xsortingvideosvisualizers#insert-sort","position":7},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Bucket Sort"},"type":"lvl2","url":"/xsortingvideosvisualizers#bucket-sort","position":8},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Bucket Sort"},"content":"https://​www​.youtube​.com​/watch​?v​=​VuXbEb5ywrU","type":"content","url":"/xsortingvideosvisualizers#bucket-sort","position":9},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Sorting Visualizers"},"type":"lvl2","url":"/xsortingvideosvisualizers#sorting-visualizers","position":10},{"hierarchy":{"lvl1":"Sorting Videos and Visualizers","lvl2":"Sorting Visualizers"},"content":"https://​sortvisualizer​.com/\n\nhttps://​www​.cs​.usfca​.edu​/​~galles​/visualization​/ComparisonSort​.html\n\nhttps://​www​.toptal​.com​/developers​/sorting​-algorithms","type":"content","url":"/xsortingvideosvisualizers#sorting-visualizers","position":11},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects"},"type":"lvl1","url":"/xstackusingarrayofobjects","position":0},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects"},"content":"","type":"content","url":"/xstackusingarrayofobjects","position":1},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Stack Methods"},"type":"lvl2","url":"/xstackusingarrayofobjects#stack-methods","position":2},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Stack Methods"},"content":"Methods usually associated with a stack are as follows:\n\nPush - adds data to the stack\n\nPop - removes data from the stack\n\nPeek - retrieves the next piece/top data from the stack, but does not remove it.\n\nisFull - this is used when making a stack with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the stack is empty.\n\nTip\n\nisFull is not needed if a Stack is created using a Linked List\n\nDetails discussed \n\nhere","type":"content","url":"/xstackusingarrayofobjects#stack-methods","position":3},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Lecture Code"},"type":"lvl2","url":"/xstackusingarrayofobjects#lecture-code","position":4},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Lecture Code"},"content":"/*\n * Project: Stack Using Array of Objects\n * Programmer: James Goudy\n * DS132SU_StackArray\n *\n *\n * Stack\n * push\n * pop\n * peek\n * isEmpty\n * isFull\n *\n *\n */\n\nclass Town {\n\n    public String city;\n    public int population;\n\n    // constructor\n    public Town(String city, int population) {\n        this.city = city;\n        this.population = population;\n    }\n\n    public void displayCity() {\n        System.out.print(\"{\" + city + \", \" + population + \"} \");\n    }\n\n}\n\nclass Stack {\n\n    private int maxSize;\n    private Town[] stackArray;\n    private int top = -1;\n\n    //constructor\n    public Stack(int maxSize) {\n        this.maxSize = maxSize;\n        stackArray = new Town[maxSize];\n        top = -1;\n    }\n\n    public boolean push(String city, int population) {\n        \n        // add data to the stack\n        if (isFull()) {\n            return false;\n        } else {\n            Town theTown = new Town(city, population);\n            stackArray[++top] = theTown;\n            return true;\n        }\n\n    }\n\n    public Town pop() {\n        // remove data from the stack\n        return stackArray[top--];\n    }\n\n    public Town peek() {\n        // look/peek at the top of the stack\n        return stackArray[top];\n    }\n\n    public boolean isEmpty() {\n        //check if the array is empty\n        return (top == -1);\n    }\n\n    public boolean isFull() {\n        // check if the array is full\n        return (top == maxSize - 1);\n    }\n\n}\n\npublic class DS132SU_StackArray {\n\n    public static void main(String[] args) {\n\n        // create a stack\n        Stack myStack = new Stack(10);\n        Town tempTown = null;\n        \n        // add data to the stack\n        myStack.push(\"Kali\", 300000);\n        myStack.push(\"Bozeman\", 100000);\n        myStack.push(\"Whitefish\", 40000);\n        myStack.push(\"Columbia Falls\", 30000);\n\n        // peek at the top data\n        System.out.print(\"Peek - \");\n        myStack.peek().displayCity();\n        System.out.println(\"\");\n\n        // pop one data object from the stack and store it in an object\n        tempTown = myStack.pop();\n        tempTown.displayCity();\n        \n        // empty the list\n        while (!myStack.isEmpty()) {\n            myStack.pop().displayCity();\n        }\n\n        System.out.println(\"\");\n\n        //ternary operator\n        boolean flag;\n        flag = myStack.push(\"Plains\", 15000) ? true : false;\n\n        if (flag) {\n            System.out.println(\"Item added\");\n        } else {\n            System.out.println(\"Item NOT added\");\n        }\n\n        System.out.print(\"\\nbye\");\n    }\n}\n\n\nEnd of Topic","type":"content","url":"/xstackusingarrayofobjects#lecture-code","position":5},{"hierarchy":{"lvl1":"Stacks and Queues"},"type":"lvl1","url":"/xstacksandqueues","position":0},{"hierarchy":{"lvl1":"Stacks and Queues"},"content":"","type":"content","url":"/xstacksandqueues","position":1},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Key Ideas"},"type":"lvl2","url":"/xstacksandqueues#key-ideas","position":2},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Key Ideas"},"content":"Stacks\n\nQueues","type":"content","url":"/xstacksandqueues#key-ideas","position":3},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Discussion"},"type":"lvl2","url":"/xstacksandqueues#discussion","position":4},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Discussion"},"content":"Stacks and queues are a way of organizing data and consuming data. The data can be stored in an array or linked list.","type":"content","url":"/xstacksandqueues#discussion","position":5},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Stack","lvl2":"Discussion"},"type":"lvl3","url":"/xstacksandqueues#stack","position":6},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Stack","lvl2":"Discussion"},"content":"Note\n\n\n\nA Stack is a way of organizing and consuming data where the Last In is the First Out (LIFO). Or it can be thought of as First In is the Last Out (FILO).\n\nMost people think of a stack as a stack of plates, where each plate represents data. Data is pushed onto the stack. Meaning. it is added to the array or linked list. Data is consumed by popping it off of the stack. Meaning, that the last piece of data added to the stack is removed from the array or linked list. This data is usually used by the part of the program that is popping/removing it from the stack.  Peeking is looking at the last/next piece of data, but not removing it from the stack. An example is \n\nStack Array\n\nMethods usually associated with a stack are as follows:\n\nPush - adds data to the stack\n\nPop - removes data from the stack\n\nPeek - retrieves the next piece/top data from the stack, but does not remove it.\n\nisFull - this is used when making a stack with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the stack is empty.\n\nIn computer science, a stack is a LIFO (Last In, First Out) data structure that stores elements in a linear order. This means that the last element added to the stack is the first one to be removed. Stacks are often used to manage a sequence of operations, such as function calls or undo/redo functionality.\n\nHere are some of the key properties of stacks:\n\nLIFO order: Elements are removed in the reverse order they were added.\n\nBounded capacity: Stacks have a limited size, and adding more elements than the stack can hold will result in an error.\n\nEfficient access: Pushing and popping elements from the top of the stack is a very efficient operation, typically taking constant time.\n\nStacks are used in a variety of applications in computer science, including:\n\nFunction calls: When a function is called, its arguments and local variables are pushed onto a stack. When the function returns, its stack frame is popped off the stack.\n\nExpression evaluation: Stacks are used to evaluate expressions in many programming languages. For example, when evaluating arithmetic expressions, operands are pushed onto the stack, and then operators are popped off the stack and applied to the operands.\n\nBacktracking algorithms: Stacks are used to store the history of decisions made in backtracking algorithms, such as depth-first search. This allows the algorithm to backtrack to previous states if it reaches a dead end.\n\nUndo/redo functionality: Stacks are used to implement undo/redo functionality in many applications. When an action is performed, the state of the application is pushed onto the undo stack. To undo the action, the state is popped off the undo stack and restored.\n\nHere are some examples of how stacks are used in real-world applications:\n\nCompilers: Compilers use stacks to keep track of the current state of the program being compiled.\n\nInterpreters: Interpreters use stacks to evaluate expressions and statements in the program being interpreted.\n\nWeb browsers: Web browsers use stacks to keep track of the history of visited web pages.\n\nOperating systems: Operating systems use stacks to manage memory allocation and process scheduling.\n\nStacks are a versatile and powerful data structure that is used in a wide variety of applications in computer science. Their LIFO order and efficient access make them well-suited for managing sequences of operations and storing the history of decisions made in algorithms.","type":"content","url":"/xstacksandqueues#stack","position":7},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Queue","lvl2":"Discussion"},"type":"lvl3","url":"/xstacksandqueues#queue","position":8},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Queue","lvl2":"Discussion"},"content":"Note\n\n\n\nA Queue is a way of organizing and consuming data where the First In is the First Out (FIFO).\n\nMost people think of a queue as people standing in a line, where people represent data.  Data is consumed in the order in which it was added.\n\nMethods usually associated with a queue are as follows:\n\nEnqueue - add data to the queue.\n\nDequeue - remove data from the queue\n\nPeek - retrieves the next piece/“head” data from the queue, but does not remove it.\n\nisFull - this is used when making a queue with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the queue is empty.\n\nIn computer science, a queue is a LIFO (First In, First Out) data structure that stores elements in a linear order. This means that the first element added to the queue is the first one to be removed. Queues are often used to manage a sequence of tasks or events, such as printing jobs or network traffic.\n\nHere are some of the key properties of queues:\n\nFIFO order: Elements are removed in the order they were added.\n\nBounded capacity: Queues have a limited size, and adding more elements than the queue can hold will result in an error.\n\nEfficient access: Adding and removing elements from the front and back of the queue are efficient operations, typically taking constant time.\n\nQueues are used in a variety of applications in computer science, including:\n\nTask scheduling: Queues are used to schedule tasks in operating systems and other systems. For example, a print queue is used to manage the order in which print jobs are processed.\n\nNetwork traffic: Queues are used to manage the flow of data in networks. For example, a network buffer is used to store data packets that are waiting to be sent over a network.\n\nBuffering: Queues are used to buffer data between different components of a system. For example, a keyboard buffer is used to store characters typed on a keyboard until they can be processed by the operating system.\n\nMessage passing: Queues are used to pass messages between different processes or threads. For example, a message queue is used to store messages that are waiting to be processed by a consumer process.\n\nHere are some examples of how queues are used in real-world applications:\n\nOperating systems: Operating systems use queues to manage task scheduling, memory allocation, and device drivers.\n\nNetworking: Networking protocols use queues to manage the flow of data packets.\n\nMultimedia applications: Multimedia applications use queues to buffer audio and video data.\n\nMessaging applications: Messaging applications use queues to store messages that are waiting to be delivered to recipients.\n\nQueues are a versatile and powerful data structure that is used in a wide variety of applications in computer science. Their FIFO order and efficient access make them well-suited for managing sequences of tasks or events.","type":"content","url":"/xstacksandqueues#queue","position":9},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Priority Queue","lvl2":"Discussion"},"type":"lvl3","url":"/xstacksandqueues#priority-queue","position":10},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Priority Queue","lvl2":"Discussion"},"content":"Definition\n\nA Priority Queue is a queue where there is a mechanism to place data at the start or infront of other data.\n\nIn computer science, a priority queue is a specialized type of queue where elements are prioritized based on their associated priority values. Elements with higher priority values are served before elements with lower priority values. Priority queues are often implemented using heap data structures, which allow for efficient insertion and extraction operations.\n\nHere are some of the key properties of priority queues:\n\nPriority-based ordering: Elements are served based on their priority values, with higher priority elements being served first.\n\nEfficient insertion and extraction: Priority queues can efficiently insert and extract elements, typically taking logarithmic time.\n\nDynamic priority updates: Priority values can be updated dynamically, allowing for reprioritization of elements within the queue.\n\nPriority queues are used in a variety of applications where prioritization is important, including:\n\nTask scheduling: Priority queues are used to schedule tasks based on their urgency or importance. For example, a critical job processing system might use a priority queue to prioritize high-priority tasks over less urgent ones.\n\nNetwork traffic management: Priority queues can be used to prioritize network traffic based on its importance or quality of service requirements. For instance, real-time voice or video traffic might be prioritized over non-real-time data transfers.\n\nEvent handling: Priority queues can be used to manage a sequence of events, ensuring that high-priority events are handled first. For example, an event-driven system might use a priority queue to prioritize system alerts or critical user interactions.\n\nAlgorithm optimization: Priority queues are used in various algorithms, such as Dijkstra’s algorithm for shortest path finding and A* search for pathfinding in graph-based problems.\n\nHere are some real-world examples of how priority queues are used:\n\nOperating systems: Operating systems use priority queues to manage task scheduling, ensuring that high-priority tasks, such as system processes, are executed before less urgent user tasks.\n\nNetwork routers: Network routers use priority queues to manage network traffic, prioritizing real-time audio or video traffic over non-real-time data transfers.\n\nEmergency response systems: Emergency response systems might use priority queues to prioritize dispatching emergency responders based on the severity of incidents.\n\nHospital patient care: Critical care units in hospitals might use priority queues to manage patient care, ensuring that patients with the most urgent medical needs are seen first.\n\nPriority queues are a valuable data structure that plays a crucial role in various applications that require efficient prioritization and management of tasks, events, or data. Their ability to handle dynamic priority updates and their efficient insertion and extraction operations make them a well-suited choice for prioritizing elements in a variety of contexts.\n\nEnd Of Topic","type":"content","url":"/xstacksandqueues#priority-queue","position":11},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms"},"type":"lvl1","url":"/xunderstandingquickmergeheap","position":0},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms"},"content":"Quick Sort, Merge Sort, and Heap Sort\n\nSorting is the backbone of efficient computing—an invisible but essential operation used in databases, search engines, scheduling systems, and nearly every data-driven application. Although many sorting algorithms exist, three have become foundational: Quick Sort, Merge Sort, and Heap Sort. Each brings its own strategy, strengths, limitations, and real-world applications.\n\nBefore exploring them individually, we must introduce a crucial concept in sorting theory: stability.","type":"content","url":"/xunderstandingquickmergeheap","position":1},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Stable vs. Unstable Sorting"},"type":"lvl2","url":"/xunderstandingquickmergeheap#stable-vs-unstable-sorting","position":2},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Stable vs. Unstable Sorting"},"content":"A stable sort preserves the relative order of equal elements.\nIf two items compare as “equal,” a stable algorithm ensures they remain in the same order they appeared in originally.\n\nThis matters in many real-life situations, for example:\n\nSorting payroll records by last name while relying on the original hire-date order to break ties.\n\nSorting a list of students by grade, while preserving alphabetical order among students with the same score.\n\nPerforming multi-step sorting on a dataset—first by department, then by job title, then by name. Stable sorts ensure earlier sort keys remain meaningful.\n\nStable sorts allow you to build these layered sorts one pass at a time—without losing the structure established by earlier steps.\n\nMerge Sort is stable (in its standard implementation).\n\nQuick Sort and Heap Sort are typically not stable in their common forms.\n\nWith that in hand, we can now examine each sorting approach in detail.","type":"content","url":"/xunderstandingquickmergeheap#stable-vs-unstable-sorting","position":3},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"type":"lvl2","url":"/xunderstandingquickmergeheap#quick-sort-divide-conquer-and-hope-your-pivot-behaves","position":4},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"content":"Quick Sort works by selecting a pivot, partitioning the data around it, and recursively sorting the resulting sublists. When those partitions divide the array evenly, the algorithm runs with remarkable speed. When they don’t, it slows dramatically.","type":"content","url":"/xunderstandingquickmergeheap#quick-sort-divide-conquer-and-hope-your-pivot-behaves","position":5},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"How Quick Sort Works","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"type":"lvl3","url":"/xunderstandingquickmergeheap#how-quick-sort-works","position":6},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"How Quick Sort Works","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"content":"Choose a pivot element.\n\nPartition elements into those less than the pivot and those greater than or equal to the pivot.\n\nRecursively sort the left and right partitions.\n\nThis in-place partitioning is what makes Quick Sort a favorite in systems where memory is precious.","type":"content","url":"/xunderstandingquickmergeheap#how-quick-sort-works","position":7},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Quick Sort Pseudocode","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"type":"lvl3","url":"/xunderstandingquickmergeheap#quick-sort-pseudocode","position":8},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Quick Sort Pseudocode","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"content":"Below is simple array-based pseudocode using indices low and high:QUICK_SORT(A, low, high):\n    if low < high:\n        p = PARTITION(A, low, high)\n        QUICK_SORT(A, low, p - 1)\n        QUICK_SORT(A, p + 1, high)\n\n\nPARTITION(A, low, high):\n    pivot = A[high]                // choose last element as pivot\n    i = low - 1                    // i marks the end of \"less than pivot\" region\n\n    for j from low to high - 1:\n        if A[j] < pivot:\n            i = i + 1\n            swap A[i] and A[j]\n\n    swap A[i + 1] and A[high]      // place pivot in correct position\n    return i + 1                   // new pivot index\n\nKey points for students:\n\nPartitioning is in-place; no extra arrays are created.\n\nPivot choice affects performance: random or median-of-three pivots usually perform better than “always first” or “always last”.","type":"content","url":"/xunderstandingquickmergeheap#quick-sort-pseudocode","position":9},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Performance","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"type":"lvl3","url":"/xunderstandingquickmergeheap#performance","position":10},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Performance","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"content":"Best Case: O(n log n) when partitions are reasonably balanced.\n\nWorst Case: O(n²) when partitions are extremely unbalanced (e.g., already sorted data with a bad pivot strategy).","type":"content","url":"/xunderstandingquickmergeheap#performance","position":11},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Stability","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"type":"lvl3","url":"/xunderstandingquickmergeheap#stability","position":12},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Stability","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"content":"Quick Sort is not stable in its basic form: equal elements can be reordered during partitioning.","type":"content","url":"/xunderstandingquickmergeheap#stability","position":13},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Real-Life Uses","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"type":"lvl3","url":"/xunderstandingquickmergeheap#real-life-uses","position":14},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Real-Life Uses","lvl2":"Quick Sort: Divide, Conquer, and Hope Your Pivot Behaves"},"content":"Quick Sort is widely used for:\n\nFast, in-memory array sorting.\n\nSystems where average-case performance matters more than worst-case guarantees.\n\nSituations where low memory overhead is important (e.g., some embedded systems, game engines).","type":"content","url":"/xunderstandingquickmergeheap#real-life-uses","position":15},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl2","url":"/xunderstandingquickmergeheap#merge-sort-the-reliable-architect-of-order","position":16},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"Merge Sort divides a list into halves, sorts each half, and then merges them back together. Its consistency and predictability make it a favorite in professional systems, especially where stability matters.","type":"content","url":"/xunderstandingquickmergeheap#merge-sort-the-reliable-architect-of-order","position":17},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"How Merge Sort Works","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl3","url":"/xunderstandingquickmergeheap#how-merge-sort-works","position":18},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"How Merge Sort Works","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"Split the data into two roughly equal halves.\n\nRecursively sort each half.\n\nMerge the two sorted halves into a single sorted list.\n\nThe merge step is the core of the algorithm: two sorted subarrays (or sublists) are combined into one sorted structure in linear time.","type":"content","url":"/xunderstandingquickmergeheap#how-merge-sort-works","position":19},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Merge Sort Pseudocode (Array Version)","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl3","url":"/xunderstandingquickmergeheap#merge-sort-pseudocode-array-version","position":20},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Merge Sort Pseudocode (Array Version)","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"MERGE_SORT(A, left, right):\n    if left >= right:\n        return\n\n    mid = floor((left + right) / 2)\n\n    MERGE_SORT(A, left, mid)\n    MERGE_SORT(A, mid + 1, right)\n\n    MERGE(A, left, mid, right)\n\n\nMERGE(A, left, mid, right):\n    // create temporary arrays\n    n1 = mid - left + 1\n    n2 = right - mid\n\n    create array L[0..n1 - 1]\n    create array R[0..n2 - 1]\n\n    for i from 0 to n1 - 1:\n        L[i] = A[left + i]\n\n    for j from 0 to n2 - 1:\n        R[j] = A[mid + 1 + j]\n\n    i = 0\n    j = 0\n    k = left\n\n    // merge L and R back into A\n    while i < n1 and j < n2:\n        if L[i] <= R[j]:           // <= makes this implementation stable\n            A[k] = L[i]\n            i = i + 1\n        else:\n            A[k] = R[j]\n            j = j + 1\n        k = k + 1\n\n    // copy any remaining elements\n    while i < n1:\n        A[k] = L[i]\n        i = i + 1\n        k = k + 1\n\n    while j < n2:\n        A[k] = R[j]\n        j = j + 1\n        k = k + 1","type":"content","url":"/xunderstandingquickmergeheap#merge-sort-pseudocode-array-version","position":21},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Merge Sort on Linked Lists (High-Level Idea)","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl3","url":"/xunderstandingquickmergeheap#merge-sort-on-linked-lists-high-level-idea","position":22},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Merge Sort on Linked Lists (High-Level Idea)","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"For a linked list, the overall idea is similar:\n\nUse a slow and fast pointer to find the middle node and split the list in two.\n\nRecursively sort the left and right halves.\n\nMerge the two sorted lists by relinking nodes.\n\nStudents don’t need every pointer detail at first; the important concept is that splitting and merging work via pointer manipulation rather than array indices, which is very efficient.","type":"content","url":"/xunderstandingquickmergeheap#merge-sort-on-linked-lists-high-level-idea","position":23},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Performance","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl3","url":"/xunderstandingquickmergeheap#performance-1","position":24},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Performance","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"Best Case: O(n log n)\n\nWorst Case: O(n log n)\n\nMerge Sort is steady and predictable—no bad pivot days.","type":"content","url":"/xunderstandingquickmergeheap#performance-1","position":25},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Stability","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl3","url":"/xunderstandingquickmergeheap#stability-1","position":26},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Stability","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"Merge Sort is stable (when implemented as above using <= when comparing).","type":"content","url":"/xunderstandingquickmergeheap#stability-1","position":27},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Real-Life Uses","lvl2":"Merge Sort: The Reliable Architect of Order"},"type":"lvl3","url":"/xunderstandingquickmergeheap#real-life-uses-1","position":28},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Real-Life Uses","lvl2":"Merge Sort: The Reliable Architect of Order"},"content":"Merge Sort is ideal when:\n\nSorting very large datasets (e.g., external sorting on disk).\n\nStability is required (e.g., multi-key sorting in databases).\n\nWorking with linked lists, where merge operations are especially cheap.\n\nRunning on parallel or distributed systems, since splitting and merging map well to multiple processors.","type":"content","url":"/xunderstandingquickmergeheap#real-life-uses-1","position":29},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Heap Sort: Order Through Structure"},"type":"lvl2","url":"/xunderstandingquickmergeheap#heap-sort-order-through-structure","position":30},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Heap Sort: Order Through Structure"},"content":"Heap Sort builds a max heap, then repeatedly extracts the largest element and restores the heap property. It trades some constant-factor speed for predictable performance and very low extra memory usage.","type":"content","url":"/xunderstandingquickmergeheap#heap-sort-order-through-structure","position":31},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"How Heap Sort Works","lvl2":"Heap Sort: Order Through Structure"},"type":"lvl3","url":"/xunderstandingquickmergeheap#how-heap-sort-works","position":32},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"How Heap Sort Works","lvl2":"Heap Sort: Order Through Structure"},"content":"Build a max heap from the input array.\n\nSwap the element at the root (largest) with the last element in the heap.\n\nDecrease the heap size by one.\n\n“Heapify” the root to restore max-heap order.\n\nRepeat until the heap size is 1.","type":"content","url":"/xunderstandingquickmergeheap#how-heap-sort-works","position":33},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Heap Sort Pseudocode","lvl2":"Heap Sort: Order Through Structure"},"type":"lvl3","url":"/xunderstandingquickmergeheap#heap-sort-pseudocode","position":34},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Heap Sort Pseudocode","lvl2":"Heap Sort: Order Through Structure"},"content":"HEAP_SORT(A, n):\n    BUILD_MAX_HEAP(A, n)\n\n    for i from n - 1 down to 1:\n        swap A[0] and A[i]          // move current max to end\n        MAX_HEAPIFY(A, 0, i)        // heap size is now i\n\n\nBUILD_MAX_HEAP(A, n):\n    // start from last non-leaf node and heapify downward\n    for i from floor(n/2) - 1 down to 0:\n        MAX_HEAPIFY(A, i, n)\n\n\nMAX_HEAPIFY(A, i, heap_size):\n    left  = 2 * i + 1\n    right = 2 * i + 2\n    largest = i\n\n    if left < heap_size and A[left] > A[largest]:\n        largest = left\n\n    if right < heap_size and A[right] > A[largest]:\n        largest = right\n\n    if largest != i:\n        swap A[i] and A[largest]\n        MAX_HEAPIFY(A, largest, heap_size)\n\nKey teaching notes:\n\nThe heap is stored in an array, not a separate tree structure.\n\nParent/child indices come from simple formulas:\n\nparent(i) = floor((i - 1) / 2)\n\nleft(i) = 2 * i + 1\n\nright(i) = 2 * i + 2","type":"content","url":"/xunderstandingquickmergeheap#heap-sort-pseudocode","position":35},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Performance","lvl2":"Heap Sort: Order Through Structure"},"type":"lvl3","url":"/xunderstandingquickmergeheap#performance-2","position":36},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Performance","lvl2":"Heap Sort: Order Through Structure"},"content":"Best Case: O(n log n)\n\nWorst Case: O(n log n)**\n\nHeap Sort’s runtime is deterministic and does not depend on the original order of the data.","type":"content","url":"/xunderstandingquickmergeheap#performance-2","position":37},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Stability","lvl2":"Heap Sort: Order Through Structure"},"type":"lvl3","url":"/xunderstandingquickmergeheap#stability-2","position":38},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Stability","lvl2":"Heap Sort: Order Through Structure"},"content":"Heap Sort is not stable in its basic array form. Swapping elements to maintain heap order may reorder equal values.","type":"content","url":"/xunderstandingquickmergeheap#stability-2","position":39},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Real-Life Uses","lvl2":"Heap Sort: Order Through Structure"},"type":"lvl3","url":"/xunderstandingquickmergeheap#real-life-uses-2","position":40},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl3":"Real-Life Uses","lvl2":"Heap Sort: Order Through Structure"},"content":"Heap Sort is useful when:\n\nExtra memory must be kept minimal (only O(1) extra space).\n\nPredictable worst-case performance is important.\n\nThe algorithm is closely related to existing priority queue or heap-based logic.","type":"content","url":"/xunderstandingquickmergeheap#real-life-uses-2","position":41},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Choosing the Right Tool: Sorting Linked Lists"},"type":"lvl2","url":"/xunderstandingquickmergeheap#choosing-the-right-tool-sorting-linked-lists","position":42},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Choosing the Right Tool: Sorting Linked Lists"},"content":"For linked lists, one algorithm is clearly superior:\n\nMerge Sort — Excellent\n\nPointer-based splitting and merging are natural and efficient.\n\nQuick Sort — Possible but awkward\n\nPartitioning over pointers is less efficient than merging.\n\nHeap Sort — Poor fit\n\nHeaps assume fast random access, which linked lists cannot provide.\n\nIn practice, when you hear “sort this linked list,” the correct reflex is “use Merge Sort.”","type":"content","url":"/xunderstandingquickmergeheap#choosing-the-right-tool-sorting-linked-lists","position":43},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Summary Comparison"},"type":"lvl2","url":"/xunderstandingquickmergeheap#summary-comparison","position":44},{"hierarchy":{"lvl1":"Understanding Three Quick, Merge, and Heap Sort Algorithms","lvl2":"Summary Comparison"},"content":"Algorithm\n\nBest Case\n\nWorst Case\n\nStable?\n\nLinked List Performance\n\nReal-Life Fit\n\nQuick Sort\n\nO(n log n)\n\nO(n²)\n\nNo\n\nPoor\n\nFast in-memory array sorting; low-overhead systems; general-purpose use.\n\nMerge Sort\n\nO(n log n)\n\nO(n log n)\n\nYes\n\nExcellent\n\nDatabases, large/external datasets, multi-key sorting, linked lists.\n\nHeap Sort\n\nO(n log n)\n\nO(n log n)\n\nNo\n\nPoor\n\nDeterministic runtimes; memory-tight systems; heap/priority-queue contexts.","type":"content","url":"/xunderstandingquickmergeheap#summary-comparison","position":45},{"hierarchy":{"lvl1":"Bucket Sort"},"type":"lvl1","url":"/xbucketsort","position":0},{"hierarchy":{"lvl1":"Bucket Sort"},"content":"","type":"content","url":"/xbucketsort","position":1},{"hierarchy":{"lvl1":"Bucket Sort"},"type":"lvl1","url":"/xbucketsort#bucket-sort","position":2},{"hierarchy":{"lvl1":"Bucket Sort"},"content":"BucketSort Method: This method performs the bucket sort algorithm.\n\nFirst, it finds the maximum value in the input array to determine how many buckets are needed.\n\nIt then creates an array of buckets (a frequency count array) to track how many times each integer appears in the input.\n\nAfter filling the buckets, it reconstructs the sorted array by placing each element in the correct order.\n\nprintArray Method: A helper function to print the array in a formatted way. This is useful for displaying the array both before and after sorting.\n\nMain Method:\n\nIt initializes an array of a given size (arrSize), then populates it with random numbers. The size of the array and the number of elements to sort (nelems) are specified.\n\nIt prints the array before and after sorting using the BucketSort method and then ends the program with a “Bye” message.","type":"content","url":"/xbucketsort#bucket-sort","position":3},{"hierarchy":{"lvl1":"Key Concepts:"},"type":"lvl1","url":"/xbucketsort#key-concepts","position":4},{"hierarchy":{"lvl1":"Key Concepts:"},"content":"Bucket Sort: It is an efficient sorting algorithm used for uniformly distributed data. The array elements are distributed into several “buckets” (frequency array in this case), sorted within those buckets (implicitly through frequency counts), and then combined back into a sorted array.\n\nRandom Number Generation: The random number generator (RNG.nextInt(maxInt)) is used to fill the array with random integers between 0 and maxInt./*\nBucket Sort Algorithm\n*/\npackage fa25_bucket;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\n/**\n * Author: jgoudy\n */\npublic class Fa25_bucket {\n\n    // Bucket Sort function\n    public static void BucketSort(int[] array, int nelems){\n        \n        // Step 1: Find the maximum value in the array to determine the range of buckets\n        int max = Arrays.stream(array).max().getAsInt();\n        \n        // Step 2: Create an array of buckets to \n        // store frequency counts (size max+1 to accommodate the largest element)\n        int[] bucket = new int[max + 1];\n        \n        // Step 3: Initialize all bucket values to 0 (since we're counting frequencies)\n        for (int i = 0; i <= max; i++) {\n            bucket[i] = 0;            \n        }\n        \n        // Step 4: Populate the buckets with the frequencies \n        // of elements in the input array\n        // For each element in the array, increment the count \n        // at the corresponding bucket index\n        for (int i = 0; i < nelems; i++) {\n            bucket[array[i]]++;  // Increase frequency for each element\n        }\n        \n        // Step 5: Reconstruct the sorted array from the bucket counts\n        // Iterate through the buckets, placing each element back into the array\n        // based on its frequency in the bucket array\n        for(int i = 0, j=0; i <= max; i++){\n            // While the current bucket contains elements (frequency > 0)\n            while(bucket[i] > 0) {\n                // Place the element in the array at the current position\n                array[j++] = i;\n                // Decrease the bucket's count (one element placed)\n                bucket[i]--;\n            }\n        }\n    } // End of BucketSort function\n    \n    // Utility function to print the array\n    static void printArray(int[] arr, int nelemns){\n        for (int i = 0; i < nelemns; i++) {\n            // Print each element with spacing for neatness\n            System.out.printf(String.format(\"%4s\", arr[i]));\n        }\n    }\n    \n    /**\n     * Main method for running the program\n     */\n    public static void main(String[] args)\n    {\n        // Define size of the array, maximum random integer, \n        // and number of elements to sort\n        int arrSize = 25;\n        int maxInt = arrSize - 5;   // Maximum value for random number generation\n        int nelems = arrSize - 10;  // Number of elements to actually sort\n        \n        // Create an array with a specified size\n        int[] arr = new int[arrSize];\n        \n        // Initialize random number generator (RNG)\n        Random RNG = new Random();\n        \n        // Step 1: Populate the array with random values between 0 and maxInt\n        for(int c = 0; c < nelems; c++) {\n            arr[c] = RNG.nextInt(maxInt);\n        }\n        \n        // Print the array before sorting\n        System.out.print(\"Before \");\n        printArray(arr, nelems);\n        System.out.println(\"\");\n        \n        // Step 2: Sort the array using BucketSort\n        BucketSort(arr, nelems);\n        \n        // Print the array after sorting\n        System.out.print(\"After  \");\n        printArray(arr, nelems);\n        System.out.println(\"\");\n        \n        // Print a message indicating the end of the program\n        System.out.println(\"Bye\");\n    }\n}\n","type":"content","url":"/xbucketsort#key-concepts","position":5},{"hierarchy":{"lvl1":"End Of Section"},"type":"lvl1","url":"/xend","position":0},{"hierarchy":{"lvl1":"End Of Section"},"content":"Algorithms and Data Structures\n\nEnd Of Section","type":"content","url":"/xend","position":1}]}