{"version":"1","records":[{"hierarchy":{"lvl1":"Array Add and Delete Data"},"type":"lvl1","url":"/arrayadddeletedata","position":0},{"hierarchy":{"lvl1":"Array Add and Delete Data"},"content":"","type":"content","url":"/arrayadddeletedata","position":1},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Key Ideas"},"type":"lvl2","url":"/arrayadddeletedata#key-ideas","position":2},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Key Ideas"},"content":"In working with arrays, keeping data continuous is a good practice the majority of the time.  If data in an element is deleted, the data in the elements to the right should be shifted left to remove the empty space.\n\nAlso, there may be times when data has to be inserted into an array that has continuous data elements.  In this case, data is shifted to the right to create a space where the new data can be inserted.\n\nTip\n\nIn many cases, arrays are usually set to have more elements than is needed. Therefore, it is important to create a variable that will alway track the number of items in the array.","type":"content","url":"/arrayadddeletedata#key-ideas","position":3},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Lecture Code"},"type":"lvl2","url":"/arrayadddeletedata#lecture-code","position":4},{"hierarchy":{"lvl1":"Array Add and Delete Data","lvl2":"Lecture Code"},"content":"/*\n *\n * Project: Add Delete In an Array\n * Programmer: J Goudy\n \n */\n\n\npublic class DS_ArraysAddDelete {\n\n    static String[] arrString;\n    static int arrStrDataCount = 0;\n\n    static void loadStringArray() {\n    // this is a helper function to setup our example array\n        \n        String[] names = {\"Adam\", \"Bobby\", \"Howard\", \"Mary\", \"Zuzu\"};\n\n        //load names\n        for (int c = 0; c < names.length; c++) {\n            arrString[c] = names[c];\n        }\n\n\t\t//set our number of data items\n        arrStrDataCount = names.length;\n\n        // print number of items\n        System.out.println(\"DataCount = \" + arrStrDataCount);\n\n        printArray(arrString, arrStrDataCount);\n\n    }\n\n    static void printArray(String[] theArray, int dataCount) {\n    // This function prints the array. \n    // Note that an array is being passed to it.\n        \n        // for spacing\n        System.out.println();\n        \n        // iterate through the array and print the data\n        for (int i = 0; i < dataCount; i++) {\n            System.out.print(theArray[i] + \" \");\n        }\n\n        System.out.println(\"\\n------------\\n\");\n\n    }\n\n    static void insertStringByPos(int pos, String aName) {\n        // ---------- Do some checks ---------------------\n\n        // check if position is withing array bounds\n        if (pos > arrStrDataCount) {\n            System.out.println(\"Error out array bounds\");\n\n            // exit the function\n            return;\n        }\n\n        // check if the array is full\n        if (arrStrDataCount >= arrString.length) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n\n        // -------------- Insert Code --------------------------\n        // shift to right\n        // note that the loop is starting at the end and \n        // working backwards to the insert spot (pos)\n        for (int i = arrStrDataCount; i > pos; i--) {\n\n            arrString[i] = arrString[i - 1];\n        }\n\n        // insert the new name\n        arrString[pos] = aName;\n\n        // increment our data Count\n        arrStrDataCount++;\n\n        // print the array to show data was inserted\n        printArray(arrString, arrStrDataCount);\n\n    }\n\n    static void deleteByPos(int pos) {\n        // check if there is contents\n        if (arrStrDataCount <= 0) {\n            System.out.println(\"Array is empty\\n\");\n            return;\n        }\n\n        // check if the position to delete is out of bounds\n        if (pos >= arrStrDataCount) {\n            System.out.println(\"Pos is out of bounds\\n\");\n            return;\n        }\n\n        // -----------  Delete Code ---------------------\n        // shift loop\n        // note that the loop starts at the element location \n        // that is being deleted\n        for (int i = pos; i < arrStrDataCount; i++) {\n            arrString[i] = arrString[i + 1];\n        }\n\n        // decrease the item count by 1\n        arrStrDataCount--;\n\n        printArray(arrString, arrStrDataCount);\n\n    }\n\n    public static void main(String[] args) {\n\n        // instantiate the data array\n        arrString = new String[8];\n\n        try {\n            \n            // setup the demo array\n            loadStringArray();\n\n            // insert \"Bubba\" in the third positon of the array\n            insertStringByPos(2, \"Bubba\");\n\n            // delete the data in the second \n            // element/position of the array\n            deleteByPos(1);\n            \n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n        \n        System.out.println(\"\\n\\nbye\\n\");\n    }\n}\n\n\nEnd Of Topic","type":"content","url":"/arrayadddeletedata#lecture-code","position":5},{"hierarchy":{"lvl1":"Array Techniques"},"type":"lvl1","url":"/arraytechniques","position":0},{"hierarchy":{"lvl1":"Array Techniques"},"content":"Array Wrap Around\n\nArray Add and Delete Data Continuously\n\nEnd of Topic","type":"content","url":"/arraytechniques","position":1},{"hierarchy":{"lvl1":"Array Warp Around"},"type":"lvl1","url":"/arraywarparound","position":0},{"hierarchy":{"lvl1":"Array Warp Around"},"content":"","type":"content","url":"/arraywarparound","position":1},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Key Ideas"},"type":"lvl2","url":"/arraywarparound#key-ideas","position":2},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Key Ideas"},"content":"Place data in an array.\n\nIf the data element is “full/occupied”,  look to the right for the next empty element and wrap around to the beginning element if at the end.","type":"content","url":"/arraywarparound#key-ideas","position":3},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Lecture Code"},"type":"lvl2","url":"/arraywarparound#lecture-code","position":4},{"hierarchy":{"lvl1":"Array Warp Around","lvl2":"Lecture Code"},"content":"/*\n * DS132SU_WrapAround\n *\n * Programmer: Jim Goudy\n * Project: Wrap Around Array\n This shows how to wrap around in an around.\n Meaning, the program looks to see if an array\n element is open. If it is not, then look to\n the right. Continue looking to the right,\n till the next available element is open.\n \n *\n */\n\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class DS_WrapAround {\n\n    static int ArrayLength = 8;\n    static String[] myArray = new String[ArrayLength];\n    static int maxVal = ArrayLength;\n\t\n    static Scanner myScan = new Scanner(System.in);\n\tstatic Random RNG = new Random();\n    \n    static int myRNG() {\n        // Generate a random number \n        // within the number of array elements\n        return RNG.nextInt(maxVal);\n    }\n\n    static void printArray() {\n        // print the array\n        \n        for (int c = 0; c < myArray.length; c++) {\n            if (myArray[c] == null) {\n                System.out.print(\" - |\");\n            } else {\n                System.out.print(myArray[c] + \" |\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n\n        String run = \"y\";\n        int aIndex = -1;\n        boolean check = true;\n        int boxCntr = 0;\n\n        String quit = \"y\";\n        \n        // assign values to the array - go to right if occupied\n        // this loops continues till the array is full\n        while (run.equals(\"y\")) {\n            aIndex = myRNG();\n            System.out.print(\"\\nComputer chooses \" + aIndex + \"\\n\");\n\n            // fill the array element\n            while (check) {\n                if (myArray[aIndex] == null) {\n                    //array index(box) is empty\n                    myArray[aIndex] = \" X\";\n                    \n                    // this variable keeps track of \n                    // the total number of elments that\n                    // are occupied/filled\n                    boxCntr++;\n                    \n                    // sets variable to exit \n                    // the inner while loop\n                    check = false;\n                    \n                    // check if all the array elements are filled\n                    if (boxCntr == myArray.length) {\n                        run = \"n\";\n                    }\n                } else {\n                    // array index (box) is not empty \n                    aIndex++;\n                    System.out.println(\"move right \" + aIndex);\n                    \n                    // if the index is at the end of the array\n                    // wrap around to the first element 0\n                    if (aIndex == myArray.length) {\n                        aIndex = 0;\n                        System.out.println(\"move right \" + aIndex);\n                    }\n                }\n            }\n            \n            check = true;\n            printArray();\n        }\n\n    }\n}\n/*\nNote: Since the computer use a random generator to pick numbers - individual results will vary\nExample Output: \nComputer chooses 5\n - | - | - | - | - | X | - | - |\nComputer chooses 6\n - | - | - | - | - | X | X | - |\nComputer chooses 7\n - | - | - | - | - | X | X | X |\nComputer chooses 7\nmove right 8\nmove right 0\n X | - | - | - | - | X | X | X |\nComputer chooses 6\nmove right 7\nmove right 8\nmove right 0\nmove right 1\n X | X | - | - | - | X | X | X |\nComputer chooses 3\n X | X | - | X | - | X | X | X |\nComputer chooses 0\nmove right 1\nmove right 2\n X | X | X | X | - | X | X | X |\nComputer chooses 5\nmove right 6\nmove right 7\nmove right 8\nmove right 0\nmove right 1\nmove right 2\nmove right 3\nmove right 4\n X | X | X | X | X | X | X | X |\n------------------------------------------------------------------------\n*/\n\nEnd Of Topic","type":"content","url":"/arraywarparound#lecture-code","position":5},{"hierarchy":{"lvl1":"Arrays Core Functionality"},"type":"lvl1","url":"/arrayscorefunctionality","position":0},{"hierarchy":{"lvl1":"Arrays Core Functionality"},"content":"","type":"content","url":"/arrayscorefunctionality","position":1},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"sort(int[] SampleData, boolean printData)"},"type":"lvl2","url":"/arrayscorefunctionality#sort-int-sampledata-boolean-printdata","position":2},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"sort(int[] SampleData, boolean printData)"},"content":"This method implements an Insertion Sort algorithm. Unlike a traditional in-place Insertion Sort, this version copies elements from the input SampleData array into a new array, SortedData, inserting each element into its correct, sorted position within the SortedData array as it iterates. The sorted array is returned. If the printData flag is true, it prints the partially sorted array after each insertion.","type":"content","url":"/arrayscorefunctionality#sort-int-sampledata-boolean-printdata","position":3},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"reverse(int[] arr)"},"type":"lvl2","url":"/arrayscorefunctionality#reverse-int-arr","position":4},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"reverse(int[] arr)"},"content":"This function reverses the order of elements in the given array in-place. It uses a two-pointer approach, with one pointer starting at the beginning (start) and the other at the end (end) of the array, iteratively swapping the elements they point to until the pointers meet or cross. The array itself is modified, and nothing is returned.","type":"content","url":"/arrayscorefunctionality#reverse-int-arr","position":5},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByValue(int[] arr, int valueToDelete)"},"type":"lvl2","url":"/arrayscorefunctionality#deletebyvalue-int-arr-int-valuetodelete","position":6},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByValue(int[] arr, int valueToDelete)"},"content":"This method finds the first occurrence of a specified valueToDelete in the array. If found, it delegates the actual deletion to the deleteByPosition function. If the value is not found, it prints a message and returns the original array unchanged. Because Java arrays have a fixed size, this function (via deleteByPosition) returns a new array that is one element shorter than the original.","type":"content","url":"/arrayscorefunctionality#deletebyvalue-int-arr-int-valuetodelete","position":7},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByPosition(int[] theArray, int pos)"},"type":"lvl2","url":"/arrayscorefunctionality#deletebyposition-int-thearray-int-pos","position":8},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"deleteByPosition(int[] theArray, int pos)"},"content":"This is a utility function for deleting an element at a specific index (pos). It creates a new array that is one element smaller and copies all elements from the original array into the new one, skipping the element at the specified position and shifting subsequent elements left to fill the gap. The new, smaller array is returned.","type":"content","url":"/arrayscorefunctionality#deletebyposition-int-thearray-int-pos","position":9},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"printArray(int[] theArray, int dataLength)"},"type":"lvl2","url":"/arrayscorefunctionality#printarray-int-thearray-int-datalength","position":10},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"printArray(int[] theArray, int dataLength)"},"content":"A simple utility function used to print the elements of an array from the beginning up to the specified dataLength.","type":"content","url":"/arrayscorefunctionality#printarray-int-thearray-int-datalength","position":11},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"Program Execution in main"},"type":"lvl2","url":"/arrayscorefunctionality#program-execution-in-main","position":12},{"hierarchy":{"lvl1":"Arrays Core Functionality","lvl2":"Program Execution in main"},"content":"The main method orchestrates a demonstration of these functions using an initial data array: {9,1,8,2,7,3,6,5,3}.\n\nInsertion Sort: It first sorts the initial data, printing the array after each insertion, resulting in a sorted array: {1,2,3,3,5,6,7,8,9}.\n\nReverse: It then reverses the resulting sorted array in-place, yielding: {9,8,7,6,5,3,3,2,1}.\n\nDelete by Value: It deletes the first occurrence of the value 3 from the reversed array, returning a new array: {9,8,7,6,5,3,2,1}.\n\nDelete by Position: Finally, it deletes the element at index 2 (which is the value 7) from the array resulting from the previous step, producing the final array: {9,8,6,5,3,2,1}.package instinsertinorder;\n\npublic class InstInsertInOrder {\n\n    // Insertion-sort into a NEW array; optionally print after each insert.\n    static int[] sort(int[] SampleData, boolean printData) {\n        int[] SortedData = new int[SampleData.length];\n        int elementsSorted = 0; // size of the sorted prefix\n\n        // For each element in SampleData\n        for (int i = 0; i < SampleData.length; i++) {\n            int key = SampleData[i];\n            int j = elementsSorted - 1;\n\n            // While items > key, shift them right\n            while (j >= 0 && SortedData[j] > key) {\n                SortedData[j + 1] = SortedData[j];\n                j--;\n            }\n\n            // Insert key at correct position\n            SortedData[j + 1] = key;\n            elementsSorted++;\n\n            if (printData) // If enabled, show current sorted portion\n                printArray(SortedData, elementsSorted);\n        }\n        return SortedData;\n    }\n\n    /** Reverse array in place using two pointers. */\n    static void reverse(int[] arr) {\n        int start = 0, end = arr.length - 1;\n        while (start < end) { // While pointers haven't crossed\n            int tmp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = tmp;\n            start++; end--;\n        }\n    }\n\n    /**\n     * Delete first occurrence of value; returns NEW array (length-1).\n     * If not found, return original.\n     */\n    static int[] deleteByValue(int[] arr, int valueToDelete) {\n        int indexToDelete = -1;\n\n        // For each element, check for match\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == valueToDelete) { // Found target\n                indexToDelete = i;\n                break;\n            }\n        }\n\n        if (indexToDelete == -1) { // If value not found\n            System.out.println(\"Value \" + valueToDelete + \" not found.\");\n            return arr;\n        }\n\n        return deleteByPosition(arr, indexToDelete);\n    }\n\n    /**\n     * Delete element at index 'pos'; returns NEW array (length-1).\n     */\n    static int[] deleteByPosition(int[] theArray, int pos) {\n        int[] temp = new int[theArray.length - 1];\n\n        // Copy elements, skipping the deleted position\n        for (int i = 0; i < temp.length; i++) {\n            if (i >= pos) // If past delete index, shift left\n                temp[i] = theArray[i + 1];\n            else          // Otherwise copy directly\n                temp[i] = theArray[i];\n        }\n        return temp;\n    }\n\n    // Print first dataLength elements on one line.\n    static void printArray(int[] theArray, int dataLength) {\n        System.out.print(\"Array: \");\n        for (int i = 0; i < dataLength; i++) // Print up to given length\n            System.out.print(theArray[i] + \" \");\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        int[] SampleData = {9, 1, 8, 2, 7, 3, 6, 5, 3};\n\n        System.out.println(\"--- 1. Insertion Sort  ---\");\n        int[] sortedArray = sort(SampleData, true);\n\n        System.out.println(\"\\n--- 2. Reverse Function  ---\");\n        printArray(sortedArray, sortedArray.length);\n        reverse(sortedArray);\n        System.out.print(\"Array after reverse: \");\n        printArray(sortedArray, sortedArray.length);\n\n        System.out.println(\"\\n--- 3. Delete by Value  (Value 3) ---\");\n        int[] arrayAfterValueDelete = deleteByValue(sortedArray, 3);\n        System.out.print(\"Array after deleting first '3': \");\n        printArray(arrayAfterValueDelete, arrayAfterValueDelete.length);\n\n        System.out.println(\"\\n--- 4. Delete by Position  (Index 2) ---\");\n        int[] finalArray = deleteByPosition(arrayAfterValueDelete, 2);\n        System.out.print(\"Array after deleting element \\nat index 2 (Value 7): \");\n        printArray(finalArray, finalArray.length);\n\n        System.out.println(\"\\nbye\\n\");\n    }\n}\n\n\n10/2025","type":"content","url":"/arrayscorefunctionality#program-execution-in-main","position":13},{"hierarchy":{"lvl1":"Big O Notation"},"type":"lvl1","url":"/bigonotation","position":0},{"hierarchy":{"lvl1":"Big O Notation"},"content":"","type":"content","url":"/bigonotation","position":1},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Key Ideas"},"type":"lvl2","url":"/bigonotation#key-ideas","position":2},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Key Ideas"},"content":"Big O Notation\n\nNote\n\n\n\nBig O notation is used in Computer Science to describe the performance or complexity of an algorithm. Big O specifically describes the worst-case scenario and can be used to describe the execution time required or the space used (e.g. in memory or on disk) by an algorithm. - \n\nRob Bell","type":"content","url":"/bigonotation#key-ideas","position":3},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Reading"},"type":"lvl2","url":"/bigonotation#reading","position":4},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Reading"},"content":"ON_Visualizing Big O Notation","type":"content","url":"/bigonotation#reading","position":5},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Videos"},"type":"lvl2","url":"/bigonotation#videos","position":6},{"hierarchy":{"lvl1":"Big O Notation","lvl2":"Videos"},"content":"\n\nhttps://​youtu​.be​/v4cd1O4zkGw\n\nhttps://​youtu​.be​/Q​_1M2JaijjQ\n\nEnd Of Topic","type":"content","url":"/bigonotation#videos","position":7},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class"},"type":"lvl1","url":"/circularlinkedlist","position":0},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class"},"content":"","type":"content","url":"/circularlinkedlist","position":1},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Key Ideas"},"type":"lvl2","url":"/circularlinkedlist#key-ideas","position":2},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Key Ideas"},"content":"The doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nIn a circular doubly-linked list the last node (next) points to the first. The first node (previous) points to the last node.\n\nThe doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nNote\n\nNot all languages support subclasses.","type":"content","url":"/circularlinkedlist#key-ideas","position":3},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Lecture Code"},"type":"lvl2","url":"/circularlinkedlist#lecture-code","position":4},{"hierarchy":{"lvl1":"Circular Linked List - Links as Sub Class","lvl2":"Lecture Code"},"content":"package com.mycompany.linkedlistcircular;\n\n/*\n * Programmer: James Goudy\n * Project Circular LinkedList\n *\n * NOTE: last link is referenced as first.prev\n */\nclass CircularLinkedList {\n\n    Link first = new Link(\"\");\n\n    // ---------------------------------\n    // sub class - Link / Nodes\n    // NOTE: this can be a separate class as well\n    class Link {\n\n        Link first = null;\n\n        // data\n        String city = null;\n\n        // link navigation\n        Link next = null;\n        Link prev = null;\n\n        // constructor\n        Link(String city) {\n            this.city = city;\n            this.next = null;\n            this.prev = null;\n        }\n\n        public void displayNode() {\n            System.out.print(city + \" \");\n        }\n    } // end of link\n    // ---------------------------------\n\n    // constructor\n    public CircularLinkedList() {\n\n        first = null;\n    }\n\n    // add link at the beginning of the list\n    public boolean addFirst(String city) {\n\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            // empty list\n            newLink.next = newLink;\n            newLink.prev = newLink;\n\n            first = newLink;\n\n        } else {\n\n            // connect the newLink references\n            newLink.next = first;\n\n            newLink.prev = first.prev;\n\n            first.prev = newLink;\n\n            // move first to the new link\n            first = newLink;\n\n            // point the last link to the new first\n            first.prev.next = first;\n\n        }\n\n        return true;\n    }\n\n    // add link to the end of the list\n    public boolean addLast(String city) {\n\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            //list is empty\n            first = newLink;\n        } else {\n            // set new link references\n            newLink.next = first;\n\n            newLink.prev = first.prev;\n\n            // last link is (first.prev)\n            first.prev.next = newLink;\n\n            first.prev = newLink;\n\n        }\n\n        return true;\n    }\n\n    public boolean findCity(String citySearch) {\n\n        if (first == null) {\n\n            // if list is empty\n            return false;\n        } else {\n            Link current = first;\n\n            do {\n                if (current.city.equals(citySearch)) {\n                    return true;\n                }\n                current = current.next;\n\n            } while (current != first);\n\n            return false;\n        }\n    }\n\n    public boolean insertAfter(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check if last link\n                    if (current.next == first.prev) {\n                        // check if last link\n                        current.next = newLink;\n                        newLink.prev = current;\n\n                        first.prev = newLink;\n\n                    } else {\n                        newLink.next = current.next;\n                        newLink.prev = current;\n\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n\n    }\n\n    public boolean insertBefore(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check for first link\n                    if (current.prev == null) {\n                        // check if last link\n                        current.prev = newLink;\n                        newLink.next = current;\n\n                        first = newLink;\n\n                    } else {\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n    }\n\n    public boolean deleteCity(String citySearch) {\n\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            do {\n                if (current.city.equals(citySearch)) {\n\n                    if (current.prev == null) {\n                        // first node\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true;\n                    } else if (current.next == null) {\n                        // last node\n                        current.prev.next = null;\n                        first.prev = current;\n                        current = null;\n                        return true;\n                    } else {\n                        // a center node\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n\n                        return true;\n                    }\n                }\n\n                current = current.next;\n            } while (current != first);\n\n            return false;\n        }\n    } //end of function\n\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\\n** Display List Forward To Back **\");\n\n        do {\n            current.displayNode();\n            current = current.next;\n            if (current == first) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.next != null);\n\n    } // end of method\n\n    public void displayList(String startCity) {\n\n        Link current = first;\n        Link start = null;\n\n        System.out.println(\"\\n ** Display List Forward To Back\"\n                + \" starting at \" + startCity + \"**\");\n\n        // find the city in the list\n        do {\n            if (current.city.equals(startCity)) {\n                break;\n            }\n\n            current = current.next;\n\n            if (current == first) {\n                System.out.println(\"City Not Found\");\n                return;\n            }\n\n        } while (current.next != null);\n\n        System.out.println(\"\");\n\n        start = current;\n\n        do {\n            current.displayNode();\n            current = current.next;\n            if (current == start) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.next != null);\n\n    } // end of method\n\n    public void displayListReverse() {\n\n        Link current = first.prev;\n\n        System.out.println(\"\\n** Display List in Reverse **\\n\");\n\n        do {\n            current.displayNode();\n            current = current.prev;\n            if (current == first.prev) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.prev != null);\n    } // end of method\n\n    public void displayListReverse(String startCity) {\n\n        Link current = first;\n        Link start = null;\n\n        System.out.println(\"\\n ** Display list in reverse\"\n                + \" starting at \" + startCity + \"**\");\n\n        // find the city in the list\n        do {\n            if (current.city.equals(startCity)) {\n                break;\n            }\n\n            current = current.next;\n\n            if (current == first) {\n                System.out.println(\"City Not Found\");\n                return;\n            }\n\n        } while (current.next != null);\n\n        System.out.println(\"\");\n\n        start = current;\n\n        do {\n            current.displayNode();\n            current = current.prev;\n            if (current == start) {\n                System.out.println(\"\\n-----------\\n\");\n                return;\n            }\n\n        } while (current.prev != null);\n    } // end of method\n\n} // end of class\n\npublic class DS_LinkedListCircular {\n\n    static CircularLinkedList dl = new CircularLinkedList();\n\n    public static void citySearch(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.findCity(searchCity)) {\n            System.out.println(\"\\n\" + searchCity + \" is in list\");\n        } else {\n            System.out.println(\"\\n\" + searchCity + \" not found\");\n        }\n\n    }\n\n    public static void deleteCity(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.deleteCity(searchCity)) {\n            System.out.println(searchCity + \" was deleted\");\n        } else {\n            System.out.println(searchCity + \" was NOT deleted\");\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        String searchCity = \"\";\n        String insertCity = \"\";\n\n        // insert data at front of list\n        dl.addFirst(\"Kali\");\n        dl.addFirst(\"Polson\");\n        dl.addFirst(\"Missoula\");\n        dl.addFirst(\"Whitefish\");\n        dl.addFirst(\"Plains\");\n\n        // insert data at end of list\n        dl.addLast(\"Chicago\");\n        dl.addLast(\"Denver\");\n        dl.addLast(\"Sandiego\");\n\n        dl.displayList();\n        dl.displayListReverse();\n\n        dl.displayList(\"Missoula\");\n        dl.displayList(\"Wolfcreek\");\n\n        dl.displayListReverse();\n        dl.displayListReverse(\"Missoula\");\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        citySearch(searchCity);\n\n        searchCity = \"Bozeman\";\n        citySearch(searchCity);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchCity = \"Polson\";\n        deleteCity(searchCity);\n\n        searchCity = \"Bozeman\";\n        deleteCity(searchCity);\n\n        searchCity = \"Sandiego\";\n        deleteCity(searchCity);\n\n        searchCity = \"Whitefish\";\n        deleteCity(searchCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Insert After Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        insertCity = \"Dayton\";\n        dl.insertAfter(searchCity, insertCity);\n\n        searchCity = \"Denver\";\n        insertCity = \"Boulder\";\n        dl.insertAfter(searchCity, insertCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Insert After Examples------\\n\");\n\n        searchCity = \"Chicago\";\n        insertCity = \"Springfield\";\n        dl.insertBefore(searchCity, insertCity);\n\n        searchCity = \"Missoula\";\n        insertCity = \"Libby\";\n        dl.insertBefore(searchCity, insertCity);\n\n        dl.displayList();\n        System.out.println(\"\\nbye\");\n    }\n}\n/*\n * output\n *\n ** Display List Forward To Back **\n * Plains Whitefish Missoula Polson Kali Chicago Denver Sandiego\n * -----------\n *\n *\n ** Display List in Reverse **\n *\n * Sandiego Denver Chicago Kali Polson Missoula Whitefish Plains\n * -----------\n *\n *\n ** Display List Forward To Back starting at Missoula**\n *\n * Missoula Polson Kali Chicago Denver Sandiego Plains Whitefish\n * -----------\n *\n *\n ** Display List Forward To Back starting at Wolfcreek**\n * City Not Found\n *\n ** Display List in Reverse **\n *\n * Sandiego Denver Chicago Kali Polson Missoula Whitefish Plains\n * -----------\n *\n *\n ** Display list in reverse starting at Missoula**\n *\n * Missoula Whitefish Plains Sandiego Denver Chicago Kali Polson\n * -----------\n *\n *\n * ----- Find Examples------\n *\n *\n * Missoula is in list\n *\n * Bozeman not found\n *\n * ----- Delete Examples------\n *\n * Polson was deleted\n * Bozeman was NOT deleted\n * Sandiego was deleted\n * Whitefish was deleted\n *\n ** Display List Forward To Back **\n * Plains Missoula Kali Chicago Denver\n * -----------\n *\n *\n * ----- Insert After Examples------\n *\n *\n ** Display List Forward To Back **\n * Plains Missoula Dayton Kali Chicago Denver Boulder\n * -----------\n *\n *\n * ----- Insert After Examples------\n *\n *\n ** Display List Forward To Back **\n * Plains Libby Missoula Dayton Kali Springfield Chicago Denver Boulder\n * -----------\n *\n *\n * bye\n *\n */\n\n\nEnd Of Topic","type":"content","url":"/circularlinkedlist#lecture-code","position":5},{"hierarchy":{"lvl1":"Data Structures and Algorithms"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Data Structures and Algorithms"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Data Structures and Algorithms","lvl2":"Textbooks and Online Sources"},"type":"lvl2","url":"/#textbooks-and-online-sources","position":2},{"hierarchy":{"lvl1":"Data Structures and Algorithms","lvl2":"Textbooks and Online Sources"},"content":"\n\nData Structures and Algorithms in Java\nSecond Edition\nRobert Lafore\n\nData Structures and Algorithms in Java 6th Edition\nMichael T. Goodrich\n\nAlgorithms (4th Edition) 4th Edition by Robert Sedgewick and Kevin Wayne\n\nOpen Data Structures    |\n\nEnd Of Topic","type":"content","url":"/#textbooks-and-online-sources","position":3},{"hierarchy":{"lvl1":"Doubly Linked List"},"type":"lvl1","url":"/doublylinkedlist","position":0},{"hierarchy":{"lvl1":"Doubly Linked List"},"content":"","type":"content","url":"/doublylinkedlist","position":1},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Key Ideas"},"type":"lvl2","url":"/doublylinkedlist#key-ideas","position":2},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Key Ideas"},"content":"The doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nA doubly linked list is a type of linked list in which each node contains three parts:\n\nData: The value stored in the node.\n\nPointer to the next node: A reference to the next node in the list.\n\nPointer to the previous node: A reference to the previous node in the list.","type":"content","url":"/doublylinkedlist#key-ideas","position":3},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Structure:","lvl2":"Key Ideas"},"type":"lvl3","url":"/doublylinkedlist#structure","position":4},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Structure:","lvl2":"Key Ideas"},"content":"In a doubly linked list, each node is connected to both its next and previous nodes, creating a two-way linkage.\n\nThe first node (head) has its previous pointer set to null, and the last node (tail) has its next pointer set to null.","type":"content","url":"/doublylinkedlist#structure","position":5},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Benefits of a Doubly Linked List:","lvl2":"Key Ideas"},"type":"lvl3","url":"/doublylinkedlist#benefits-of-a-doubly-linked-list","position":6},{"hierarchy":{"lvl1":"Doubly Linked List","lvl3":"Benefits of a Doubly Linked List:","lvl2":"Key Ideas"},"content":"Bidirectional Traversal: You can easily traverse the list in both forward and backward directions.\n\nEfficient Deletion: Insertion and deletion of nodes can be more efficient since you can easily access the previous node.","type":"content","url":"/doublylinkedlist#benefits-of-a-doubly-linked-list","position":7},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Lecture Code"},"type":"lvl2","url":"/doublylinkedlist#lecture-code","position":8},{"hierarchy":{"lvl1":"Doubly Linked List","lvl2":"Lecture Code"},"content":"/*\n * Programmer: James Goudy\n * Project: Doubly Linked List \n */\n\n// Define a class representing each link/node in the doubly linked list\nclass Link {\n\n    // Pointers for the first and last nodes in the list\n    Link first = null;\n    Link last = null;\n\n    // Data stored in the node\n    String city = null;\n\n    // Pointers for the next and previous nodes\n    Link next = null;\n    Link prev = null;\n\n    // Constructor to initialize a node with the city name\n    Link(String city) {\n        this.city = city;\n        this.next = null;\n        this.prev = null;\n    }\n\n    // Display the data of the current node\n    public void displayNode() {\n        System.out.print(city + \" \");\n    }\n} // End of Link class\n\n// Define a class representing the doubly linked list itself\nclass Doubly {\n\n    // References to the first and last nodes in the list\n    Link first = null;\n    Link last = null;\n\n    // Constructor to initialize an empty doubly linked list\n    public Doubly() {\n        first = null;\n        last = null;\n    }\n\n    // Method to add a node at the beginning of the list\n    public boolean addFirst(String city) {\n        Link newLink = new Link(city);\n\n        // If list is empty, set first and last to the new node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            // Otherwise, update pointers for the new node and the current first node\n            newLink.next = first;\n            first.prev = newLink;\n            first = newLink;\n        }\n\n        return true;\n    }\n\n    // Method to add a node at the end of the list\n    public boolean addLast(String city) {\n        Link newLink = new Link(city);\n\n        // If list is empty, set first and last to the new node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            // Otherwise, update pointers for the new node and the current last node\n            newLink.prev = last;\n            last.next = newLink;\n            last = newLink;\n        }\n\n        return true;\n    }\n\n    // Method to find a city in the list\n    public boolean findCity(String citySearch) {\n\n        // If list is empty, return false\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            // Traverse the list to search for the city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n                    return true; // City found\n                }\n                current = current.next;\n            }\n\n            return false; // City not found\n        }\n    }\n\n    // Method to insert a new node after a given city\n    public boolean insertAfter(String citySearch, String insertCity) {\n        Link newLink = new Link(insertCity);\n\n        // If list is empty, add the new node as the only node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            Link current = first;\n\n            // Traverse the list to find the specified city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // If the city is the last node, update last\n                    if (current.next == null) {\n                        current.next = newLink;\n                        newLink.prev = current;\n                        last = newLink;\n                    } else {\n                        // Update pointers for inserting in the middle\n                        newLink.next = current.next;\n                        newLink.prev = current;\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true; // City inserted\n                }\n                current = current.next;\n            }\n        }\n\n        return false; // City not found\n    }\n\n    // Method to insert a new node before a given city\n    public boolean insertBefore(String citySearch, String insertCity) {\n        Link newLink = new Link(insertCity);\n\n        // If list is empty, add the new node as the only node\n        if (first == null) {\n            first = newLink;\n            last = newLink;\n        } else {\n            Link current = first;\n\n            // Traverse the list to find the specified city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // If the city is the first node, update first\n                    if (current.prev == null) {\n                        current.prev = newLink;\n                        newLink.next = current;\n                        first = newLink;\n                    } else {\n                        // Update pointers for inserting in the middle\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true; // City inserted\n                }\n                current = current.next;\n            }\n        }\n\n        return false; // City not found\n    }\n\n    // Method to delete a node with a specified city\n    public boolean deleteCity(String citySearch) {\n\n        // If list is empty, return false\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            // Traverse the list to find the specified city\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // If the city is the first node\n                    if (current.prev == null) {\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true; // City deleted\n                    } else if (current.next == null) {\n                        // If the city is the last node\n                        current.prev.next = null;\n                        last = current.prev;\n                        current = null;\n                        return true; // City deleted\n                    } else {\n                        // If the city is in the middle\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n                        return true; // City deleted\n                    }\n                }\n                current = current.next;\n            }\n\n            return false; // City not found\n        }\n    }\n\n    // Method to display the entire list\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode(); // Display each node\n            current = current.next; // Move to next node\n        }\n        System.out.println(\"\");\n    }\n}\n\n// Main class to demonstrate doubly linked list functionality\npublic class DS_DoublyLinkedList {\n\n    // Create an instance of the Doubly linked list\n    static Doubly dl = new Doubly();\n\n    // Method to search for a city\n    public static void citySearch(String searchCity) {\n        if (dl.findCity(searchCity)) {\n            System.out.println(\"\\n\" + searchCity + \" is in the list\");\n        } else {\n            System.out.println(\"\\n\" + searchCity + \" not found\");\n        }\n    }\n\n    // Method to delete a city\n    public static void deleteCity(String searchCity) {\n        if (dl.deleteCity(searchCity)) {\n            System.out.println(searchCity + \" was deleted\");\n        } else {\n            System.out.println(searchCity + \" was NOT deleted\");\n        }\n    }\n\n    // Main method to execute the program\n    public static void main(String[] args) {\n\n        String searchCity = \"\";\n        String insertCity = \"\";\n\n        // Insert data at the front of the list\n        dl.addFirst(\"Kali\");\n        dl.addFirst(\"Polson\");\n        dl.addFirst(\"Missoula\");\n        dl.addFirst(\"Whitefish\");\n\n        // Insert data at the end of the list\n        dl.addLast(\"Chicago\");\n        dl.addLast(\"Denver\");\n        dl.addLast(\"Sandiego\");\n\n        dl.displayList(); // Display the list\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchCity = \"Chicago\";\n        citySearch(searchCity);\n\n        searchCity = \"Bozeman\";\n        citySearch(searchCity);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchCity = \"Polson\";\n        deleteCity(searchCity);\n\n        searchCity = \"Bozeman\";\n        deleteCity(searchCity);\n\n        searchCity = \"Sandiego\";\n        deleteCity(searchCity);\n\n        searchCity = \"Whitefish\";\n        deleteCity(searchCity);\n\n        dl.displayList(); // Display the list\n\n        System.out.println(\"\\n----- Insert Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        insertCity = \"Dayton\";\n        dl.insertAfter(searchCity, insertCity);\n\n        searchCity = \"Denver\";\n        insertCity = \"Boulder\";\n        dl.insertAfter(searchCity, insertCity);\n\n        dl.displayList(); // Display the list\n\n        searchCity = \"Chicago\";\n        insertCity = \"Springfield\";\n        dl.insertBefore(searchCity, insertCity);\n\n        searchCity = \"Missoula\";\n        insertCity = \"Libby\";\n        dl.insertBefore(searchCity, insertCity);\n\n        dl.displayList(); // Display the list\n\n        System.out.println(\"\\nbye\");\n    }\n}\n\n/*\n * OUTPUT  *\n * Whitefish Missoula Polson Kali Chicago Denver Sandiego  *\n * ----- Find Examples------\n *\n *\n * Chicago is in list\n *\n * Bozeman not found\n *\n * ----- Delete Examples------\n *\n * Polson was deleted\n * Bozeman was NOT deleted\n * Sandiego was deleted\n * Whitefish was deleted\n *\n * Missoula Kali Chicago Denver  *\n * ----- Insert Examples------\n *\n *\n * Missoula Dayton Kali Chicago Denver Boulder  *\n * Libby Missoula Dayton Kali Springfield Chicago Denver Boulder  *\n * bye\n *\n */\n\n\n\nEnd Of Topic","type":"content","url":"/doublylinkedlist#lecture-code","position":9},{"hierarchy":{"lvl1":"C# Linked List Class"},"type":"lvl1","url":"/doublylinkedlistcsharp","position":0},{"hierarchy":{"lvl1":"C# Linked List Class"},"content":"Here’s the revised version, adding information about ArrayList in Section 3:","type":"content","url":"/doublylinkedlistcsharp","position":1},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"1. What is a Linked List?"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-1-what-is-a-linked-list","position":2},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"1. What is a Linked List?"},"content":"A linked list is a data structure used to store a sequence of elements, where each element is called a node. In the case of a doubly linked list:\n\nData: Each node contains the data or value.\n\nPointers: Each node has two pointers—one pointing to the next node and one pointing to the previous node.\n\nC# has a built-in generic LinkedList<T> class that represents a doubly linked list, supporting dynamic memory allocation and efficient insertions and deletions.","type":"content","url":"/doublylinkedlistcsharp#id-1-what-is-a-linked-list","position":3},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"2. Real-Life Applications of Linked Lists"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-2-real-life-applications-of-linked-lists","position":4},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"2. Real-Life Applications of Linked Lists"},"content":"Music Playlists: Linked lists can manage playlists, where songs can be accessed or rearranged using the next and previous pointers.\n\nUndo Functionality in Applications: Applications like text editors can use linked lists to maintain a history of changes.\n\nWeb Browser History: Browsers can use linked lists to manage navigation history, allowing forward and backward traversal.\n\nDynamic Memory Allocation: Operating systems can use linked lists to manage memory blocks, making memory allocation and deallocation efficient.\n\nAdjacency Lists in Graphs: In graphs, adjacency lists are often implemented using linked lists for efficient traversal of vertices and edges.","type":"content","url":"/doublylinkedlistcsharp#id-2-real-life-applications-of-linked-lists","position":5},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"3. ArrayList vs. LinkedList"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-3-arraylist-vs-linkedlist","position":6},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"3. ArrayList vs. LinkedList"},"content":"C# provides two main collections that can be used to manage dynamic sequences of elements: ArrayList and LinkedList<T>. Here’s a comparison:\n\nFeature\n\nArrayList\n\nLinkedList (C#)\n\nUnderlying Data Structure\n\nResizable array\n\nDoubly linked list\n\nMemory Allocation\n\nContiguous (requires resizing)\n\nNon-contiguous (nodes can be scattered)\n\nAccess Time\n\nO(1) for index-based access\n\nO(n) (must traverse nodes)\n\nInsertion/Deletion\n\nO(n) for shifting elements\n\nO(1) at ends; O(n) for middle\n\nMemory Overhead\n\nLess (just array)\n\nMore (extra pointers for each node)\n\nSearch Complexity\n\nO(n) (linear search)\n\nO(n) (linear search)\n\nThread Safety\n\nNot synchronized (not thread-safe)\n\nNot synchronized (not thread-safe)","type":"content","url":"/doublylinkedlistcsharp#id-3-arraylist-vs-linkedlist","position":7},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Key Differences:","lvl2":"3. ArrayList vs. LinkedList"},"type":"lvl3","url":"/doublylinkedlistcsharp#key-differences","position":8},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Key Differences:","lvl2":"3. ArrayList vs. LinkedList"},"content":"Access Speed:\n\nArrayList provides faster access due to contiguous memory allocation, allowing elements to be accessed directly via index.\n\nLinkedList<T> requires traversal from the head to access an element by index, making it slower for random access.\n\nInsertion and Deletion:\n\nArrayList has slower insertion and deletion times (O(n) in the worst case) because elements need to be shifted.\n\nLinkedList<T> excels in insertions and deletions at both ends (O(1)), making it ideal for scenarios where these operations are frequent.\n\nMemory Usage:\n\nArrayList typically uses less memory since it only stores the elements.\n\nLinkedList<T> uses more memory due to the extra pointers needed for each node.","type":"content","url":"/doublylinkedlistcsharp#key-differences","position":9},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Use Cases:","lvl2":"3. ArrayList vs. LinkedList"},"type":"lvl3","url":"/doublylinkedlistcsharp#use-cases","position":10},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"Use Cases:","lvl2":"3. ArrayList vs. LinkedList"},"content":"ArrayList: Better suited for scenarios where fast access to elements is needed and the size of the data structure is stable or grows infrequently.\n\nLinkedList: Ideal for applications that require frequent insertions and deletions, such as queues, stacks, and dynamic data management.","type":"content","url":"/doublylinkedlistcsharp#use-cases","position":11},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"4. Use Cases"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-4-use-cases","position":12},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"4. Use Cases"},"content":"ArrayList: Best for fast access and stable size.\n\nLinkedList: Ideal for scenarios involving frequent insertions and deletions, particularly at the ends.","type":"content","url":"/doublylinkedlistcsharp#id-4-use-cases","position":13},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"5. C# Linked List Methods"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-5-c-linked-list-methods","position":14},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"5. C# Linked List Methods"},"content":"Here’s a breakdown of common methods in the C# LinkedList<T> class:\n\nC# Method\n\nDescription\n\nAddLast(T value)\n\nAdds an element to the end of the list.\n\nAddFirst(T value)\n\nAdds an element at the start of the list.\n\nRemove(T value)\n\nRemoves the first occurrence of the specified element.\n\nRemoveFirst()\n\nRemoves and returns the first element.\n\nRemoveLast()\n\nRemoves and returns the last element.\n\nCount\n\nReturns the number of elements in the list.","type":"content","url":"/doublylinkedlistcsharp#id-5-c-linked-list-methods","position":15},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"6. Demo Code"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-6-demo-code","position":16},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"6. Demo Code"},"content":"Here’s a C# code example that performs basic operations with LinkedList<T>:using System;\nusing System.Collections.Generic;\n\npublic class LinkedListDemo\n{\n    public static void Main(string[] args)\n    {\n        // Create a LinkedList\n        LinkedList<string> list = new LinkedList<string>();\n\n        // Add elements to the LinkedList\n        list.AddLast(\"Apple\");\n        list.AddLast(\"Banana\");\n        list.AddLast(\"Cherry\");\n        list.AddFirst(\"Mango\");\n        list.AddLast(\"Orange\");\n\n        // Display the LinkedList\n        Console.WriteLine(\"Initial LinkedList: \" + string.Join(\", \", list));\n\n        // Access elements in the LinkedList\n        Console.WriteLine(\"First element: \" + list.First.Value);\n        Console.WriteLine(\"Last element: \" + list.Last.Value);\n\n        // Check the size of the LinkedList\n        Console.WriteLine(\"Size of LinkedList: \" + list.Count);\n\n        // Remove elements from the LinkedList\n        list.RemoveFirst();\n        list.RemoveLast();\n        list.Remove(\"Banana\");\n\n        // Display the LinkedList after removals\n        Console.WriteLine(\"LinkedList after removals: \" + string.Join(\", \", list));\n\n        // Check if LinkedList contains a specific element\n        if (list.Contains(\"Cherry\"))\n        {\n            Console.WriteLine(\"LinkedList contains Cherry\");\n        }\n        else\n        {\n            Console.WriteLine(\"LinkedList does not contain Cherry\");\n        }\n\n        // Clear the LinkedList\n        list.Clear();\n        Console.WriteLine(\"LinkedList after clearing: \" + (list.Count == 0 ? \"Empty\" : string.Join(\", \", list)));\n    }\n}","type":"content","url":"/doublylinkedlistcsharp#id-6-demo-code","position":17},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"7. Iterator with LinkedList in C#"},"type":"lvl2","url":"/doublylinkedlistcsharp#id-7-iterator-with-linkedlist-in-c","position":18},{"hierarchy":{"lvl1":"C# Linked List Class","lvl2":"7. Iterator with LinkedList in C#"},"content":"Iterators allow sequential traversal through a linked list in C#, facilitating the processing of each element.","type":"content","url":"/doublylinkedlistcsharp#id-7-iterator-with-linkedlist-in-c","position":19},{"hierarchy":{"lvl1":"C# Linked List Class","lvl4":"Example Code Using Iterator with LinkedList:","lvl2":"7. Iterator with LinkedList in C#"},"type":"lvl4","url":"/doublylinkedlistcsharp#example-code-using-iterator-with-linkedlist","position":20},{"hierarchy":{"lvl1":"C# Linked List Class","lvl4":"Example Code Using Iterator with LinkedList:","lvl2":"7. Iterator with LinkedList in C#"},"content":"using System;\nusing System.Collections.Generic;\n\npublic class LinkedListIteratorDemo\n{\n    public static void Main(string[] args)\n    {\n        LinkedList<string> list = new LinkedList<string>(new[] { \"Apple\", \"Banana\", \"Cherry\", \"Mango\" });\n\n        // Get an enumerator for the LinkedList\n        var enumerator = list.GetEnumerator();\n\n        Console.WriteLine(\"Traversing the LinkedList:\");\n        while (enumerator.MoveNext())\n        {\n            string element = enumerator.Current;\n            Console.WriteLine(element);\n\n            // Remove \"Banana\" during iteration\n            if (element == \"Banana\")\n            {\n                list.Remove(element);\n                Console.WriteLine(\"\\\"Banana\\\" has been removed\");\n            }\n        }\n\n        // Display the LinkedList after iteration\n        Console.WriteLine(\"\\nLinkedList after iteration: \" + string.Join(\", \", list));\n    }\n}","type":"content","url":"/doublylinkedlistcsharp#example-code-using-iterator-with-linkedlist","position":21},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"8. Why Use an Iterator with LinkedList in C#?","lvl2":"7. Iterator with LinkedList in C#"},"type":"lvl3","url":"/doublylinkedlistcsharp#id-8-why-use-an-iterator-with-linkedlist-in-c","position":22},{"hierarchy":{"lvl1":"C# Linked List Class","lvl3":"8. Why Use an Iterator with LinkedList in C#?","lvl2":"7. Iterator with LinkedList in C#"},"content":"Efficient Traversal: Iterators (or enumerators) provide an efficient way to traverse through linked list nodes.\n\nModification During Traversal: Enumerators allow safe modification of elements during traversal, making them useful for dynamic data handling.","type":"content","url":"/doublylinkedlistcsharp#id-8-why-use-an-iterator-with-linkedlist-in-c","position":23},{"hierarchy":{"lvl1":"Java Linked List Class"},"type":"lvl1","url":"/doublylinkedlistjava","position":0},{"hierarchy":{"lvl1":"Java Linked List Class"},"content":"","type":"content","url":"/doublylinkedlistjava","position":1},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"What is a Linked List?"},"type":"lvl2","url":"/doublylinkedlistjava#what-is-a-linked-list","position":2},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"What is a Linked List?"},"content":"A linked list is a data structure used to store a collection of elements (nodes). Each node contains two parts:\n\nData: The actual value or information.\n\nPointer (or Reference): A link to the next node in the sequence (and optionally, a link to the previous node in the case of doubly linked lists).\n\nLinked lists allow for dynamic memory allocation and efficient insertions and deletions since nodes can be added or removed without reorganizing the entire structure. Unlike arrays, linked lists do not require a contiguous block of memory, making them more flexible.","type":"content","url":"/doublylinkedlistjava#what-is-a-linked-list","position":3},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Real-Life Applications of Linked Lists"},"type":"lvl2","url":"/doublylinkedlistjava#real-life-applications-of-linked-lists","position":4},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Real-Life Applications of Linked Lists"},"content":"Music Playlists:\n\nA music player can use a linked list to manage a playlist. Each song can be a node, and the player can easily move forward or backward through the playlist (using next and previous pointers), allowing for easy manipulation of the song order.\n\nUndo Functionality in Applications:\n\nMany applications, like text editors, implement an undo feature using a linked list. Each action can be stored as a node in the list, allowing users to navigate backward through their actions and revert to previous states.\n\nWeb Browser History:\n\nBrowsers use linked lists to maintain the history of visited pages. Each page can be a node, and users can navigate forward and backward through their browsing history easily.\n\nDynamic Memory Allocation:\n\nOperating systems often use linked lists for managing memory. For instance, free memory blocks can be stored as nodes, allowing the OS to allocate and deallocate memory efficiently as processes start and finish.\n\nAdjacency Lists in Graphs:\n\nIn graph data structures, linked lists are often used to represent adjacency lists. Each node in the list represents a vertex, and its linked nodes represent the edges connecting to other vertices, allowing for efficient traversal of graph data.\n\nThese applications highlight the versatility and efficiency of linked lists in various scenarios, particularly where dynamic data management is essential.","type":"content","url":"/doublylinkedlistjava#real-life-applications-of-linked-lists","position":5},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"ArrayList vs. LinkedList"},"type":"lvl2","url":"/doublylinkedlistjava#arraylist-vs-linkedlist","position":6},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"ArrayList vs. LinkedList"},"content":"Feature\n\nArrayList\n\nLinkedList\n\nUnderlying Data Structure\n\nResizable array\n\nDoubly linked list\n\nMemory Allocation\n\nContiguous memory (requires resizing when full)\n\nNon-contiguous memory (nodes can be scattered)\n\nAccess Time\n\nO(1) for index-based access\n\nO(n) for index-based access (must traverse nodes)\n\nInsertion/Deletion\n\nO(n) in the worst case (shifting elements needed)\n\nO(1) for adding/removing at ends; O(n) for middle (traversal needed)\n\nMemory Overhead\n\nLess overhead (just the array)\n\nMore overhead (extra pointers for each node)\n\nPerformance for Large Data\n\nBetter for large datasets with frequent access\n\nBetter for large datasets with frequent insertions/deletions\n\nSearch Complexity\n\nO(n) (linear search)\n\nO(n) (linear search)\n\nThread Safety\n\nNot synchronized (not thread-safe by default)\n\nNot synchronized (not thread-safe by default)\n\nUse Cases\n\nBest for frequent access, fewer insertions/deletions\n\nBest for frequent insertions/deletions, less access\n\nIteration\n\nFaster for sequential access due to locality of reference\n\nSlower for sequential access (due to pointers)","type":"content","url":"/doublylinkedlistjava#arraylist-vs-linkedlist","position":7},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Summary of Key Differences","lvl2":"ArrayList vs. LinkedList"},"type":"lvl3","url":"/doublylinkedlistjava#summary-of-key-differences","position":8},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Summary of Key Differences","lvl2":"ArrayList vs. LinkedList"},"content":"Access Speed:\n\nArrayList allows for faster access due to its contiguous memory allocation. You can directly access any element via its index.\n\nLinkedList requires traversal from the head to access an element by index, making it slower for random access.\n\nInsertion and Deletion:\n\nArrayList has slower insertion and deletion times (O(n) in the worst case) because elements may need to be shifted.\n\nLinkedList excels in insertions and deletions at both ends (O(1)), making it ideal for scenarios where these operations are frequent.\n\nMemory Usage:\n\nArrayList typically uses less memory per element since it only stores the elements.\n\nLinkedList uses more memory due to the extra pointers needed for each node.","type":"content","url":"/doublylinkedlistjava#summary-of-key-differences","position":9},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Use Cases","lvl2":"ArrayList vs. LinkedList"},"type":"lvl3","url":"/doublylinkedlistjava#use-cases","position":10},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Use Cases","lvl2":"ArrayList vs. LinkedList"},"content":"ArrayList: Ideal for scenarios where you need fast access to elements and the size of the data structure is stable or grows infrequently.\n\nLinkedList: Better suited for applications that involve frequent insertions and deletions, such as queues or stacks.","type":"content","url":"/doublylinkedlistjava#use-cases","position":11},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Conclusion","lvl2":"ArrayList vs. LinkedList"},"type":"lvl3","url":"/doublylinkedlistjava#conclusion","position":12},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Conclusion","lvl2":"ArrayList vs. LinkedList"},"content":"Choosing between an ArrayList and a LinkedList depends on the specific use case and performance needs. If you need frequent access and stable size, go for ArrayList. If your application requires a lot of insertions and deletions, opt for LinkedList.","type":"content","url":"/doublylinkedlistjava#conclusion","position":13},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Java Linked List Methods"},"type":"lvl2","url":"/doublylinkedlistjava#java-linked-list-methods","position":14},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Java Linked List Methods"},"content":"Method\n\nDescription\n\nadd(E e)\n\nAppends the specified element to the end of the list.\n\nadd(int index, E element)\n\nInserts the specified element at the specified position.\n\naddFirst(E e)\n\nInserts the specified element at the beginning of the list.\n\naddLast(E e)\n\nAppends the specified element to the end of the list.\n\nremove(Object o)\n\nRemoves the first occurrence of the specified element.\n\nremove(int index)\n\nRemoves the element at the specified position.\n\nremoveFirst()\n\nRemoves and returns the first element of the list.\n\nremoveLast()\n\nRemoves and returns the last element of the list.\n\nget(int index)\n\nReturns the element at the specified position.\n\nset(int index, E element)\n\nReplaces the element at the specified position with the given element.\n\nsize()\n\nReturns the number of elements in the list.\n\nisEmpty()\n\nReturns true if the list is empty, false otherwise.\n\nclear()\n\nRemoves all elements from the list.\n\ncontains(Object o)\n\nReturns true if the list contains the specified element.\n\nindexOf(Object o)\n\nReturns the index of the first occurrence of the specified element, or -1 if not found.\n\nlastIndexOf(Object o)\n\nReturns the index of the last occurrence of the specified element, or -1 if not found.\n\nlistIterator()\n\nReturns a list iterator over the elements in the list.\n\niterator()\n\nReturns an iterator over the elements in the list.\n\ntoArray()\n\nReturns an array containing all elements in the list.\n\ntoArray(T[] a)\n\nReturns an array containing all elements in the list; the runtime type of the returned array is that of the specified array.\n\naddAll(Collection<? extends E> c)\n\nAppends all elements in the specified collection to the end of the list.\n\naddAll(int index, Collection<? extends E> c)\n\nInserts all elements in the specified collection at the specified position.\n\nremoveAll(Collection<?> c)\n\nRemoves all elements in this list that are contained in the specified collection.\n\nretainAll(Collection<?> c)\n\nRetains only the elements in this list that are contained in the specified collection.\n\nclone()\n\nReturns a shallow copy of the list.","type":"content","url":"/doublylinkedlistjava#java-linked-list-methods","position":15},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Demo Code"},"type":"lvl2","url":"/doublylinkedlistjava#demo-code","position":16},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"Demo Code"},"content":"Here is a Java program that demonstrates the most frequently used methods in the LinkedList class. This program showcases common operations such as adding, removing, accessing elements, and checking the size of the list:import java.util.LinkedList;\n\npublic class LinkedListDemo {\n    public static void main(String[] args) {\n        // Create a LinkedList\n        LinkedList<String> list = new LinkedList<>();\n        \n        // Add elements to the LinkedList\n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Cherry\");\n        list.addFirst(\"Mango\"); // Adds element at the start\n        list.addLast(\"Orange\"); // Adds element at the end\n        \n        // Display the LinkedList\n        System.out.println(\"Initial LinkedList: \" + list);\n\n        // Access elements in the LinkedList\n        System.out.println(\"First element: \" + list.getFirst());\n        System.out.println(\"Last element: \" + list.getLast());\n        System.out.println(\"Element at index 2: \" + list.get(2));\n\n        // Check the size of the LinkedList\n        System.out.println(\"Size of LinkedList: \" + list.size());\n\n        // Remove elements from the LinkedList\n        list.removeFirst(); // Removes the first element\n        list.removeLast();  // Removes the last element\n        list.remove(1);     // Removes element at index 1\n        \n        // Display the LinkedList after removals\n        System.out.println(\"LinkedList after removals: \" + list);\n\n        // Check if LinkedList contains a specific element\n        if (list.contains(\"Banana\")) {\n            System.out.println(\"LinkedList contains Banana\");\n        } else {\n            System.out.println(\"LinkedList does not contain Banana\");\n        }\n\n        // Clear the LinkedList\n        list.clear();\n        System.out.println(\"LinkedList after clearing: \" + list);\n    }\n}","type":"content","url":"/doublylinkedlistjava#demo-code","position":17},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation of the Methods Used:","lvl2":"Demo Code"},"type":"lvl3","url":"/doublylinkedlistjava#explanation-of-the-methods-used","position":18},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation of the Methods Used:","lvl2":"Demo Code"},"content":"add(element) - Adds an element to the end of the list.\n\naddFirst(element) - Adds an element at the beginning of the list.\n\naddLast(element) - Adds an element at the end of the list.\n\nget(index) - Returns the element at the specified position.\n\ngetFirst() / getLast() - Returns the first or last element, respectively.\n\nsize() - Returns the number of elements in the list.\n\nremove(index) - Removes the element at the specified position.\n\nremoveFirst() / removeLast() - Removes the first or last element, respectively.\n\ncontains(element) - Checks if the list contains the specified element.\n\nclear() - Removes all the elements from the list.","type":"content","url":"/doublylinkedlistjava#explanation-of-the-methods-used","position":19},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"LinkedList Iterator"},"type":"lvl2","url":"/doublylinkedlistjava#linkedlist-iterator","position":20},{"hierarchy":{"lvl1":"Java Linked List Class","lvl2":"LinkedList Iterator"},"content":"The LinkedList Iterator in Java is an object that allows you to traverse the elements of a LinkedList sequentially. The Iterator is part of the Java Collections Framework and provides methods to iterate through the list, remove elements during iteration, and check for more elements.","type":"content","url":"/doublylinkedlistjava#linkedlist-iterator","position":21},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Key Methods of the Iterator:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/doublylinkedlistjava#key-methods-of-the-iterator","position":22},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Key Methods of the Iterator:","lvl2":"LinkedList Iterator"},"content":"hasNext(): Returns true if there are more elements to iterate.\n\nnext(): Returns the next element in the iteration.\n\nremove(): Removes the last element returned by the iterator (optional operation).","type":"content","url":"/doublylinkedlistjava#key-methods-of-the-iterator","position":23},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Example Code Using Iterator with LinkedList:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/doublylinkedlistjava#example-code-using-iterator-with-linkedlist","position":24},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Example Code Using Iterator with LinkedList:","lvl2":"LinkedList Iterator"},"content":"Here’s a sample Java program that demonstrates how to use the Iterator to traverse a LinkedList:import java.util.LinkedList;\nimport java.util.Iterator;\n\npublic class LinkedListIteratorDemo {\n    public static void main(String[] args) {\n        // Create a LinkedList\n        LinkedList<String> list = new LinkedList<>();\n        list.add(\"Apple\");\n        list.add(\"Banana\");\n        list.add(\"Cherry\");\n        list.add(\"Mango\");\n\n        // Get the iterator from the LinkedList\n        Iterator<String> iterator = list.iterator();\n\n        // Iterate through the LinkedList\n        System.out.println(\"Traversing the LinkedList:\");\n        while (iterator.hasNext()) {\n            String element = iterator.next();\n            System.out.println(element);\n            \n            // Remove \"Banana\" during iteration\n            if (element.equals(\"Banana\")) {\n                iterator.remove();\n                System.out.println(\"\\\"Banana\\\" has been removed\");\n            }\n        }\n\n        // Display the LinkedList after iteration\n        System.out.println(\"\\nLinkedList after iteration: \" + list);\n    }\n}","type":"content","url":"/doublylinkedlistjava#example-code-using-iterator-with-linkedlist","position":25},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Output:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/doublylinkedlistjava#output","position":26},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Output:","lvl2":"LinkedList Iterator"},"content":"Traversing the LinkedList:\nApple\nBanana\n\"Banana\" has been removed\nCherry\nMango\n\nLinkedList after iteration: [Apple, Cherry, Mango]","type":"content","url":"/doublylinkedlistjava#output","position":27},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation:","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/doublylinkedlistjava#explanation","position":28},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Explanation:","lvl2":"LinkedList Iterator"},"content":"Create a LinkedList:\n\nWe create a LinkedList of strings and add elements to it.\n\nGet an iterator:\n\nThe iterator() method of LinkedList is used to obtain an Iterator for the list.\n\nUse the iterator to traverse:\n\nWe loop through the list using hasNext() and next(), which ensure that each element is processed one by one.\n\nRemove an element during iteration:\n\nThe remove() method removes the last element returned by the iterator.\n\nIn this case, if the current element is \"Banana\", it is removed from the list.","type":"content","url":"/doublylinkedlistjava#explanation","position":29},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Why Use an Iterator with LinkedList?","lvl2":"LinkedList Iterator"},"type":"lvl3","url":"/doublylinkedlistjava#why-use-an-iterator-with-linkedlist","position":30},{"hierarchy":{"lvl1":"Java Linked List Class","lvl3":"Why Use an Iterator with LinkedList?","lvl2":"LinkedList Iterator"},"content":"Efficient Traversal: Iterators are efficient for traversing and manipulating lists because they maintain the state of traversal.\n\nModification During Traversal: Unlike using a for loop or enhanced for loop, an Iterator allows safe removal of elements during traversal, avoiding ConcurrentModificationException.\n\nThe iterator is a flexible and powerful way to navigate through and manipulate LinkedList elements in Java.","type":"content","url":"/doublylinkedlistjava#why-use-an-iterator-with-linkedlist","position":31},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List"},"type":"lvl1","url":"/doublylinkedlistreaddataintoll","position":0},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List"},"content":"","type":"content","url":"/doublylinkedlistreaddataintoll","position":1},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List","lvl2":"Lecture Code"},"type":"lvl2","url":"/doublylinkedlistreaddataintoll#lecture-code","position":2},{"hierarchy":{"lvl1":"Reading Datafile Into Linked List","lvl2":"Lecture Code"},"content":"/*\nProgrammer: James Goudy\nProject: Reading a csv file into a linked list\n */\n\n\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nclass Link {\n\n    Link first = null;\n    Link last = null;\n\n    // data\n    String id = null;\n    String firstname;\n    String lastname;\n    String pet;\n    \n\n    // link navigation\n    Link next = null;\n    Link prev = null;\n\n    // constructor\n    public Link(String id, String firstname, String lastname, String pet) {\n        this.id = id;\n        this.firstname = firstname;\n        this.lastname = lastname;\n        this.pet = pet;\n    }\n\n\n    public void displayNode() {\n        System.out.println(\"{\"+ firstname + \" \" + lastname + \" \"\n                            +pet+ \" \" + id +\" } \" );\n    }\n} // end of link\n\n\n\n\nclass Doubly {\n\n    Link first = null;\n    Link last = null;\n\n    // constructor\n    public Doubly() {\n\n        first = null;\n        last = null;\n    }\n\n    // add link at the beginning of the list\n    public boolean addFirst(String id,String firstname, \n            String lastname, String pet) {\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.next = first;\n            first.prev = newLink;\n            first = newLink;\n        }\n\n        return true;\n    }\n\n    // add link to the end of the list\n    public boolean addLast(String id,String firstname, \n            String lastname, String pet) {\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.prev = last;\n            last.next = newLink;\n            last = newLink;\n        }\n\n        return true;\n    }\n\n    public boolean findId(String searchID) {\n\n        if (first == null) {\n\n            // if list is empty\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchID)) {\n                    return true;\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    }\n\n    public boolean insertAfter(String searchId, String id,String firstname, \n            String lastname, String pet) {\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchId)) {\n\n                    // check if last link\n                    if (current.next == null) {\n                        // check if last link\n                        current.next = newLink;\n                        newLink.prev = current;\n\n                        last = newLink;\n\n                    } else {\n                        newLink.next = current.next;\n                        newLink.prev = current;\n\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n\n    }\n\n    public boolean insertBefore(String searchId, String id,String firstname, \n            String lastname, String pet) {\n\n        Link newLink = new Link( id,firstname,  lastname,  pet);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchId)) {\n\n                    // check for first link\n                    if (current.prev == null) {\n                        // check if last link\n                        current.prev = newLink;\n                        newLink.next = current;\n\n                        first = newLink;\n\n                    } else {\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n    }\n\n    public boolean deleteId(String searchID) {\n\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.id.equals(searchID)) {\n\n                    if (current.prev == null) {\n                        // first node\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true;\n                    } else if (current.next == null) {\n                        // last node\n                        current.prev.next = null;\n                        last = current;\n                        current = null;\n                        return true;\n                    } else {\n                        // a center node\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n\n                        return true;\n                    }\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    } //end of function\n\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode();\n            current = current.next;\n        }\n        System.out.println(\"\");\n\n    }\n}\n\npublic class DS_ReadDataIntoLinkedList {\n\n    static Doubly dl = new Doubly();\n\n    public static void idSearch(String searchId) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.findId(searchId)) {\n            System.out.println(\"\\n\" + searchId + \" is in list\");\n        } else {\n            System.out.println(\"\\n\" + searchId + \" not found\");\n        }\n\n    }\n\n    public static void deleteID(String searchId) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.deleteId(searchId)) {\n            System.out.println(searchId + \" was deleted\");\n        } else {\n            System.out.println(searchId + \" was NOT deleted\");\n        }\n\n    }\n    \n    \n    public static boolean addData(String filePath)\n    {\n        BufferedReader br;\n        FileReader fr;\n        String inputLine;\n        \n        try {\n            // create buffered reader\n            br = new BufferedReader(new FileReader(filePath));\n            \n            // skip the header line\n            br.readLine();\n            \n            while((inputLine = br.readLine()) != null)\n            {\n                String[] inputArray = inputLine.split(\",\");\n                dl.addLast(inputArray[0],\n                           inputArray[1],\n                           inputArray[2],\n                           inputArray[3]);\n            \n            }\n            \n            br.close();\n            \n        } catch (FileNotFoundException ex) {\n            System.out.println(ex.getMessage());\n            return false;\n        }catch (Exception e)\n        {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        \n        \n        return true;\n    }\n    \n\n    public static void main(String[] args) {\n\n        String searchID = \"\";\n        String insertCity = \"\";\n        \n        String filePath = \"c:\\\\z\\\\peoplePets.csv\";\n\n        addData(filePath);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchID = \"10\";\n        idSearch(searchID);\n\n        searchID = \"AAA\";\n        idSearch(searchID);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchID = \"10\";\n        deleteID(searchID);\n\n        searchID = \"AA\";\n        deleteID(searchID);\n\n\n        System.out.println(\"\\n----- Insert Examples------\\n\");\n\n        searchID = \"140\";\n        dl.insertAfter(searchID, \"1440\",\"Duke\",\"Ellington\", \"Phoenix\");\n\n\n        searchID = \"145\";\n        dl.insertBefore(searchID, \"1455\",\"John\",\"Coletrane\", \"Hydra\");\n\n\n        dl.displayList();\n\n        System.out.println(\"\\nbye\");\n    }\n}\n\n/* peoplePet.csv\n\nid,firstname,lastname,pet\n1,Wini,Gwinnett,Crowned hawk-eagle\n2,Birgit,Tabb,Silver gull\n3,Alfonso,Moyle,Ring-tailed possum\n4,Ode,Buckwell,Leopard\n5,Francene,Zanazzi,Wambenger\n6,Willie,Hakking,Butterfly\n7,Carlie,Pizey,Northern fur seal\n8,Cobby,Chittock,Great white pelican\n9,Ingamar,Cardenoza,Puma\n10,Brady,Vowles,Red meerkat\n11,Nonna,Betser,Lesser mouse lemur\n12,Antonina,Dovey,Insect\n13,Erastus,Crackett,Cow\n14,Lucien,Cardenosa,Yellow baboon\n15,Leon,Storm,Blue catfish\n16,Reinaldos,Welberry,Common grenadier\n17,Cherice,Coleson,Shrike\n18,Elyn,Antill,Echidna\n19,Dicky,Guppie,Puna ibis\n20,Erasmus,Pauncefort,White-necked stork\n21,Stewart,Pettifer,Starling\n22,Brand,Tytcomb,Raccoon\n23,Edwina,Cosens,Radiated tortoise\n24,Martelle,Barkus,Cormorant\n25,Blithe,Prevett,Kafue flats lechwe\n26,Abbie,Ferber,Common wombat\n27,Antonin,Sayes,Small-clawed otter\n28,Vaughan,Barzen,Hawk-eagle\n29,Elwira,Braemer,Monkey\n30,Sibelle,Vennings,Javanese cormorant\n31,Mavra,Bulter,Lemur\n32,Darrelle,Sanford,Beisa oryx\n33,Rodney,Whapples,Gull\n34,Horace,Gerwood,Tropical buckeye butterfly\n35,Garvin,Pestell,Bleu\n36,Lauralee,Crowdace,Dama wallaby\n37,Farica,Juara,Penguin\n38,Bucky,Taylo,Crab\n39,Carlynne,Pleasaunce,Common genet\n40,Dana,Percy,White-throated kingfisher\n41,Esma,McKerley,Southern ground hornbill\n42,Hube,Grills,Flamingo\n43,Hersch,Schneidau,Kangaroo\n44,Hildy,Matfin,Gull\n45,Lelia,Donaghy,American marten\n46,Eric,Tydd,Bahama pintail\n47,Clim,Tetsall,Spur-winged goose\n48,Berke,Brotherwood,Little cormorant\n49,Steve,Bride,Turtle\n50,Christiane,Stoppe,Fox\n51,Riley,Badgers,Swallow\n52,Leonidas,Pughsley,Roseate cockatoo\n53,Richard,Baudon,White-browed owl\n54,Marline,Tousey,Indian mynah\n55,Margarita,Breche,Phalarope\n56,Gerek,Aspinwall,Great horned owl\n57,Mabelle,Aronin,Grouse\n58,Curtice,Provost,Indian mynah\n59,Nikolaos,Cass,Desert tortoise\n60,Edmund,Pogosian,Grenadier\n61,Cindi,Vell,Catfish\n62,Davis,Roberts,Three-banded plover\n63,Clayborne,Jennrich,Roe deer\n64,Malory,Iwanicki,Snowy owl\n65,Toddy,Vannuchi,Arboral spiny rat\n66,Terri,Dudson,Malachite kingfisher\n67,Gabriel,Prine,Possum\n68,Jeannine,Westwick,Gecko\n69,Conney,Mattke,Stork\n70,Eulalie,Wapplington,Flamingo\n71,Darrick,Porcas,Rat\n72,Matty,Marchment,Deer\n73,Fedora,Semper,Nighthawk\n74,Barnebas,Wychard,Flying fox\n75,Edmund,Whitton,Squirrel\n76,Oliver,Dragoe,Parrot\n77,Carly,Royden,Lourie\n78,Cairistiona,Brothwell,Chestnut weaver\n79,Barnabas,Eastby,Lion\n80,Clementina,McCoish,European stork\n81,Rupert,Goosnell,Boa\n82,Jerrylee,Keir,Lizard\n83,Cariotta,Strettell,Little blue penguin\n84,Onida,Wysome,White-rumped vulture\n85,Reggis,Thursby,Cape wild cat\n86,Sharleen,Yele,Gazer\n87,Obadias,Rosedale,Vine snake\n88,Jodie,Harmond,Boat-billed heron\n89,Jonie,Goodricke,Brush-tailed phascogale\n90,Carissa,Clorley,Elk\n91,Jacki,Belhome,Northern elephant seal\n92,Virgina,Jarrette,House sparrow\n93,Hasheem,Cordeiro,Oystercatcher\n94,Roseann,Hussy,Fairy penguin\n95,Emmeline,Saurat,Bee-eater\n96,Ashlin,Ollerhead,Grey lourie\n97,Frannie,Sailes,Jungle kangaroo\n98,Shelden,Imason,Woodpecker\n99,Nicole,Cattle,Starling\n100,Bennie,Selliman,Ant\n101,Monroe,Sturzaker,Wild turkey\n102,Lou,Drew-Clifton,Ferruginous hawk\n103,Gerladina,Broadbere,Yellow-billed stork\n104,Laney,Scartifield,Common zebra\n105,Rolfe,Dressel,Cape Barren goose\n106,Clarita,Zylbermann,Red-legged pademelon\n107,Ev,Buckston,Kite\n108,Vidovic,Lawson,Buffalo\n109,Daloris,Grzesiak,Southern brown bandicoot\n110,Pier,Sproson,Brocket\n111,Edwina,Barlace,Giant girdled lizard\n112,Elvin,Birchwood,Deer\n113,Jedediah,Lazonby,Wallaby\n114,Ambur,Lochead,Gila monster\n115,Mirabella,Ferron,Possum\n116,Dougy,Gianinotti,Openbill\n117,Cher,Sivill,Dog\n118,Durante,Wissby,Genet\n119,Rora,Shord,Dove\n120,Dame,Jennison,Red-billed toucan\n121,Ira,Karolowski,Eurasian red squirrel\n122,Juliet,Hobson,Greylag goose\n123,Natale,Tattersdill,Starling\n124,Caitlin,Leggett,Ring-necked pheasant\n125,Hamnet,Danelut,South African hedgehog\n126,Christye,Stores,Porcupine\n127,Vince,Paolo,Kangaroo\n128,Cristy,Fesby,Starling\n129,Britney,Standfield,Burrowing owl\n130,Kaleena,Volkers,Langur\n131,Averil,Kimbell,Rhea\n132,Carmelita,Gehrels,Spotted-tailed quoll\n133,Cory,Sreenan,Hyrax\n134,Sybille,Filippone,Dove\n135,Delia,Forkan,Agama lizard\n136,Sigfried,Cattlemull,Eastern dwarf mongoose\n137,Rowena,James,Fox\n138,Shane,Naisey,Jaguarundi\n139,Janine,Ielden,Eastern fox squirrel\n140,Beverlie,Biggerstaff,Fox\n141,Menard,Archbould,Roe deer\n142,Darline,Keating,Caribou\n143,Heall,Chritchley,Beaver\n144,Corenda,Bunnell,Glossy starling\n145,Town,Mandal,White-winged tern\n146,Pietrek,Primmer,Superb starling\n147,Guillemette,Jasper,Gemsbok\n148,Diane,Mewes,Civet\n149,Hatty,Liddle,Grouse\n150,Ange,Beardwell,Deer\n\n */\n\nEnd Of Topic","type":"content","url":"/doublylinkedlistreaddataintoll#lecture-code","position":3},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class"},"type":"lvl1","url":"/doublylinkedlistsubclass","position":0},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class"},"content":"","type":"content","url":"/doublylinkedlistsubclass","position":1},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Key Ideas"},"type":"lvl2","url":"/doublylinkedlistsubclass#key-ideas","position":2},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Key Ideas"},"content":"The doubly linked list allows the list to be traversed in both directions; forwards and backwards\n\nNote\n\nNot all languages support subclasses.","type":"content","url":"/doublylinkedlistsubclass#key-ideas","position":3},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Lecture Code"},"type":"lvl2","url":"/doublylinkedlistsubclass#lecture-code","position":4},{"hierarchy":{"lvl1":"Doubly Linked List - Links as Sub Class","lvl2":"Lecture Code"},"content":"/*\n * Programmer: James Goudy\n * Project: Doubly Linked List written\n * with  Links / Nodes as SubClass\n */\n\nclass Doubly {\n\n    Link first = null;\n    Link last = null;\n\n    // ---------------------------------\n    // sub class - Link / Nodes\n    // NOTE: this can be a separate class as well\n    \n    class Link {\n\n        Link first = null;\n        Link last = null;\n\n        // data\n        String city = null;\n\n        // link navigation\n        Link next = null;\n        Link prev = null;\n\n        // constructor\n        Link(String city) {\n            this.city = city;\n            this.next = null;\n            this.prev = null;\n        }\n\n        public void displayNode() {\n            System.out.print(city + \" \");\n        }\n    } // end of link\n    // ---------------------------------\n\n    // constructor\n    public Doubly() {\n\n        first = null;\n        last = null;\n    }\n\n    // add link at the beginning of the list\n    public boolean addFirst(String city) {\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.next = first;\n            first.prev = newLink;\n            first = newLink;\n        }\n\n        return true;\n    }\n\n    // add link to the end of the list\n    public boolean addLast(String city) {\n\n        Link newLink = new Link(city);\n\n        if (first == null) {\n            // if list is empty\n            first = newLink;\n            last = newLink;\n        } else {\n            newLink.prev = last;\n            last.next = newLink;\n            last = newLink;\n        }\n\n        return true;\n    }\n\n    public boolean findCity(String citySearch) {\n\n        if (first == null) {\n\n            // if list is empty\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n                    return true;\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    }\n\n    public boolean insertAfter(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n            \n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check if last link\n                    if (current.next == null) {\n                        // check if last link\n                        current.next = newLink;\n                        newLink.prev = current;\n\n                        last = newLink;\n\n                    } else {\n                        newLink.next = current.next;\n                        newLink.prev = current;\n\n                        current.next.prev = newLink;\n                        current.next = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n\n    }\n\n    public boolean insertBefore(String citySearch, String insertCity) {\n\n        Link newLink = new Link(insertCity);\n\n        if (first == null) {\n\n            // list is empty - add the link\n            first = newLink;\n            last = newLink;\n\n            // NOTE: there is an option not to insert\n            // a link then the code above would be replaced\n            // with return false\n            \n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    // check for first link\n                    if (current.prev == null) {\n                        // check if last link\n                        current.prev = newLink;\n                        newLink.next = current;\n\n                        first = newLink;\n\n                    } else {\n                        newLink.next = current;\n                        newLink.prev = current.prev;\n\n                        current.prev.next = newLink;\n                        current.prev = newLink;\n                    }\n\n                    return true;\n                }\n                current = current.next;\n\n            }\n        }\n\n        return false;\n    }\n\n    public boolean deleteCity(String citySearch) {\n\n        if (first == null) {\n            return false;\n        } else {\n            Link current = first;\n\n            while (current != null) {\n                if (current.city.equals(citySearch)) {\n\n                    if (current.prev == null) {\n                        // first node\n                        current.next.prev = null;\n                        first = current.next;\n                        current = null;\n                        return true;\n                    } else if (current.next == null) {\n                        // last node\n                        current.prev.next = null;\n                        last = current;\n                        current = null;\n                        return true;\n                    } else {\n                        // a center node\n                        current.prev.next = current.next;\n                        current.next.prev = current.prev;\n                        current = null;\n\n                        return true;\n                    }\n                }\n                current = current.next;\n            }\n\n            return false;\n        }\n    } //end of function\n\n    public void displayList() {\n        Link current = first;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode();\n            current = current.next;\n        }\n        System.out.println(\"\");\n    }\n        \n    public void displayListBackwards() {\n        Link current = last;\n\n        System.out.println(\"\");\n        while (current != null) {\n            current.displayNode();\n            current = current.prev;\n        }\n        System.out.println(\"\");\n    }\n    \n}\n\npublic class J2_SubClass {\n\n    static Doubly dl = new Doubly();\n\n    public static void citySearch(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.findCity(searchCity)) {\n            System.out.println(\"\\n\" + searchCity + \" is in list\");\n        } else {\n            System.out.println(\"\\n\" + searchCity + \" not found\");\n        }\n\n    }\n\n    public static void deleteCity(String searchCity) {\n\n        // note that findCity returns a boolean\n        // so it can be used in an \"if\" statement\n        if (dl.deleteCity(searchCity)) {\n            System.out.println(searchCity + \" was deleted\");\n        } else {\n            System.out.println(searchCity + \" was NOT deleted\");\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n        String searchCity = \"\";\n        String insertCity = \"\";\n\n        // insert data at front of list\n        dl.addFirst(\"Kali\");\n        dl.addFirst(\"Polson\");\n        dl.addFirst(\"Missoula\");\n        dl.addFirst(\"Whitefish\");\n\n        // insert data at end of list\n        dl.addLast(\"Chicago\");\n        dl.addLast(\"Denver\");\n        dl.addLast(\"Sandiego\");\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Find Examples------\\n\");\n\n        searchCity = \"Chicago\";\n        citySearch(searchCity);\n\n        searchCity = \"Bozeman\";\n        citySearch(searchCity);\n\n        System.out.println(\"\\n----- Delete Examples------\\n\");\n\n        searchCity = \"Polson\";\n        deleteCity(searchCity);\n\n        searchCity = \"Bozeman\";\n        deleteCity(searchCity);\n\n        searchCity = \"Sandiego\";\n        deleteCity(searchCity);\n\n        searchCity = \"Whitefish\";\n        deleteCity(searchCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\n----- Insert Examples------\\n\");\n\n        searchCity = \"Missoula\";\n        insertCity = \"Dayton\";\n        dl.insertAfter(searchCity, insertCity);\n\n        searchCity = \"Denver\";\n        insertCity = \"Boulder\";\n        dl.insertAfter(searchCity, insertCity);\n\n        dl.displayList();\n\n        searchCity = \"Chicago\";\n        insertCity = \"Springfield\";\n        dl.insertBefore(searchCity, insertCity);\n\n        searchCity = \"Missoula\";\n        insertCity = \"Libby\";\n        dl.insertBefore(searchCity, insertCity);\n\n        dl.displayList();\n\n        System.out.println(\"\\nbye\");\n    }\n}\n\n/*\n OUTPUT \n \n Whitefish Missoula Polson Kali Chicago Denver Sandiego \n\n----- Find Examples------\n\n\nChicago is in list\n\nBozeman not found\n\n----- Delete Examples------\n\nPolson was deleted\nBozeman was NOT deleted\nSandiego was deleted\nWhitefish was deleted\n\nMissoula Kali Chicago Denver \n\n----- Insert Examples------\n\n\nMissoula Dayton Kali Chicago Denver Boulder \n\nLibby Missoula Dayton Kali Springfield Chicago Denver Boulder \n\nbye\n \n */\n\nEnd Of Topic","type":"content","url":"/doublylinkedlistsubclass#lecture-code","position":5},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation"},"type":"lvl1","url":"/encapsulationnonencapsulation","position":0},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation"},"content":"This program is a Java demonstration designed to illustrate the core Object-Oriented Programming (OOP) concept of Encapsulation using the contrast between private and public access modifiers. It primarily shows how data hiding and controlled access are used to maintain an object’s integrity.","type":"content","url":"/encapsulationnonencapsulation","position":1},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Encapsulated Person Class (Good Practice)"},"type":"lvl2","url":"/encapsulationnonencapsulation#the-encapsulated-person-class-good-practice","position":2},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Encapsulated Person Class (Good Practice)"},"content":"The Person class exemplifies proper encapsulation, also known as data hiding.\n\nPrivate Data Fields: The class’s data (firstName and lastName) are declared as private. This prevents any code outside the class from directly reading or modifying them, effectively protecting the data.\n\nPublic Accessors (Getters and Setters): The class provides public methods—getters (like getFirstName()) for safely reading the data, and setters (like setFirstName()) for safely writing the data.\n\nControlled Integrity: The key benefit is that the setFirstName() method includes validation logic. If an external caller attempts to set a first name that is null or shorter than two characters, the setter detects the invalid input, prints an error message, and prevents the private field from being changed. This ensures the Person object remains in a valid, consistent state.","type":"content","url":"/encapsulationnonencapsulation#the-encapsulated-person-class-good-practice","position":3},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Non-Encapsulated Dog Class (Risky Practice)"},"type":"lvl2","url":"/encapsulationnonencapsulation#the-non-encapsulated-dog-class-risky-practice","position":4},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The Non-Encapsulated Dog Class (Risky Practice)"},"content":"The Dog class demonstrates the pitfalls of breaking encapsulation by using public fields.\n\nPublic Data Fields: The class’s data (dogName and dogBreed) are declared as public. Any external code can directly access and modify these variables without any mediation.\n\nNo Control or Validation: Because external code bypasses any methods to change the data, the Dog class has no opportunity to validate the new values. As demonstrated in the main method, an external caller can directly set the dogName to a potentially disastrous value like null. This makes the object’s internal state vulnerable and potentially invalid, and the class cannot prevent it.","type":"content","url":"/encapsulationnonencapsulation#the-non-encapsulated-dog-class-risky-practice","position":5},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The main Demonstration"},"type":"lvl2","url":"/encapsulationnonencapsulation#the-main-demonstration","position":6},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"The main Demonstration"},"content":"The main method creates instances of both classes to showcase the difference:\n\nIt attempts to set an invalid, short first name (“S”) on the encapsulated Person object. The setter rejects the change, and the object’s name remains the previous valid value (“Jane Doe”).\n\nIt directly sets an invalid, null name on the non-encapsulated Dog object. The public field is directly overwritten, allowing the object to enter an inconsistent, invalid state (“null Mutt”), demonstrating the lack of control.","type":"content","url":"/encapsulationnonencapsulation#the-main-demonstration","position":7},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"Demo Code"},"type":"lvl2","url":"/encapsulationnonencapsulation#demo-code","position":8},{"hierarchy":{"lvl1":"Encapsulation vs Non-Encapsulation","lvl2":"Demo Code"},"content":"/*\n * Developer: James Goudy\n *\n * This file demonstrates the key Object-Oriented Programming (OOP)\n * concept of ENCAPSULATION using access modifiers (private vs. public).\n */\npackage classpublicprivateelements;\n\n// The Person class demonstrates ENCAPSULATION (Data Hiding)\nclass Person {\n\n    // 1. Data Hiding: The fields are private, protecting them from\n    // direct external modification. This forces users to go through\n    // our controlled public interface.\n    private String firstName;\n    private String lastName;\n\n    public Person() {\n    }\n    \n    public Person(String firstName, String lastName) {\n        // Use setters in the constructor to ensure validation runs!\n        setFirstName(firstName);\n        setLastName(lastName);\n    }\n\n    // Getters: Public methods to safely READ the private data.\n    public String getFirstName() {\n        return firstName;\n    }\n\n    // 2. Controlled Access (Setters): Public methods to safely WRITE \n    // the private data. Setters give you the opportunity to VALIDATE\n    // data and maintain the object's integrity. If the input is \n    // invalid, the field is not changed.\n    public void setFirstName(String firstName) {\n        // ENHANCEMENT: Simple validation logic\n        if (firstName != null && firstName.length() >= 2) {\n            this.firstName = firstName;\n        } else {\n            // Note: In real production code, you might throw an\n            // IllegalArgumentException.\n            System.out.println(\"Error: First name '\" + firstName + \n                               \"' is invalid. Value ignored.\");\n        }\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public void setLastName(String lastName) {\n        \n        // The same checks as setFirstName could also be applied here.\n        this.lastName = lastName; \n    }\n    \n    public String allInfo() {\n        return (this.firstName + \" \" + this.lastName);\n    }\n}\n\n// The Dog class demonstrates the dangers of PUBLIC ACCESS\nclass Dog {\n\n    // 1. Public Fields: The elements are PUBLIC - they can be accessed \n    // and changed directly by any external code. This breaks \n    // encapsulation.\n    public String dogName;\n    public String dogBreed;\n\n    // THERE IS NO OPPORTUNITY TO VALIDATE! A user can set these fields\n    // to any value (like null or an empty string), potentially making\n    // the object's state INVALID without the class having any control.\n    \n    public Dog() {\n    }\n\n    public Dog(String dogName, String dogBreed) {\n        // If we wanted validation here, we would have to duplicate the\n        // logic in every constructor, instead of just using a Setter.\n        this.dogName = dogName;\n        this.dogBreed = dogBreed;\n    }\n    \n    public String allInfo() {\n        return (this.dogName + \" \" + this.dogBreed);\n    }\n}\n\npublic class ClassPublicPrivateElements {\n\n    public static void main(String[] args) {\n        \n        // --- Demonstration of Encapsulation (Person) ---\n        Person p1 = new Person();\n        \n        // Use the public interface (Setters) to change the private fields.\n        p1.setFirstName(\"Jane\");\n        p1.setLastName(\"Doe\");\n        System.out.println(\"Person 1 (Initial Set): \" + p1.allInfo());\n        \n        // Attempting to set an invalid value - The Setter PROTECTS the data!\n        System.out.println(\"\\nAttempting to set an INVALID first name ('S'):\");\n        p1.setFirstName(\"S\"); \n        \n        // The field remains unchanged because of the validation in the setter.\n        System.out.println(\"Person 1 (After Invalid Set): \" + p1.allInfo()); \n        \n        // --- Demonstration of Public Access (Dog) ---\n        \n        Dog dog = new Dog();\n        \n        // Directly setting the public elements - NO validation possible.\n        dog.dogName = \"Fido\";\n        dog.dogBreed = \"Mutt\";\n        System.out.println(\"\\nDog (Initial Set): \" + dog.allInfo());\n        \n        // Directly setting an invalid value - The public field is VULNERABLE!\n        System.out.println(\"Directly setting an INVALID name (null):\");\n        \n        // This is legal but potentially disastrous!\n        dog.dogName = null; \n        \n        // The object's state is now inconsistent, and the Dog class \n        // could not prevent it.\n        System.out.println(\"Dog (After Invalid Set): \" + dog.allInfo()); \n    }\n}\n\n10/2025","type":"content","url":"/encapsulationnonencapsulation#demo-code","position":9},{"hierarchy":{"lvl1":"Linked Lists"},"type":"lvl1","url":"/linkedlists","position":0},{"hierarchy":{"lvl1":"Linked Lists"},"content":"Definition\n\nLinked List is a set of nodes where each node contains a data field(s) and a reference(link) to the next node in the list.","type":"content","url":"/linkedlists","position":1},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Benefits of a linked list"},"type":"lvl2","url":"/linkedlists#benefits-of-a-linked-list","position":2},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Benefits of a linked list"},"content":"Not limited to a specific data space amount.\n\nEasy to add and delete data","type":"content","url":"/linkedlists#benefits-of-a-linked-list","position":3},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Disadvantages of a linked list"},"type":"lvl2","url":"/linkedlists#disadvantages-of-a-linked-list","position":4},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Disadvantages of a linked list"},"content":"The retrieval time of stored data is dependent on the size of the list and the position/node of the data in the list. O(n)","type":"content","url":"/linkedlists#disadvantages-of-a-linked-list","position":5},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Types of linked lists"},"type":"lvl2","url":"/linkedlists#types-of-linked-lists","position":6},{"hierarchy":{"lvl1":"Linked Lists","lvl2":"Types of linked lists"},"content":"Singly linked lists\n\nDoubly linked lists\n\nDoubly linked lists with links as sub class\n\nCircular linked lists\n\nEnd of Topic","type":"content","url":"/linkedlists#types-of-linked-lists","position":7},{"hierarchy":{"lvl1":"Merge Sort"},"type":"lvl1","url":"/mergesort","position":0},{"hierarchy":{"lvl1":"Merge Sort"},"content":"Here’s a summary of the pros and cons of merge sort presented in bullet points:\n\nPros of Merge Sort:\n\nEfficient for large datasets: Merge sort’s average and worst-case time complexities are O(n log n), making it highly efficient for sorting large datasets.\n\nStable sorting algorithm: Merge sort preserves the original order of equal elements, making it a stable sorting algorithm. This is particularly useful when sorting data that contains multiple instances of the same value.\n\nAdaptable to external sorting: Merge sort can be adapted for external sorting, where the data to be sorted is too large to fit into main memory.\n\nHighly parallelizable: Merge sort can be effectively parallelized, making it suitable for multithreaded and distributed computing environments.\n\nCons of Merge Sort:\n\nAdditional memory usage: Merge sort requires additional memory to store the temporary sublists created during the sorting process.\n\nOverhead for small datasets: For small datasets, the overhead of recursion and merging can make merge sort less efficient than simpler algorithms like insertion sort.\n\nNot in-place sorting: Merge sort is not an in-place sorting algorithm, meaning it requires additional memory to store the sorted result.\n\nOverall, merge sort is a versatile and efficient sorting algorithm that is particularly well-suited for large datasets. However, its additional memory requirements and overhead for small datasets make it less suitable for certain applications.","type":"content","url":"/mergesort","position":1},{"hierarchy":{"lvl1":"Merge Sort - Demo Code"},"type":"lvl1","url":"/mergesort-reva","position":0},{"hierarchy":{"lvl1":"Merge Sort - Demo Code"},"content":"","type":"content","url":"/mergesort-reva","position":1},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"How Merge Sort Works"},"type":"lvl3","url":"/mergesort-reva#how-merge-sort-works","position":2},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"How Merge Sort Works"},"content":"Merge sort is a divide-and-conquer sorting algorithm. It recursively divides the array into two halves until each subarray has only one element (which is trivially sorted). Then it merges these sorted halves back together, comparing elements and building a larger sorted array step by step. This merging process continues until the entire array is reassembled in sorted order.\n\nThe algorithm has a consistent time complexity of O(n log n) — it divides the array (log n times) and merges n elements at each level. Merge sort is stable and efficient but requires extra space proportional to the array size due to its temporary workspace array.","type":"content","url":"/mergesort-reva#how-merge-sort-works","position":3},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Arrays"},"type":"lvl2","url":"/mergesort-reva#arrays","position":4},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Arrays"},"content":"","type":"content","url":"/mergesort-reva#arrays","position":5},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Arrays"},"type":"lvl3","url":"/mergesort-reva#demo-code","position":6},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Arrays"},"content":"/*\nEngineer: James Goduy\n */\npackage mergesort_rev;\n\nimport java.util.Random;\n\n\n/*\n * The Sorter interface defines a contract that all sorting classes must follow.\n * Any class that implements Sorter must provide concrete versions of insert(),\n * sort(), and displayArray(). These are method signatures only—no code \n * is written here.\n *\n * Using an interface allows us to treat different sorting algorithms (e.g.,\n * recursive and iterative merge sorts) as the same \"type.\" This is an example\n * of polymorphism: we can write one block of code that works with any object\n * implementing Sorter, regardless of how it performs the sorting internally.\n *\n * In short, the interface provides a common structure (what must be done),\n * while each class defines its own behavior (how it is done).\n */\n\ninterface Sorter {\n    void insert(int value);\n    void sort();\n    void displayArray();\n}\n\n\nclass MergeSort implements Sorter {\n\n    private int[] theArray;  // Main array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum capacity of the array\n\n    // Constructor: initializes the array and tracking variables\n    public MergeSort(int max) {\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n    // Check if array is full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert a value into the array (if space allows)\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        theArray[nElems++] = value; // Place value and increment element count\n    }\n\n    // Public method to start the merge sort process\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary workspace for merging\n        recMergeSort(workspace, 0, nElems - 1); // Begin recursive sorting\n    }\n\n    // Recursive function that splits and sorts subarrays\n    private void recMergeSort(int[] workspace, int lowerBound, int upperBound) {\n        if (lowerBound >= upperBound) return; // Base case: one element\n\n        int mid = (lowerBound + upperBound) / 2; // Find midpoint\n\n        // Recursively sort left and right halves\n        recMergeSort(workspace, lowerBound, mid);\n        recMergeSort(workspace, mid + 1, upperBound);\n\n        // Merge the two sorted halves\n        merge(workspace, lowerBound, mid + 1, upperBound);\n    }\n\n    // Merge two sorted halves into a single sorted run\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                   // Index for workspace\n        int lowerBound = lowPtr;     // Start index of left half\n        int mid = highPtr - 1;       // End index of left half\n        int n = upperBound - lowerBound + 1; // Total elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr <= mid && highPtr <= upperBound) {\n            workspace[j++] = (theArray[lowPtr] <= theArray[highPtr])\n                    ? theArray[lowPtr++]\n                    : theArray[highPtr++];\n        }\n\n        // Copy any remaining elements from the left half\n        if (lowPtr <= mid) {\n            System.arraycopy(theArray, lowPtr, workspace, j, mid - lowPtr + 1);\n            j += (mid - lowPtr + 1);\n        }\n\n        // Copy any remaining elements from the right half\n        if (highPtr <= upperBound) {\n            System.arraycopy(theArray, highPtr, workspace, j, upperBound - highPtr + 1);\n        }\n\n        // Copy merged elements back into the original array\n        System.arraycopy(workspace, 0, theArray, lowerBound, n);\n    }\n\n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n} // End Of Class\n\nclass MergeSort_Iterative implements Sorter {\n\n    // Instance Variables\n    private int[] theArray;  // The array to be sorted\n    private int nElems;      // Current number of elements in the array\n    private int max;         // Maximum array capacity (limit)\n\n    // Constructor\n    public MergeSort_Iterative (int max) {\n        // Initialize the array and size counters\n        theArray = new int[max];\n        nElems = 0;\n        this.max = max;\n    }\n\n\n    // Utility Method\n    // Checks whether the array is already full\n    private boolean isFull() {\n        return nElems == max;\n    }\n\n    // Insert Method\n    // Adds a value to the array if space is available\n    public void insert(int value) {\n        if (isFull()) {\n            System.out.println(\"Array is full\");\n            return;\n        }\n        // Store value and increase the element count\n        theArray[nElems++] = value;\n    }\n\n\n    // Iterative Merge Sort\n    public void sort() {\n        int[] workspace = new int[nElems]; // Temporary array used during merging\n        \n        // subSize represents the size of subarrays being merged each pass\n        // Start with subarrays of size 1 and double the size each iteration\n        for (int subSize = 1; subSize < nElems; subSize *= 2) {\n            \n            // Process and merge all pairs of subarrays of the current subSize\n            for (int leftStart = 0; leftStart < nElems - subSize; leftStart += 2 * subSize) {\n                \n                // leftStart: beginning index of left subarray\n                int mid = leftStart + subSize - 1; // Last index of left subarray\n                \n                // Ensure the right subarray does not exceed array bounds\n                int rightEnd = Math.min(leftStart + 2 * subSize - 1, nElems - 1);\n                \n                // Merge the two adjacent sorted subarrays into one\n                merge(workspace, leftStart, mid + 1, rightEnd);\n            }\n        }\n    }\n\n\n    // Merge Method\n    // Merges two sorted halves into a single sorted section\n    private void merge(int[] workspace, int lowPtr, int highPtr, int upperBound) {\n        int j = 0;                    // Index for workspace array\n        int lowerBound = lowPtr;      // Start index of the left half\n        int mid = highPtr - 1;        // End index of the left half\n        int n = upperBound - lowerBound + 1; // Total number of elements to merge\n\n        // Compare elements from both halves and copy the smaller one first\n        while (lowPtr <= mid && highPtr <= upperBound) {\n            if (theArray[lowPtr] <= theArray[highPtr])\n                workspace[j++] = theArray[lowPtr++]; // Copy from left half\n            else\n                workspace[j++] = theArray[highPtr++]; // Copy from right half\n        }\n\n        // Copy any remaining elements from the left half\n        while (lowPtr <= mid) {\n            workspace[j++] = theArray[lowPtr++];\n        }\n\n        // Copy any remaining elements from the right half\n        while (highPtr <= upperBound) {\n            workspace[j++] = theArray[highPtr++];\n        }\n\n        // Copy merged elements back into the original array\n        for (int k = 0; k < n; k++) {\n            theArray[lowerBound + k] = workspace[k];\n        }\n    }\n    \n    // Utility method to display the array contents\n    public void displayArray() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nElems; i++) sb.append(theArray[i]).append(' ');\n        System.out.println(sb.toString());\n    }\n}\n\n\npublic class MergeSort_Rev {\n\n\n    public static void main(String[] args)\n    {\n        \n        int maxSize = 15    ;\n        int sampleSize =  (int)(maxSize * .9);\n        int choice = 2;\n        \n        Sorter ms;\n        \n        // create the object\n        if(choice == 1)\n        {\n            // recursive\n        \tms = new MergeSort(maxSize);\n        }\n        else\n        {\n            // iterative - loops\n            ms = new MergeSort_Iterative (maxSize);\n        }\n\n        // Create RNG\n        Random RNG = new Random();\n\n        // insert random numbers\n        for(int c = 0 ; c < sampleSize; c++)\n        {\n            ms.insert(RNG.nextInt(0,maxSize));\n        }\n      \n        // display the orignal array\n        ms.displayArray();\n\n        \n        // sort the list\n        ms.sort();\n        \n        // spacing\n        System.out.println();\n\n        // display the sorted list\n        ms.displayArray();\n\n        System.out.println(\"\\nbye\\n\");\n    }\n    \n}","type":"content","url":"/mergesort-reva#demo-code","position":7},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Linked Lists"},"type":"lvl2","url":"/mergesort-reva#linked-lists","position":8},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"Linked Lists"},"content":"","type":"content","url":"/mergesort-reva#linked-lists","position":9},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Linked Lists"},"type":"lvl3","url":"/mergesort-reva#demo-code-1","position":10},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Demo Code","lvl2":"Linked Lists"},"content":"/*\n * Example program demonstrating two implementations of Merge Sort\n * for a linked list of people (first name, last name, city).\n * \n * Both recursive (top-down) and iterative (bottom-up) versions\n * implement a common interface (Sorter) for interchangeable use.\n *\n * Author: [Your Name]\n * Course: [Your Class Name or Section]\n */\n\npackage mergesortlinkedlist;\n\n// ----------------------------------------------------------------------\n// Interface Definition\n// ----------------------------------------------------------------------\n\n/**\n * The Sorter interface defines a simple contract for\n * inserting, sorting, and displaying a collection.\n * \n * Both recursive and iterative merge sort classes\n * will implement this interface to ensure consistent usage.\n */\ninterface Sorter {\n    void insert(String fn, String ln, String cty);\n    void sort();\n    void displayList();\n}\n\n// ----------------------------------------------------------------------\n// Recursive Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Recursive\n * \n * Uses a recursive (top-down) merge sort approach.\n * The list is divided into halves until single nodes remain,\n * then merged back together in sorted order by last name.\n */\nclass MergeSortLinkedList_Recursive implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     * Each node stores a person's first name, last name, and city.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head;  // Head pointer for the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public sort method — initiates recursive merge sort.\n     */\n    public void sort() {\n        head = mergeSort(head);\n    }\n\n    /**\n     * Recursive merge sort: splits the list, sorts each half, and merges them.\n     */\n    private Node mergeSort(Node h) {\n        // Base case: 0 or 1 element\n        if (h == null || h.next == null) return h;\n\n        // Split the list into two halves\n        Node middle = getMiddle(h);\n        Node nextOfMiddle = middle.next;\n        middle.next = null; // Split into two sublists\n\n        // Recursively sort both halves\n        Node left = mergeSort(h);\n        Node right = mergeSort(nextOfMiddle);\n\n        // Merge the two sorted halves\n        return sortedMerge(left, right);\n    }\n\n    /**\n     * Merges two sorted linked lists into one (sorted by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        if (a == null) return b;\n        if (b == null) return a;\n\n        Node result;\n\n        // Compare by last name (case-insensitive)\n        if (a.lastName.compareToIgnoreCase(b.lastName) <= 0) {\n            result = a;\n            result.next = sortedMerge(a.next, b);\n        } else {\n            result = b;\n            result.next = sortedMerge(a, b.next);\n        }\n\n        return result;\n    }\n\n    /**\n     * Finds the middle node of a linked list using the fast/slow pointer method.\n     */\n    private Node getMiddle(Node h) {\n        if (h == null) return h;\n\n        Node slow = h, fast = h;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Iterative Merge Sort Implementation\n// ----------------------------------------------------------------------\n\n/**\n * MergeSortLinkedList_Iterative\n * \n * Uses an iterative (bottom-up) merge sort approach.\n * Starts by merging small sorted sublists of size 1, then doubles\n * the size of the sublists (1, 2, 4, 8...) until the full list is sorted.\n */\nclass MergeSortLinkedList_Iterative implements Sorter {\n\n    /**\n     * Inner class Node — represents a single record in the linked list.\n     */\n    class Node {\n        String firstName;\n        String lastName;\n        String city;\n        Node next;\n\n        Node(String firstName, String lastName, String city) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.city = city;\n            this.next = null;\n        }\n    }\n\n    private Node head; // Head of the linked list\n\n    /**\n     * Inserts a new node at the end of the list.\n     */\n    public void insert(String firstName, String lastName, String city) {\n        Node newNode = new Node(firstName, lastName, city);\n        if (head == null) {\n            head = newNode;\n            return;\n        }\n        Node current = head;\n        while (current.next != null)\n            current = current.next;\n        current.next = newNode;\n    }\n\n    /**\n     * Public method to start iterative merge sort.\n     */\n    public void sort() {\n        head = mergeSortIterative(head);\n    }\n\n    /**\n     * Iterative (loop-based) merge sort implementation.\n     * Uses sublist merging of increasing size to avoid recursion.\n     */\n    private Node mergeSortIterative(Node head) {\n        if (head == null || head.next == null) return head;\n\n        int n = getSize(head);\n\n        // Dummy node simplifies pointer management during merging\n        Node dummy = new Node(\"\", \"\", \"\");\n        dummy.next = head;\n\n        // Merge sublists of size 1, 2, 4, 8, etc.\n        for (int step = 1; step < n; step *= 2) {\n            Node prev = dummy;\n            Node current = dummy.next;\n\n            while (current != null) {\n                Node left = current;\n                Node right = split(left, step);\n                current = split(right, step);\n\n                Node merged = sortedMerge(left, right);\n                prev.next = merged;\n\n                // Move 'prev' to the end of the merged sublist\n                while (prev.next != null)\n                    prev = prev.next;\n            }\n        }\n\n        return dummy.next;\n    }\n\n    /**\n     * Splits the list after 'size' nodes and returns the next sublist.\n     */\n    private Node split(Node head, int size) {\n        if (head == null) return null;\n        for (int i = 1; head.next != null && i < size; i++)\n            head = head.next;\n\n        Node second = head.next;\n        head.next = null;\n        return second;\n    }\n\n    /**\n     * Merges two sorted linked lists (by last name).\n     */\n    private Node sortedMerge(Node a, Node b) {\n        Node dummy = new Node(\"\", \"\", \"\");\n        Node tail = dummy;\n\n        while (a != null && b != null) {\n            if (a.lastName.compareToIgnoreCase(b.lastName) <= 0) {\n                tail.next = a;\n                a = a.next;\n            } else {\n                tail.next = b;\n                b = b.next;\n            }\n            tail = tail.next;\n        }\n\n        tail.next = (a != null) ? a : b;\n        return dummy.next;\n    }\n\n    /**\n     * Counts the number of nodes in the list.\n     */\n    private int getSize(Node head) {\n        int count = 0;\n        while (head != null) {\n            count++;\n            head = head.next;\n        }\n        return count;\n    }\n\n    /**\n     * Displays the contents of the linked list.\n     */\n    public void displayList() {\n        Node current = head;\n        while (current != null) {\n            System.out.printf(\"%-10s %-10s %-10s%n\",\n                    current.firstName, current.lastName, current.city);\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\n// ----------------------------------------------------------------------\n// Driver Class\n// ----------------------------------------------------------------------\n\n/**\n * Main driver class.\n * \n * Demonstrates the use of both recursive and iterative\n * linked list merge sort implementations via the Sorter interface.\n */\npublic class MergeSortLinkedList {\n\n    public static void main(String[] args) {\n\n        Sorter list;\n\n        int choice = 1;  // 1 = Recursive, 2 = Iterative\n\n        if (choice == 1)\n            list = new MergeSortLinkedList_Recursive();\n        else\n            list = new MergeSortLinkedList_Iterative();\n\n        // Insert sample data\n        list.insert(\"Alice\", \"Zimmer\", \"Chicago\");\n        list.insert(\"Bob\", \"Anderson\", \"Kalispell\");\n        list.insert(\"Cathy\", \"Johnson\", \"Seattle\");\n        list.insert(\"Daniel\", \"Brown\", \"Denver\");\n\n        // Display before sorting\n        System.out.println(\"Before Sorting:\");\n        list.displayList();\n\n        // Sort and display results\n        list.sort();\n        System.out.println(\"After Sorting by Last Name:\");\n        list.displayList();\n    }\n}\n","type":"content","url":"/mergesort-reva#demo-code-1","position":11},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"When To Use"},"type":"lvl2","url":"/mergesort-reva#when-to-use","position":12},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl2":"When To Use"},"content":"","type":"content","url":"/mergesort-reva#when-to-use","position":13},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Quick summary","lvl2":"When To Use"},"type":"lvl3","url":"/mergesort-reva#quick-summary","position":14},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Quick summary","lvl2":"When To Use"},"content":"Both are O(n log n) time, stable, and O(1) extra space on the list (recursive adds O(log n) call-stack space).\n\nRecursive = simpler to read/teach; Iterative = no recursion, often better constants and safer for huge inputs.","type":"content","url":"/mergesort-reva#quick-summary","position":15},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl3","url":"/mergesort-reva#strengths-vs-weaknesses","position":16},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"","type":"content","url":"/mergesort-reva#strengths-vs-weaknesses","position":17},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Recursive (top-down)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/mergesort-reva#recursive-top-down","position":18},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Recursive (top-down)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"How it works: repeatedly split with fast/slow pointers (getMiddle), then merge.\n\nStrengths\n\nClarity & pedagogy: mirrors the textbook definition; very readable for students.\n\nNatural structure: the “divide → conquer → combine” flow matches the mental model of merge sort.\n\nEasy to parallelize: left and right halves can be sorted concurrently if you go multi-threaded later.\n\nStable by construction: merge step preserves order of equals.\n\nWeaknesses\n\nCall-stack use: O(log n) stack frames. Usually fine, but it’s still extra memory and can matter on very tight stacks or unusual environments.\n\nFunction-call overhead: many small recursive calls; minor but measurable on some JVMs.\n\nMiddle finding every level: each split uses fast/slow pointers; total cost stays O(n log n) but the constant factor isn’t free.","type":"content","url":"/mergesort-reva#recursive-top-down","position":19},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Iterative (bottom-up)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/mergesort-reva#iterative-bottom-up","position":20},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Iterative (bottom-up)","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"How it works: repeatedly merge runs of size 1, 2, 4, 8, … using loops; uses pointer “splicing” (split, merge) and a dummy head.\n\nStrengths\n\nNo recursion: avoids stack growth entirely; safer for very large lists or constrained runtimes.\n\nGood constants: one linear pass per run size; practical throughput often edges out recursive on linked lists.\n\nPredictable control flow: all in loops; easy to bound and instrument.\n\nStill stable: merge loop preserves order of equals.\n\nWeaknesses\n\nMore pointer surgery: more places to make off-by-one / null-next mistakes; trickier to get right first time.\n\nSlightly less intuitive to newcomers: bottom-up run doubling is less obvious than “split in half”.\n\nNeeds size or tail walking: typical pattern computes n up front or advances pointers carefully; again, more book-keeping.","type":"content","url":"/mergesort-reva#iterative-bottom-up","position":21},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Performance & resource notes","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/mergesort-reva#performance-resource-notes","position":22},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Performance & resource notes","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"Time complexity: both O(n log n) on singly linked lists.\n\nSpace: both in-place on nodes; recursive adds O(log n) call stack, iterative doesn’t.\n\nCache locality: neither is great (linked lists aren’t cache-friendly), but iterative’s fewer function calls can help a bit.\n\nStability: both remain stable as long as your merge uses <= (or equivalent) and never reorders equals.","type":"content","url":"/mergesort-reva#performance-resource-notes","position":23},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"When to pick which","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/mergesort-reva#when-to-pick-which","position":24},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"When to pick which","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"Teaching / readability / quick correctness: Recursive.\n\nProduction on huge lists / tight memory / maximum robustness: Iterative.\n\nParallel sort of very large lists: Recursive lends itself to parallelizing the two halves.","type":"content","url":"/mergesort-reva#when-to-pick-which","position":25},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Practical checklist","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"type":"lvl4","url":"/mergesort-reva#practical-checklist","position":26},{"hierarchy":{"lvl1":"Merge Sort - Demo Code","lvl4":"Practical checklist","lvl3":"Strengths vs. weaknesses","lvl2":"When To Use"},"content":"Need simple code? → Recursive.\n\nWorried about stack or sorting millions of nodes? → Iterative.","type":"content","url":"/mergesort-reva#practical-checklist","position":27},{"hierarchy":{"lvl1":"Visualizing Big O notation"},"type":"lvl1","url":"/on-visualizingbigonotation","position":0},{"hierarchy":{"lvl1":"Visualizing Big O notation"},"content":"From ‘’ mellowd co uk/ccie/?p=6122\"\n\nAuthor: Darren O’Connor\n\nI’m currently learning as much computer science as I can on the side. I’ve come across \n\nBig O notation a few times already, and while I understand it, I’m much more of a visual guy.\n\nIt’s rather easy to use Python and matplotlib to graph out how a function’s execution time grows as the size of the input grows. The important thing to note is not total execution time, but rather how the runtime of that function grows in relation to the input size. This can be plotted onto a graph which should give us a nice representation of Big O notations.\n\nNote too that Big O notations always show the worst case. For this reason, I’ll ensure to use values which the function will have to do the most work for.","type":"content","url":"/on-visualizingbigonotation","position":1},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(1)"},"type":"lvl2","url":"/on-visualizingbigonotation#o-1","position":2},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(1)"},"content":"O(1) means constant time. No matter what size the input, the runtime will always be the same. A simple example is finding the middle number in a list. I’ll ensure that all code return the amount of time a command was run in the function. This may make the code look just a bit bloated, but for a good \n\nreason.To find the center of a list we simply divide the length of the list in two, and return that number. It does not matter if a list has 10 elements or 100 elements, the same amount of steps is performed:def O1(input):\n    count = 0\n    result = input[len(input) / 2]\n    count += 1\n    return count\n\nI have created 5 lists. The first is length 10, the second the length 20, and so on. I’ll get the returned values and plot them.","type":"content","url":"/on-visualizingbigonotation#o-1","position":3},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(1) plot","lvl2":"O(1)"},"type":"lvl3","url":"/on-visualizingbigonotation#o-1-plot","position":4},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(1) plot","lvl2":"O(1)"},"content":"As can be seen, it doesn’t matter the size of the input. It will always run at the same constant time.","type":"content","url":"/on-visualizingbigonotation#o-1-plot","position":5},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(logN)"},"type":"lvl2","url":"/on-visualizingbigonotation#o-logn","position":6},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(logN)"},"content":"O(logN) increases as the input size goes up. However, it goes up as a log of the input size. This means that you can exponentially increase your input size, without linearly increasing the processing time to match.def OlogN(input):\n    def search(length, count):\n        count += 1\n        length /= 2\n        if length == 1 or length == 0:\n            return 1 + count\n        else:\n            return 1 + search(length, count)\n    return 1 + search(len(input), 1)\n","type":"content","url":"/on-visualizingbigonotation#o-logn","position":7},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(logN) plot","lvl2":"O(logN)"},"type":"lvl3","url":"/on-visualizingbigonotation#o-logn-plot","position":8},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(logN) plot","lvl2":"O(logN)"},"content":"\n\nThe run time is going up but look at the size of the inputs at the bottom. I start with 10,000 and move up to 500,000. The number of steps has increased, but not significantly.","type":"content","url":"/on-visualizingbigonotation#o-logn-plot","position":9},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N)"},"type":"lvl2","url":"/on-visualizingbigonotation#o-n","position":10},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N)"},"content":"O(N) is linear. This means that the run time is linearly matched to the input size. They should increase at exactly the same rate.def ON(input, check):\n    count = 0\n    for number in input:\n        count += 1\n        if number == check:\n            return 1 + count\n","type":"content","url":"/on-visualizingbigonotation#o-n","position":11},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N) plot","lvl2":"O(N)"},"type":"lvl3","url":"/on-visualizingbigonotation#o-n-plot","position":12},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N) plot","lvl2":"O(N)"},"content":"\n\nThere is a 1:1 correlation between input size and run time. As expected this produces a linear graph.","type":"content","url":"/on-visualizingbigonotation#o-n-plot","position":13},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^2^)"},"type":"lvl2","url":"/on-visualizingbigonotation#o-n-2","position":14},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^2^)"},"content":"O(N^2^)’s runtime will go up as a square of the input size. The runtime goes up faster than your input sizes, so processing time increases rapidly. This is usually when you iterate through multiple loops at the same time like so:def ON2(input):\n    count = 0\n    for i in input:\n        count += 1\n        for j in input:\n            count += 1\n    return 1 + count\n","type":"content","url":"/on-visualizingbigonotation#o-n-2","position":15},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^2^) plot","lvl2":"O(N^2^)"},"type":"lvl3","url":"/on-visualizingbigonotation#o-n-2-plot","position":16},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^2^) plot","lvl2":"O(N^2^)"},"content":"","type":"content","url":"/on-visualizingbigonotation#o-n-2-plot","position":17},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^3^)"},"type":"lvl2","url":"/on-visualizingbigonotation#o-n-3","position":18},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"O(N^3^)"},"content":"O(N^3^)is merely O(N^2^) with another exponent. I wanted to show the difference by simply changing the exponent.def ON3(input):\n    count = 0\n    for i in input:\n        count += 1\n        for j in input:\n            count += 1\n            for k in input:\n                count +=1\n    return 1 + count\n","type":"content","url":"/on-visualizingbigonotation#o-n-3","position":19},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^3^) plot","lvl2":"O(N^3^)"},"type":"lvl3","url":"/on-visualizingbigonotation#o-n-3-plot","position":20},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl3":"O(N^3^) plot","lvl2":"O(N^3^)"},"content":"Graphs increase rapidly as the exponent increases.","type":"content","url":"/on-visualizingbigonotation#o-n-3-plot","position":21},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"Conclusions"},"type":"lvl2","url":"/on-visualizingbigonotation#conclusions","position":22},{"hierarchy":{"lvl1":"Visualizing Big O notation","lvl2":"Conclusions"},"content":"I’ve not shown every single type of algorithm, as I just wanted to show the ones I have the most experience with. It’s nice to have a visual representation of these things as it really drills down just how fast your runtime can increase with larger inputs.\n\nYou can find my code used over here.\n\n\nhttps://​github​.com​/mellowdrifter​/Blog​_Code​/tree​/master​/Big_O\n\nEnd Of Topic","type":"content","url":"/on-visualizingbigonotation#conclusions","position":23},{"hierarchy":{"lvl1":"Priority Queue"},"type":"lvl1","url":"/priorityqueue","position":0},{"hierarchy":{"lvl1":"Priority Queue"},"content":"","type":"content","url":"/priorityqueue","position":1},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Key Ideas"},"type":"lvl2","url":"/priorityqueue#key-ideas","position":2},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Key Ideas"},"content":"Priority Queue\n\nDefinition\n\nA Priority Queue is a queue where there is a mechanism to place data at the start or in front of other data.","type":"content","url":"/priorityqueue#key-ideas","position":3},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Lecture Code"},"type":"lvl2","url":"/priorityqueue#lecture-code","position":4},{"hierarchy":{"lvl1":"Priority Queue","lvl2":"Lecture Code"},"content":"// priorityQ.java\n// demonstrates priority queue\n\n/**\n *\n * @author jgoudy\n */\nclass PriorityQ {\n\n    private int maxSize;\n    private int[] queArr;\n    private int nItems;\n\n    // constructor\n    public PriorityQ(int maxSize) {\n        this.maxSize = maxSize;\n        queArr = new int[maxSize];\n        nItems = 0;\n    }\n\n    public boolean isFull() {\n        return (nItems == maxSize);\n    }\n\n    public boolean isEmpty() {\n        return (nItems == 0);\n    }\n\n    // enqueue - add to queue\n    // lower numbers take a higher place in the queue\n    \n    public void enqueue(int key) {\n        int c;\n\n        if (isEmpty()) {\n            queArr[nItems++] = key;\n        } else {\n            for (c = nItems - 1; c >= 0; c--) {\n                if (key > queArr[c]) {\n                    queArr[c + 1] = queArr[c];\n                } else {\n                    break;\n                }\n            }// end of for\n\n            queArr[c + 1] = key;\n\n            nItems++;\n        }\n    }\n\n    // retreive the next item from the queue\n    // and remove it from the queue\n    public int dequeue() {\n        return queArr[--nItems];\n    }\n\n    // reteive the data from the next item in the queue\n    // but does NOT remove it\n    public int peek() {\n        return queArr[nItems - 1];\n    }\n\n    // print the queue\n    public void printPriorityQ() {\n        System.out.println();\n        for (int c = 0; c < nItems; c++) {\n            System.out.print(queArr[c] + \" \");\n        }\n        System.out.println();\n\n    }\n\n} // end of class\n\npublic class Ds_priorityQueue {\n\n    public static void main(String[] args) {\n\n// assumption lower the number - higher the priority\n        PriorityQ thePQ = new PriorityQ(10);\n\n        // add data items to the queue\n        thePQ.enqueue(30);\n        thePQ.enqueue(50);\n        thePQ.enqueue(10);\n        thePQ.enqueue(40);\n        thePQ.enqueue(20);\n        thePQ.enqueue(60);\n        thePQ.enqueue(5);\n\n        // print the queue\n        thePQ.printPriorityQ();\n\n        System.out.println(\"\\n-----------\\n\");\n\n        // peek at the next data item\n        System.out.println(\"Peek \" + thePQ.peek());\n\n        System.out.println(\"\\n-----------\\n\");\n\n        // remove all the items from the queue\n        while (!thePQ.isEmpty()) {\n            int x = thePQ.dequeue();\n            System.out.print(x + \" \");\n        }\n\n        System.out.println(\"\\n-----------\\n\");\n\n    }\n}\n\n/* Output\n  \n 60 50 40 30 20 10 5 \n\n-----------\n\nPeek 5\n\n-----------\n\n5 10 20 30 40 50 60 \n-----------\n \n */\n\nEnd Of Topic","type":"content","url":"/priorityqueue#lecture-code","position":5},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects"},"type":"lvl1","url":"/queueusingarrayofobjects","position":0},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects"},"content":"","type":"content","url":"/queueusingarrayofobjects","position":1},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Queue Methods"},"type":"lvl2","url":"/queueusingarrayofobjects#queue-methods","position":2},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Queue Methods"},"content":"Methods usually associated with a queue are as follows:\n\nEnqueue - add data to the queue.\n\nDequeue - remove data from the queue\n\nPeek - retrieves the next piece/“head” data from the queue, but does not remove it.\n\nisFull - this is used when making a queue with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the queue is empty.\n\nTip\n\nisFull is not needed if a Stack is created using a Linked List // make a new queue object\n\n Queue theQue = new Queue(5);\n\n /*\n  NOTICE THE CODE BELOW - \n  make an object from the sub class\n */\n\nQueue.Town theTown = theQue.new Town(\"\", 0);\n\nDetails discussed","type":"content","url":"/queueusingarrayofobjects#queue-methods","position":3},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Lecture Code"},"type":"lvl2","url":"/queueusingarrayofobjects#lecture-code","position":4},{"hierarchy":{"lvl1":"Queue  - Using Array Of Objects","lvl2":"Lecture Code"},"content":"/*\n *Programmer: James Goudy\n *Project: Queue of Objects\n *\n */\npackage com.mycompany.ds132su_queue;\n\n/**\n *\n * @author jgoudy\n */\nclass Queue {\n\n    class Town {\n        // subclass\n        public String city;\n        public int population;\n\n        public Town(String city, int population) {\n            this.city = city;\n            this.population = population;\n        }\n\n        public void displayTown() {\n            System.out.print(\"{\" + city + \" - \" + population + \"} \");\n        }\n\n    }// end of town\n\n    private int maxSize;\n    private Town[] queArray;\n    private int numItems;\n    private int head;\n    private int tail;\n\n    // Queue Constructor\n    public Queue(int maxSize) {\n        this.maxSize = maxSize;\n        queArray = new Town[maxSize];\n        head = 0;\n        tail = -1;\n        numItems = 0;\n    }\n\n    public boolean isFull() {\n        return (numItems == maxSize);\n    }\n\n    public boolean isEmpty() {\n        return (numItems == 0);\n    }\n\n    public boolean enqueue(String city, int population) {\n\n        // insert at tail\n        // \"enqueue\"\n        if (isFull()) {\n            return false;\n        }\n\n        // create town\n        Town newTown = new Town(city, population);\n\n        // wrap to front if neccessary\n        if (tail == maxSize - 1) {\n            tail = -1;\n        }\n\n        // add object to array\n        queArray[++tail] = newTown;\n\n        // increment the count of objects in the array\n        numItems++;\n\n        return true;\n    }\n\n    public Town dequeue() {\n        // remove from the front - the head \n        // \"dequeue\"\n\n        if (isEmpty()) {\n            System.out.print(\"Queue is empty\");\n            return null;\n        }\n\n        // retreive the next in queue and move the head to\n        // the next data item.\n        Town temp = queArray[head++];\n\n        if (head == maxSize) {\n            head = 0;\n        }\n\n        // decrease the count of objects in the array\n        numItems--;\n\n        return temp;\n    }\n\n    public Town peek() {\n        // retreive the head information but do not remove \n        return queArray[head];\n    }\n\n    public void displayQueue() {\n        int cntr = 0;\n        int pos = head;\n        while (cntr < numItems) {\n            queArray[pos].displayTown();\n            cntr++;\n\n            pos++;\n            // loop to the start of the array if necessary\n            if (pos == maxSize) {\n                pos = 0;\n            }\n\n        }\n        System.out.println(\"\\n\");\n    }\n\n} // end of queue\n\npublic class DS132SU_Queue {\n\n    public static void main(String[] args) {\n\n        // make a new queue object\n        Queue theQue = new Queue(5);\n\n        // make an object from the sub class\n        Queue.Town theTown = theQue.new Town(\"\", 0);\n\n        String acity;\n\n        theQue.enqueue(\"Bozeman\", 100000);\n        theQue.enqueue(\"Culver\", 100001);\n        theQue.enqueue(\"Dover\", 100002);\n        theQue.enqueue(\"Edger\", 100003);\n\n        System.out.println(\"\\n------ Queue--------\\n\");\n\n        theQue.displayQueue();\n\n        System.out.println(\"\\nDequeue the first two items in the queue\");\n\n        // return next item from the queue\n        theTown = theQue.dequeue();\n        System.out.println(\"\\n\" + theTown.city + \" - \" + theTown.population);\n\n        theTown = theQue.dequeue();\n        System.out.println(\"\\n\" + theTown.city + \" - \" + theTown.population);\n\n        System.out.println(\"\\n--------------\\n\");\n\n        System.out.println(\"\\nDequeue and retreive only the city\");\n\n        // another option to dequeue and retrieve city only\n        acity = theQue.dequeue().city;\n        System.out.println(acity);\n\n        System.out.println(\"\\n------ Queue--------\\n\");\n\n        theQue.displayQueue();\n\n        theQue.enqueue(\"Franklin\", 104);\n        theQue.enqueue(\"Georgetown\", 105);\n        theQue.enqueue(\"Highland\", 106);\n\n        System.out.println(\"\\n------- Queue -------\\n\");\n        theQue.displayQueue();\n\n        System.out.println(\"\\n----- Peek just city ---------\\n\");\n\n        acity = theQue.peek().city;\n        System.out.println(acity);\n\n        System.out.println(\"\\n----- Peek city population ---------\\n\");\n\n        theTown = theQue.peek();\n        System.out.println(\"\\n\" + theTown.city + \" - \" + theTown.population);\n\n        System.out.println(\"\\n------ Queue --------\\n\");\n        // notice that peek did not remove any towns\n        theQue.displayQueue();\n\n    }\n}\n\n/*\n Output\n \n------ Queue--------\n\n{Bozeman - 100000} {Culver - 100001} {Dover - 100002} {Edger - 100003} \n\n\nDequeue the first two items in the queue\n\nBozeman - 100000\n\nCulver - 100001\n\n--------------\n\n\nDequeue and retreive only the city\nDover\n\n------ Queue--------\n\n{Edger - 100003} \n\n\n------- Queue -------\n\n{Edger - 100003} {Franklin - 104} {Georgetown - 105} {Highland - 106} \n\n\n----- Peek just city ---------\n\nEdger\n\n----- Peek city population ---------\n\n\nEdger - 100003\n\n------ Queue --------\n\n{Edger - 100003} {Franklin - 104} {Georgetown - 105} {Highland - 106} \n  \n \n \n */\n\nEnd Of Topic","type":"content","url":"/queueusingarrayofobjects#lecture-code","position":5},{"hierarchy":{"lvl1":"Quick Sort"},"type":"lvl1","url":"/quicksort","position":0},{"hierarchy":{"lvl1":"Quick Sort"},"content":"Quicksort is a highly efficient sorting algorithm that utilizes the divide-and-conquer strategy to recursively partition an array into smaller subarrays until the entire array is sorted. It’s a versatile algorithm applicable to various data types and input conditions, making it a popular choice for both educational and practical purposes.\n\nHere’s a step-by-step breakdown of how quicksort works:\n\nPivot Selection: Choose an element from the array as the pivot. This pivot will serve as a reference point for partitioning the array.\n\nPartitioning: Partition the array around the pivot, placing elements smaller than the pivot to its left and elements larger than the pivot to its right. This process involves moving elements from one end of the array to the other until the pivot is at its correct position in the sorted array.\n\nRecursion: Recursively apply the partitioning process to the two subarrays created in the previous step. This means treating each subarray as a new unsorted array and repeating the pivot selection and partitioning steps until all subarrays are sorted.\n\nBase Case: The recursion stops when a subarray contains only one element, as it is already sorted.\n\nThe efficiency of quicksort stems from its ability to divide the array into smaller and smaller subarrays, reducing the overall number of comparisons required for sorting. However, its worst-case performance is O(n^2), which occurs when the pivot selection consistently leads to unbalanced subarrays.\n\nIn summary, quicksort is a fast and effective sorting algorithm that works by recursively partitioning an array around a pivot element until the entire array is sorted. Its efficiency and simplicity make it a popular choice for various sorting tasks.\n\nHere is a list of the pros and cons of quicksort in bullet points:\n\nPros:\n\nEfficiency: Quicksort has an average time complexity of O(n log n), which is one of the best among sorting algorithms.\n\nSimplicity: Quicksort is relatively easy to understand and implement, making it a popular choice for teaching and practical applications.\n\nIn-place: Quicksort is an in-place sorting algorithm, meaning it does not require additional memory to store intermediate results.\n\nAdaptability: Quicksort can be adapted to handle various data types and input conditions.\n\nCons:\n\nWorst-case performance: Quicksort has a worst-case time complexity of O(n^2), which occurs when the pivot selection is consistently poor.\n\nInstability: Quicksort is unstable, meaning it does not preserve the original order of equal elements.\n\nMemory usage: Quicksort may require a significant amount of stack space for recursion, especially for large datasets.\n\nSensitivity to pivot selection: The performance of quicksort is heavily dependent on the choice of pivot, making it susceptible to variations in input data.\n\nOverall, quicksort is a versatile and efficient sorting algorithm with a proven track record in various applications. However, it is essential to consider its potential drawbacks, such as worst-case performance and instability, when selecting an appropriate sorting algorithm for a specific task.","type":"content","url":"/quicksort","position":1},{"hierarchy":{"lvl1":"Singly Linked List"},"type":"lvl1","url":"/singlylinkedlistrev3","position":0},{"hierarchy":{"lvl1":"Singly Linked List"},"content":"Note\n\n\n\nSingly linked list is a type of linked list that is unidirectional. It can be traversed in only one direction from the head to the last node (tail). The last node always points to null","type":"content","url":"/singlylinkedlistrev3","position":1},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Ternary Operator"},"type":"lvl2","url":"/singlylinkedlistrev3#ternary-operator","position":2},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Ternary Operator"},"content":"Ternary Operator is an instruction that consists of three parts.\nCondition Part - test if something is true or false\nTrue Part - what is returned if the condition is true\nFalse Part - what is returned if the condition is false\n\nx = **(Conditional Part) ** ? True Part : False Part;// Example\ny = 3;\nx = (y < 4) ? \"y is less than four\": \"y is greater than four\"\nSystem.out.write(x);\n\n// Output\n// y is less than four","type":"content","url":"/singlylinkedlistrev3#ternary-operator","position":3},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Lecture Code"},"type":"lvl2","url":"/singlylinkedlistrev3#lecture-code","position":4},{"hierarchy":{"lvl1":"Singly Linked List","lvl2":"Lecture Code"},"content":"","type":"content","url":"/singlylinkedlistrev3#lecture-code","position":5},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List Code","lvl2":"Lecture Code"},"type":"lvl3","url":"/singlylinkedlistrev3#singly-linked-list-code","position":6},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List Code","lvl2":"Lecture Code"},"content":"The Link and the controlling Linked List are written as two separate classes/*\n * Singly Linked List\n *\n * singlylinkedlists_rev3\n * Programmer: James Goudy\n *\n */\npackage singlylinkedlists_rev3;\n\nclass Link\n{\n\n    // Data goes here\n    public String city = \"\";\n    public int population = 0;\n\n    // link to next node\n    public Link next;\n\n    // constructor\n    public Link(String city, int population)\n    {\n        this.city = city;\n        this.population = population;\n    }\n\n    // display the link\n    public void displayLink()\n    {\n        System.out.print(\"{\" + city + \", \" + population + \"} \");\n    }\n\n}\n\n\nclass LinkedList\n{\n\n    // first is a reference / \"address\" of the first link\n    private Link first;\n\n    // constructor\n    public LinkedList()\n    {\n        first = null;\n    }\n\n    //Check if the list is empty\n    public boolean isEmpty()\n    {\n        return (first == null);\n    }\n\n    // insert at the front \n    // of the list (front[left] -- to --> back[right]) \n    public void insertFirst(String city, int population)\n    {\n\n        // create a new link\n        Link newLink = new Link(city, population);\n\n        // the new link is to the left or in front of first\n        // the new link will make first in the second spot\n        // so newLink.next has to point to the address first\n        newLink.next = first;\n\n        // now that the newLink.next is looking at the seond spot\n        // or the next spot, first can have the address of the newLink\n        first = newLink;\n\n    }\n\n    //This function displays the linked list\n    public void displayList()\n    {\n        System.out.print(\"\\nList\\n(first --> last): \");\n\n        //temp variable to hold first\n        Link current = first;\n\n        while (current != null)\n        {\n            current.displayLink();\n\n            // move to the next  link\n            current = current.next;\n        }\n\n        System.out.println();\n    } //end of display list\n\n    public boolean findCity(String city)\n    {\n        boolean found = false;\n\n        Link current = first;\n        // iterate through the loop\n        while (current != null)\n        {\n            // check if current city matches search city\n            // set found to true and break out of the loop\n            if (current.city.equals(city))\n            {\n                found = true;\n                break;\n            }\n\n            current = current.next;\n\n        }\n\n        return found;\n    }\n\n    // delete first\n    public Link deleteFirst()\n    {\n\n        // temp variable to hold first address\n        // temp is pointing to an address\n        Link temp = first;\n\n        if (!isEmpty())\n        {\n            // set variable to second spot\n            first = first.next;\n        }\n\n        // return a link to object \n        // in case calling program wants\n        // to retreive the deleted data\n        return temp;\n    }\n\n    public void deleteCity(String city)\n    {\n        // assumes the data does not have duplicates\n\n        //need to check if the city was found\n        boolean found = false;\n\n        Link current = first;\n        Link prev = first;\n        Link temp;\n\n        // check if city is in the first node\n        if (first.city.equals(city))\n        {\n            temp = first;\n            first = first.next;\n            temp = null;\n            System.out.println(\"City was deleted\");\n            return;\n        }\n\n        // start at the beginning of list\n        while (current != null)\n        {\n            // check if the current city matches the search city\n            if (current.city.equals(city))\n            {\n                found = true;\n\n                // break out of the while statement\n                break;\n            }\n\n            // set the prev variable\n            prev = current;\n\n            // move to the next node\n            current = current.next;\n        }\n\n        // check if the while statment made it to \n        // the end of the loop\n        if (found == false)\n        {\n            System.out.println(\"\\n*** City not found - Nothing deleted\");\n            return;\n        }\n\n        // delete process\n        prev.next = current.next;\n\n        current = null;\n        System.out.println(\"\\n*** City was successfully delete\");\n\n    }\n\n    public void deleteList()\n    {\n        while (first != null)\n        {\n            deleteFirst();\n        }\n\n    }\n\n    // city is the location of where the new data \n    // will be inserted (after)\n    // newCity and newPop are the new city and new population\n    public void insertAfter(String city, String newCity, int newPop)\n    {\n        boolean found = false;\n        Link current = first;\n\n        //create a new link\n        Link NewLink = new Link(newCity, newPop);\n\n        try\n        {\n            // iterate through loop\n            while (current != null)\n            {\n                // break out of the loop if found\n                // stops the loop at the found city\n                // sets found to true\n                if (current.city.equals(city))\n                {\n                    found = true;\n                    break;\n                }\n\n                // move to next node\n                current = current.next;\n            }\n\n            // insert process\n            NewLink.next = current.next;\n            current.next = NewLink;\n\n        } catch (Exception e)\n        {\n            System.out.println(\"**Error**\\n\" + e.getMessage() + \"\\n***\\n\");\n        }\n\n    }\n\n} // end of class\n\npublic class SinglyLinkedLists_Rev3\n{\n\n    public static void main(String[] args)\n    {\n        LinkedList theList = new LinkedList();\n\n\n        theList.insertFirst(\"Kali\", 32000);\n        theList.insertFirst(\"Whitefish\", 7700);\n        theList.insertFirst(\"Polson\", 20000);\n        theList.insertFirst(\"Chicago\", 13000000);\n        theList.insertFirst(\"Convoy\", 500);\n\n        theList.displayList();\n\n        System.out.println(\"Find Kali : \" + theList.findCity(\"Kali\"));\n\n        // ternary operator\n        String output = (theList.findCity(\"Polson\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Polson: \" + output);\n\n        output = (theList.findCity(\"Somers\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Somers: \" + output);\n\n        theList.deleteFirst();\n        theList.displayList();\n\n        theList.deleteCity(\"Chicago\");\n        theList.displayList();\n\n        theList.insertAfter(\"Polson\", \"New York\", 10000000);\n        theList.displayList();\n\n        theList.deleteList();\n        theList.displayList();\n    }\n\n}\n","type":"content","url":"/singlylinkedlistrev3#singly-linked-list-code","position":7},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List - Nested Link Class","lvl2":"Lecture Code"},"type":"lvl3","url":"/singlylinkedlistrev3#singly-linked-list-nested-link-class","position":8},{"hierarchy":{"lvl1":"Singly Linked List","lvl3":"Singly Linked List - Nested Link Class","lvl2":"Lecture Code"},"content":"/*\n * Single Link List\n *\n * SingleLinkList_nested_Rev3\n * Programmer: James Goudy\n *\n */\npackage singlylinkedlists_nested_rev3;\n\nclass LinkedList\n{\n\n    class Link\n    {\n\n        // Data goes here\n        public String city = \"\";\n        public int population = 0;\n\n        // link to next node\n        public Link next;\n\n        // constructor\n        public Link(String city, int population)\n        {\n            this.city = city;\n            this.population = population;\n        }\n\n        // display the link\n        public void displayLink()\n        {\n            System.out.print(\"{\" + city + \", \" + population + \"} \");\n        }\n\n    }\n\n    // first is a reference / \"address\" of the first link\n    private Link first;\n\n    // constructor\n    public LinkedList()\n    {\n        first = null;\n    }\n\n    //Check if the list is empty\n    public boolean isEmpty()\n    {\n        return (first == null);\n    }\n\n    // insert at the front \n    // of the list (front[left] -- to --> back[right]) \n    public void insertFirst(String city, int population)\n    {\n\n        // create a new link\n        Link newLink = new Link(city, population);\n\n        // the new link is to the left or in front of first\n        // the new link will make first in the second spot\n        // so newLink.next has to point to the address first\n        newLink.next = first;\n\n        // now that the newLink.next is looking at the seond spot\n        // or the next spot, first can have the address of the newLink\n        first = newLink;\n\n    }\n\n    //This function displays the linked list\n    public void displayList()\n    {\n        System.out.print(\"\\nList\\n(first --> last): \");\n\n        //temp variable to hold first\n        Link current = first;\n\n        while (current != null)\n        {\n            current.displayLink();\n\n            // move to the next  link\n            current = current.next;\n        }\n\n        System.out.println();\n    } //end of display list\n\n    public boolean findCity(String city)\n    {\n        boolean found = false;\n\n        Link current = first;\n        // iterate through the loop\n        while (current != null)\n        {\n            // check if current city matches search city\n            // set found to true and break out of the loop\n            if (current.city.equals(city))\n            {\n                found = true;\n                break;\n            }\n\n            current = current.next;\n\n        }\n\n        return found;\n    }\n\n    // delete first\n    public Link deleteFirst()\n    {\n\n        // temp variable to hold first address\n        // temp is pointing to an address\n        Link temp = first;\n\n        if (!isEmpty())\n        {\n            // set variable to second spot\n            first = first.next;\n        }\n\n        // return a link to object \n        // in case calling program wants\n        // to retreive the deleted data\n        return temp;\n    }\n\n    public void deleteCity(String city)\n    {\n        // assumes the data does not have duplicates\n\n        //need to check if the city was found\n        boolean found = false;\n\n        Link current = first;\n        Link prev = first;\n        Link temp;\n\n        // check if city is in the first node\n        if (first.city.equals(city))\n        {\n            temp = first;\n            first = first.next;\n            temp = null;\n            System.out.println(\"City was deleted\");\n            return;\n        }\n\n        // start at the beginning of list\n        while (current != null)\n        {\n            // check if the current city matches the search city\n            if (current.city.equals(city))\n            {\n                found = true;\n\n                // break out of the while statement\n                break;\n            }\n\n            // set the prev variable\n            prev = current;\n\n            // move to the next node\n            current = current.next;\n        }\n\n        // check if the while statment made it to \n        // the end of the loop\n        if (found == false)\n        {\n            System.out.println(\"\\n*** City not found - Nothing deleted\");\n            return;\n        }\n\n        // delete process\n        prev.next = current.next;\n\n        current = null;\n        System.out.println(\"\\n*** City was successfully delete\");\n\n    }\n\n    public void deleteList()\n    {\n        while (first != null)\n        {\n            deleteFirst();\n        }\n\n    }\n\n    // city is the location of where the new data \n    // will be inserted (after)\n    // newCity and newPop are the new city and new population\n    public void insertAfter(String city, String newCity, int newPop)\n    {\n        boolean found = false;\n        Link current = first;\n\n        //create a new link\n        Link NewLink = new Link(newCity, newPop);\n\n        try\n        {\n            // iterate through loop\n            while (current != null)\n            {\n                // break out of the loop if found\n                // stops the loop at the found city\n                // sets found to true\n                if (current.city.equals(city))\n                {\n                    found = true;\n                    break;\n                }\n\n                // move to next node\n                current = current.next;\n            }\n\n            // insert process\n            NewLink.next = current.next;\n            current.next = NewLink;\n\n        } catch (Exception e)\n        {\n            System.out.println(\"**Error**\\n\" + e.getMessage() + \"\\n***\\n\");\n        }\n\n    }\n\n} // e\n\npublic class Singlylinkedlists_nested_rev3\n{\n\n    public static void main(String[] args)\n    {\n\n        LinkedList theList = new LinkedList();\n        \n        // how to create a Link from a nested class\n        // note that the new link has to be created from the\n        // outer link ('theList')\n        LinkedList.Link aLink =  theList.new Link(\"Detroit\", 2000000);\n        \n        // display the created link\n        System.out.println(\"Created Inner Link\");\n        aLink.displayLink();\n        System.out.println(\"\\n\\n\");\n        \n        \n\n        theList.insertFirst(\"Kali\", 32000);\n        theList.insertFirst(\"Whitefish\", 7700);\n        theList.insertFirst(\"Polson\", 20000);\n        theList.insertFirst(\"Chicago\", 13000000);\n        theList.insertFirst(\"Convoy\", 500);\n\n        theList.displayList();\n\n        System.out.println(\"Find Kali : \" + theList.findCity(\"Kali\"));\n\n        // ternary operator\n        String output = (theList.findCity(\"Polson\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Polson: \" + output);\n\n        output = (theList.findCity(\"Somers\") == true)\n                ? \"City Found\" : \"City Not Found\";\n        System.out.println(\"Somers: \" + output);\n\n        theList.deleteFirst();\n        theList.displayList();\n\n        theList.deleteCity(\"Chicago\");\n        theList.displayList();\n\n        theList.insertAfter(\"Polson\", \"New York\", 10000000);\n        theList.displayList();\n\n        theList.deleteList();\n        theList.displayList();\n\n    }\n\n}\n\n\nEnd Of Topic","type":"content","url":"/singlylinkedlistrev3#singly-linked-list-nested-link-class","position":9},{"hierarchy":{"lvl1":"Sorting Algorithms"},"type":"lvl1","url":"/sortalgorithms","position":0},{"hierarchy":{"lvl1":"Sorting Algorithms"},"content":"Bubble Sort","type":"content","url":"/sortalgorithms","position":1},{"hierarchy":{"lvl1":"Sorting Algorithms","lvl2":"Visualizations"},"type":"lvl2","url":"/sortalgorithms#visualizations","position":2},{"hierarchy":{"lvl1":"Sorting Algorithms","lvl2":"Visualizations"},"content":"Visual Aglo\n\nToptal\n\nComparison Sorting Algorithms\n\nSort Visualizer\n\nEnd Of Topic","type":"content","url":"/sortalgorithms#visualizations","position":3},{"hierarchy":{"lvl1":"Bubble Sort"},"type":"lvl1","url":"/sort-bubble","position":0},{"hierarchy":{"lvl1":"Bubble Sort"},"content":"","type":"content","url":"/sort-bubble","position":1},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Key Ideas"},"type":"lvl3","url":"/sort-bubble#key-ideas","position":2},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Key Ideas"},"content":"Bubble Sort\n\nDefinition\n\nBubble Sort is a simple sorting algorithm that repeatedly iterates through the list or array. It compares adjacent elements and swaps them if they are in the wrong order. The algorithm repeatedly passes through the list until the list is sorted. It is a comparison sort and is named for the way smaller or larger elements “bubble” to the top of the list.","type":"content","url":"/sort-bubble#key-ideas","position":3},{"hierarchy":{"lvl1":"Bubble Sort","lvl2":"Performance"},"type":"lvl2","url":"/sort-bubble#performance","position":4},{"hierarchy":{"lvl1":"Bubble Sort","lvl2":"Performance"},"content":"Bubble sort has a worst-case and average complexity of On^2^.","type":"content","url":"/sort-bubble#performance","position":5},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Visualizations","lvl2":"Performance"},"type":"lvl3","url":"/sort-bubble#visualizations","position":6},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Visualizations","lvl2":"Performance"},"content":"Visual Aglo\n\nToptal\n\nComparison Sorting Algorithms\n\nSort Visualizer","type":"content","url":"/sort-bubble#visualizations","position":7},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Videos","lvl2":"Performance"},"type":"lvl3","url":"/sort-bubble#videos","position":8},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Videos","lvl2":"Performance"},"content":"\n\n---\n\n---","type":"content","url":"/sort-bubble#videos","position":9},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Lecture Code","lvl2":"Performance"},"type":"lvl3","url":"/sort-bubble#lecture-code","position":10},{"hierarchy":{"lvl1":"Bubble Sort","lvl3":"Lecture Code","lvl2":"Performance"},"content":"/*\n * Programmer: James Goudy\n * Project: Bubble Sort\n */\npackage com.mycompany.bubblesort_lecturecode;\n\nimport java.util.Random;\n\nclass BubbleSort {\n\n    // arrInt is an array of integers\n    // numDataElements is the actual count \n    // of elements of data in the array\n    // algorithm assumes the data is contiguous\n    int arrInt[];\n    int numDataElments;\n\n    public BubbleSort(int[] arrInt, int numDataElments) {\n        this.arrInt = arrInt;\n        this.numDataElments = numDataElments;\n    }\n\n    public void Sort() {\n        // \n        int n = numDataElments;\n\n        for (int c = 0; c < n; c++) {\n            for (int j = 1; j < (n); j++) {\n                \n                // check if the left element is \n                // greater to the one on the right\n                // \"Bubble\" the lowest to the left\n\n                if (arrInt[j - 1] > arrInt[j]) {\n                    // swap left element arr[j-1]\n                    // with the one on the right and arr[j]\n                    \n                    // store left one in temp\n                    int temp = arrInt[j - 1];\n                    //copy the right into the left\n                    arrInt[j - 1] = arrInt[j];\n                    //copy the left into the right\n                    arrInt[j] = temp;\n                }\n            }\n        }\n    }\n\n}\n\npublic class BubbleSort_LectureCode {\n\n    static int arrSize = 8;\n    //static int theArray[] = new int[arrSize];\n    static int theArray[] ={3,60,35,2,45,320,5,1}; \n    \n    static void fillTheArray()\n    {\n        Random RNG  = new Random();\n        for(int c = 0; c < arrSize; c++)\n        {\n            theArray[c] = RNG.nextInt(0,(arrSize*10));\n        }\n    }\n    \n    static void printArray(int anArray[], int numOfDataElements)\n    {\n        System.out.println(\"\");\n        for (int i = 0; i < numOfDataElements; i++) {\n            System.out.print(anArray[i] + \" \");\n        }\n        System.out.println(\"\\n--------------\\n\");\n        \n    }\n    \n    public static void main(String[] args) {\n       \n        // option to randomly fill the array\n        //fillTheArray();\n        \n        printArray(theArray, arrSize);\n        \n        BubbleSort bs = new BubbleSort(theArray, arrSize);\n        bs.Sort();\n        \n        printArray(theArray, arrSize);\n               \n        \n    }\n}\n\n/*\n3 60 35 2 45 320 5 1 \n--------------\n\n\n1 2 3 5 35 45 60 320 \n--------------\n*/\n\nEnd Of Topic","type":"content","url":"/sort-bubble#lecture-code","position":11},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects"},"type":"lvl1","url":"/stackusingarrayofobjects","position":0},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects"},"content":"","type":"content","url":"/stackusingarrayofobjects","position":1},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Stack Methods"},"type":"lvl2","url":"/stackusingarrayofobjects#stack-methods","position":2},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Stack Methods"},"content":"Methods usually associated with a stack are as follows:\n\nPush - adds data to the stack\n\nPop - removes data from the stack\n\nPeek - retrieves the next piece/top data from the stack, but does not remove it.\n\nisFull - this is used when making a stack with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the stack is empty.\n\nTip\n\nisFull is not needed if a Stack is created using a Linked List\n\nDetails discussed \n\nhere","type":"content","url":"/stackusingarrayofobjects#stack-methods","position":3},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Lecture Code"},"type":"lvl2","url":"/stackusingarrayofobjects#lecture-code","position":4},{"hierarchy":{"lvl1":"Stack  - Using Array of Objects","lvl2":"Lecture Code"},"content":"/*\n * Project: Stack Using Array of Objects\n * Programmer: James Goudy\n * DS132SU_StackArray\n *\n *\n * Stack\n * push\n * pop\n * peek\n * isEmpty\n * isFull\n *\n *\n */\n\nclass Town {\n\n    public String city;\n    public int population;\n\n    // constructor\n    public Town(String city, int population) {\n        this.city = city;\n        this.population = population;\n    }\n\n    public void displayCity() {\n        System.out.print(\"{\" + city + \", \" + population + \"} \");\n    }\n\n}\n\nclass Stack {\n\n    private int maxSize;\n    private Town[] stackArray;\n    private int top = -1;\n\n    //constructor\n    public Stack(int maxSize) {\n        this.maxSize = maxSize;\n        stackArray = new Town[maxSize];\n        top = -1;\n    }\n\n    public boolean push(String city, int population) {\n        \n        // add data to the stack\n        if (isFull()) {\n            return false;\n        } else {\n            Town theTown = new Town(city, population);\n            stackArray[++top] = theTown;\n            return true;\n        }\n\n    }\n\n    public Town pop() {\n        // remove data from the stack\n        return stackArray[top--];\n    }\n\n    public Town peek() {\n        // look/peek at the top of the stack\n        return stackArray[top];\n    }\n\n    public boolean isEmpty() {\n        //check if the array is empty\n        return (top == -1);\n    }\n\n    public boolean isFull() {\n        // check if the array is full\n        return (top == maxSize - 1);\n    }\n\n}\n\npublic class DS132SU_StackArray {\n\n    public static void main(String[] args) {\n\n        // create a stack\n        Stack myStack = new Stack(10);\n        Town tempTown = null;\n        \n        // add data to the stack\n        myStack.push(\"Kali\", 300000);\n        myStack.push(\"Bozeman\", 100000);\n        myStack.push(\"Whitefish\", 40000);\n        myStack.push(\"Columbia Falls\", 30000);\n\n        // peek at the top data\n        System.out.print(\"Peek - \");\n        myStack.peek().displayCity();\n        System.out.println(\"\");\n\n        // pop one data object from the stack and store it in an object\n        tempTown = myStack.pop();\n        tempTown.displayCity();\n        \n        // empty the list\n        while (!myStack.isEmpty()) {\n            myStack.pop().displayCity();\n        }\n\n        System.out.println(\"\");\n\n        //ternary operator\n        boolean flag;\n        flag = myStack.push(\"Plains\", 15000) ? true : false;\n\n        if (flag) {\n            System.out.println(\"Item added\");\n        } else {\n            System.out.println(\"Item NOT added\");\n        }\n\n        System.out.print(\"\\nbye\");\n    }\n}\n\n\nEnd of Topic","type":"content","url":"/stackusingarrayofobjects#lecture-code","position":5},{"hierarchy":{"lvl1":"Stacks and Queues"},"type":"lvl1","url":"/stacksandqueues","position":0},{"hierarchy":{"lvl1":"Stacks and Queues"},"content":"","type":"content","url":"/stacksandqueues","position":1},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Key Ideas"},"type":"lvl2","url":"/stacksandqueues#key-ideas","position":2},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Key Ideas"},"content":"Stacks\n\nQueues","type":"content","url":"/stacksandqueues#key-ideas","position":3},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Discussion"},"type":"lvl2","url":"/stacksandqueues#discussion","position":4},{"hierarchy":{"lvl1":"Stacks and Queues","lvl2":"Discussion"},"content":"Stacks and queues are a way of organizing data and consuming data. The data can be stored in an array or linked list.","type":"content","url":"/stacksandqueues#discussion","position":5},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Stack","lvl2":"Discussion"},"type":"lvl3","url":"/stacksandqueues#stack","position":6},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Stack","lvl2":"Discussion"},"content":"Note\n\n\n\nA Stack is a way of organizing and consuming data where the Last In is the First Out (LIFO). Or it can be thought of as First In is the Last Out (FILO).\n\nMost people think of a stack as a stack of plates, where each plate represents data. Data is pushed onto the stack. Meaning. it is added to the array or linked list. Data is consumed by popping it off of the stack. Meaning, that the last piece of data added to the stack is removed from the array or linked list. This data is usually used by the part of the program that is popping/removing it from the stack.  Peeking is looking at the last/next piece of data, but not removing it from the stack. An example is \n\nStack Array\n\nMethods usually associated with a stack are as follows:\n\nPush - adds data to the stack\n\nPop - removes data from the stack\n\nPeek - retrieves the next piece/top data from the stack, but does not remove it.\n\nisFull - this is used when making a stack with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the stack is empty.\n\nIn computer science, a stack is a LIFO (Last In, First Out) data structure that stores elements in a linear order. This means that the last element added to the stack is the first one to be removed. Stacks are often used to manage a sequence of operations, such as function calls or undo/redo functionality.\n\nHere are some of the key properties of stacks:\n\nLIFO order: Elements are removed in the reverse order they were added.\n\nBounded capacity: Stacks have a limited size, and adding more elements than the stack can hold will result in an error.\n\nEfficient access: Pushing and popping elements from the top of the stack is a very efficient operation, typically taking constant time.\n\nStacks are used in a variety of applications in computer science, including:\n\nFunction calls: When a function is called, its arguments and local variables are pushed onto a stack. When the function returns, its stack frame is popped off the stack.\n\nExpression evaluation: Stacks are used to evaluate expressions in many programming languages. For example, when evaluating arithmetic expressions, operands are pushed onto the stack, and then operators are popped off the stack and applied to the operands.\n\nBacktracking algorithms: Stacks are used to store the history of decisions made in backtracking algorithms, such as depth-first search. This allows the algorithm to backtrack to previous states if it reaches a dead end.\n\nUndo/redo functionality: Stacks are used to implement undo/redo functionality in many applications. When an action is performed, the state of the application is pushed onto the undo stack. To undo the action, the state is popped off the undo stack and restored.\n\nHere are some examples of how stacks are used in real-world applications:\n\nCompilers: Compilers use stacks to keep track of the current state of the program being compiled.\n\nInterpreters: Interpreters use stacks to evaluate expressions and statements in the program being interpreted.\n\nWeb browsers: Web browsers use stacks to keep track of the history of visited web pages.\n\nOperating systems: Operating systems use stacks to manage memory allocation and process scheduling.\n\nStacks are a versatile and powerful data structure that is used in a wide variety of applications in computer science. Their LIFO order and efficient access make them well-suited for managing sequences of operations and storing the history of decisions made in algorithms.","type":"content","url":"/stacksandqueues#stack","position":7},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Queue","lvl2":"Discussion"},"type":"lvl3","url":"/stacksandqueues#queue","position":8},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Queue","lvl2":"Discussion"},"content":"Note\n\n\n\nA Queue is a way of organizing and consuming data where the First In is the First Out (FIFO).\n\nMost people think of a queue as people standing in a line, where people represent data.  Data is consumed in the order in which it was added.\n\nMethods usually associated with a queue are as follows:\n\nEnqueue - add data to the queue.\n\nDequeue - remove data from the queue\n\nPeek - retrieves the next piece/“head” data from the queue, but does not remove it.\n\nisFull - this is used when making a queue with an array since an array has a limited number of elements.\n\nisEmpty - this is used to determine if the queue is empty.\n\nIn computer science, a queue is a LIFO (First In, First Out) data structure that stores elements in a linear order. This means that the first element added to the queue is the first one to be removed. Queues are often used to manage a sequence of tasks or events, such as printing jobs or network traffic.\n\nHere are some of the key properties of queues:\n\nFIFO order: Elements are removed in the order they were added.\n\nBounded capacity: Queues have a limited size, and adding more elements than the queue can hold will result in an error.\n\nEfficient access: Adding and removing elements from the front and back of the queue are efficient operations, typically taking constant time.\n\nQueues are used in a variety of applications in computer science, including:\n\nTask scheduling: Queues are used to schedule tasks in operating systems and other systems. For example, a print queue is used to manage the order in which print jobs are processed.\n\nNetwork traffic: Queues are used to manage the flow of data in networks. For example, a network buffer is used to store data packets that are waiting to be sent over a network.\n\nBuffering: Queues are used to buffer data between different components of a system. For example, a keyboard buffer is used to store characters typed on a keyboard until they can be processed by the operating system.\n\nMessage passing: Queues are used to pass messages between different processes or threads. For example, a message queue is used to store messages that are waiting to be processed by a consumer process.\n\nHere are some examples of how queues are used in real-world applications:\n\nOperating systems: Operating systems use queues to manage task scheduling, memory allocation, and device drivers.\n\nNetworking: Networking protocols use queues to manage the flow of data packets.\n\nMultimedia applications: Multimedia applications use queues to buffer audio and video data.\n\nMessaging applications: Messaging applications use queues to store messages that are waiting to be delivered to recipients.\n\nQueues are a versatile and powerful data structure that is used in a wide variety of applications in computer science. Their FIFO order and efficient access make them well-suited for managing sequences of tasks or events.","type":"content","url":"/stacksandqueues#queue","position":9},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Priority Queue","lvl2":"Discussion"},"type":"lvl3","url":"/stacksandqueues#priority-queue","position":10},{"hierarchy":{"lvl1":"Stacks and Queues","lvl3":"Priority Queue","lvl2":"Discussion"},"content":"Definition\n\nA Priority Queue is a queue where there is a mechanism to place data at the start or infront of other data.\n\nIn computer science, a priority queue is a specialized type of queue where elements are prioritized based on their associated priority values. Elements with higher priority values are served before elements with lower priority values. Priority queues are often implemented using heap data structures, which allow for efficient insertion and extraction operations.\n\nHere are some of the key properties of priority queues:\n\nPriority-based ordering: Elements are served based on their priority values, with higher priority elements being served first.\n\nEfficient insertion and extraction: Priority queues can efficiently insert and extract elements, typically taking logarithmic time.\n\nDynamic priority updates: Priority values can be updated dynamically, allowing for reprioritization of elements within the queue.\n\nPriority queues are used in a variety of applications where prioritization is important, including:\n\nTask scheduling: Priority queues are used to schedule tasks based on their urgency or importance. For example, a critical job processing system might use a priority queue to prioritize high-priority tasks over less urgent ones.\n\nNetwork traffic management: Priority queues can be used to prioritize network traffic based on its importance or quality of service requirements. For instance, real-time voice or video traffic might be prioritized over non-real-time data transfers.\n\nEvent handling: Priority queues can be used to manage a sequence of events, ensuring that high-priority events are handled first. For example, an event-driven system might use a priority queue to prioritize system alerts or critical user interactions.\n\nAlgorithm optimization: Priority queues are used in various algorithms, such as Dijkstra’s algorithm for shortest path finding and A* search for pathfinding in graph-based problems.\n\nHere are some real-world examples of how priority queues are used:\n\nOperating systems: Operating systems use priority queues to manage task scheduling, ensuring that high-priority tasks, such as system processes, are executed before less urgent user tasks.\n\nNetwork routers: Network routers use priority queues to manage network traffic, prioritizing real-time audio or video traffic over non-real-time data transfers.\n\nEmergency response systems: Emergency response systems might use priority queues to prioritize dispatching emergency responders based on the severity of incidents.\n\nHospital patient care: Critical care units in hospitals might use priority queues to manage patient care, ensuring that patients with the most urgent medical needs are seen first.\n\nPriority queues are a valuable data structure that plays a crucial role in various applications that require efficient prioritization and management of tasks, events, or data. Their ability to handle dynamic priority updates and their efficient insertion and extraction operations make them a well-suited choice for prioritizing elements in a variety of contexts.\n\nEnd Of Topic","type":"content","url":"/stacksandqueues#priority-queue","position":11},{"hierarchy":{"lvl1":"End Of Section"},"type":"lvl1","url":"/end","position":0},{"hierarchy":{"lvl1":"End Of Section"},"content":"Algorithms and Data Structures\n\nEnd Of Section","type":"content","url":"/end","position":1}]}