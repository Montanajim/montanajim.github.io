{"version":"1","records":[{"hierarchy":{"lvl1":"Bounce Balls Animation"},"type":"lvl1","url":"/xbounce","position":0},{"hierarchy":{"lvl1":"Bounce Balls Animation"},"content":"<img src=\"assets/Bounce_Rev24.gif\" alt=\"2024-04-11_11-55-01\" style=\"zoom: 67%;\" />\n\nInitial Setup:\n\nIt imports necessary libraries for Swing components, random number generation, timers, and colors.\n\nThe Frame1 class inherits from javax.swing.JFrame which represents the main window of the application.\n\nGlobal Variables:\n\npanelTimer: A timer object to control repainting of the panel where balls bounce.\n\nTimerStatus: Boolean flag to track if the timer is running.\n\nRNG: Instance of Random class to generate random values.\n\nInitial ball properties like x, y, radius.\n\nclockTick: Time interval between timer ticks (in milliseconds).\n\nalBalls: An ArrayList to store bouncing ball objects.\n\nRNG2: Another random number generator (potentially for future use).\n\nConstructor (Frame1):\n\nInitializes the frame and sets its layout.\n\nSets TimerStatus to false initially.\n\nCreates another random number generator (RNG2).\n\nPositions the frame in the center of the screen.\n\nPanelClock method:\n\nCreates a new Timer object with clockTick interval and an anonymous ActionListener.\n\nThe actionPerformed method of the listener iterates through alBalls, calling their moveBall method to update their positions.\n\nIt then loops through all components in jPanel1 (which should be the balls), retrieves their objects using casting, and sets their locations based on their xpos and ypos values in the Ball class.\n\nIt repaints the panel (jPanel1) and reduces the timer delay to a smaller value (presumably for smoother animation).\n\nFinally, starts the timer.\n\nEvent Handlers:\n\njbttnAddBallActionPerformed\n\n: triggered when the “Add Ball” button is clicked.\n\nCreates a new Ball object.\n\nSets random ball properties like radius, speed, color, and initial position.\n\nAdds the ball to the jPanel1 panel and the alBalls list.\n\nStarts the timer (PanelClock) if it’s not already running.\n\njbttnDeleteBallActionPerformed\n\n: triggered when the “Delete Ball” button is clicked.\n\nTries to remove the first ball from jPanel1 and alBalls\n\nRepaints the panel.\n\njbttnClearAllActionPerformed\n\n: triggered when the “Clear All” button is clicked.\n\nRemoves all components from jPanel1.\n\nClears the alBalls list.\n\nThis code demonstrates how to create a simple bouncing ball animation with Swing. The balls update their positions based on random directions and repaint themselves within the panel.\n\n","type":"content","url":"/xbounce","position":1},{"hierarchy":{"lvl1":"Bounce Balls Animation","lvl2":"Project File"},"type":"lvl2","url":"/xbounce#project-file","position":2},{"hierarchy":{"lvl1":"Bounce Balls Animation","lvl2":"Project File"},"content":"J2_Bounce_Rev24.java/*\nProject: Bounce\nDescription: Animate Bouncing Balls\nProgrammer: James Goudy\nDate: April, 2024\n */\npackage j2_bounce_rev24;\n\n/**\n *\n * @author jgoudy\n */\npublic class J2_Bounce_Rev24 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        \n        // Instatiate a new frame\n        Frame1 myFrame = new Frame1();\n        myFrame.setVisible(true);\n        myFrame.setSize(730,575);\n        \n        \n    }\n    \n}/*\nProject: Bounce\nDescription: Animate Bouncing Balls\nProgrammer: James Goudy\nDate: April, 2024\n */\npackage j2_bounce_rev24;\n\n/**\n *\n * @author jgoudy\n */\npublic class J2_Bounce_Rev24 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        \n        // Instatiate a new frame\n        Frame1 myFrame = new Frame1();\n        myFrame.setVisible(true);\n        myFrame.setSize(730,575);\n        \n        \n    }\n    \n}\n\n","type":"content","url":"/xbounce#project-file","position":3},{"hierarchy":{"lvl1":"Bounce Balls Animation","lvl2":"Frame1.java"},"type":"lvl2","url":"/xbounce#frame1-java","position":4},{"hierarchy":{"lvl1":"Bounce Balls Animation","lvl2":"Frame1.java"},"content":"/*\n * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license\n * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template\n */\npackage j2_bounce_rev24;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport javax.swing.Timer;\nimport java.awt.Color;\nimport javax.swing.JComponent;\n\n/**\n *\n * @author jgoudy\n */\npublic class Frame1 extends javax.swing.JFrame {\n\n    // Global Variables\n    Timer panelTimer;  //this will control the repaint of the panel\n    boolean TimerStatus;\n    \n    \n    Random RNG = new Random();\n    // Setup to show one can instantiate an object later\n    Random RNG2;\n    \n    \n    // initial ball info\n    int x = 1;\n    int y = 1;\n    int radius = 25;\n\n    // Timer Tick\n    int clockTick = 100;\n    \n    // Arraylist to hold the balls\n    ArrayList<Ball> alBalls = new ArrayList();\n\n\n    // constructor\n    public Frame1() {\n        initComponents();\n\n        TimerStatus = false;\n\n        RNG2 = new Random();\n\n        this.setLocationRelativeTo(null);\n\n    }\n\n    private void PanelClock() {\n\n        panelTimer = new Timer(clockTick, new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n\n                for (Ball item : alBalls) {\n                    item.moveBall();\n                }\n\n                for (int i = 0; i < jPanel1.getComponentCount(); i++) {\n                    Ball js = (Ball) jPanel1.getComponent(i);\n                    jPanel1.getComponent(i).setLocation(js.getXpos(), js.ypos);\n                }\n\n\n                jPanel1.repaint();\n                panelTimer.setDelay(20);\n            }\n        });\n\n        panelTimer.start();\n\n    }\n\n    /**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">                          \n    private void initComponents() {\n\n        jPanel1 = new javax.swing.JPanel();\n        jLabel1 = new javax.swing.JLabel();\n        jbttnAddBall = new javax.swing.JButton();\n        jbttnDeleteBall = new javax.swing.JButton();\n        jbttnClearAll = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 591, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 364, Short.MAX_VALUE)\n        );\n\n        jLabel1.setFont(new java.awt.Font(\"Segoe UI\", 1, 24)); // NOI18N\n        jLabel1.setText(\"Bounce\");\n\n        jbttnAddBall.setText(\"Add Ball\");\n        jbttnAddBall.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jbttnAddBallActionPerformed(evt);\n            }\n        });\n\n        jbttnDeleteBall.setText(\"Delete Ball\");\n        jbttnDeleteBall.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jbttnDeleteBallActionPerformed(evt);\n            }\n        });\n\n        jbttnClearAll.setText(\"Clear All\");\n        jbttnClearAll.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jbttnClearAllActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(62, 62, 62)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jLabel1)\n                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jbttnAddBall, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(18, 18, 18)\n                        .addComponent(jbttnDeleteBall, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(18, 18, 18)\n                        .addComponent(jbttnClearAll, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addContainerGap(69, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(42, 42, 42)\n                .addComponent(jLabel1)\n                .addGap(18, 18, 18)\n                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jbttnAddBall)\n                    .addComponent(jbttnDeleteBall)\n                    .addComponent(jbttnClearAll))\n                .addContainerGap(15, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>                        \n\n    private void jbttnAddBallActionPerformed(java.awt.event.ActionEvent evt) {                                             \n\n        // create a ball\n        Ball aball = new Ball();\n\n        // ball characteristics\n        aball.setVisible(true);\n        aball.setRadius(RNG.nextInt(40) + 10);\n        aball.setBallspeed(RNG.nextInt(50) + 5);\n        aball.setCompHeight(jPanel1.getHeight());\n        aball.setCompWidth(jPanel1.getWidth());\n        aball.setXpos(1);\n        aball.setYpos(1);\n        aball.setSlopeRun(RNG.nextInt(10) + 1);\n        aball.setSlopeRise(RNG.nextInt(10));\n        aball.setBallColor(new Color(RNG.nextInt(256),\n                RNG.nextInt(256), RNG.nextInt(256)));\n\n        // area where we bounce the balls\n        //aball.setSize(jPanel1.getWidth(), jPanel1.getHeight());\n        aball.setSize(2 * radius, 2 * radius);\n\n        // add the ball to the panel\n        jPanel1.add(aball);\n        alBalls.add(aball);\n\n       // aball.startBall();\n\n        if (!TimerStatus) {\n            PanelClock();\n            TimerStatus = true;\n        }\n    }                                            \n\n    private void jbttnDeleteBallActionPerformed(java.awt.event.ActionEvent evt) {                                                \n\n        try {\n\n            // uncomment to remove the last ball added\n            //    jPanel1.remove(jPanel1.getComponentCount() - 1);\n            \n            // remove first ball added\n            jPanel1.remove(alBalls.get(0));\n            alBalls.remove(0);\n            \n            jPanel1.repaint();\n\n        } catch (Exception e) {\n        }\n\n\n    }                                               \n\n    private void jbttnClearAllActionPerformed(java.awt.event.ActionEvent evt) {                                              \n        \n        // Remove all balls from the pannel\n        jPanel1.removeAll();\n        \n        // Reset the arraylist\n        alBalls.clear();\n       \n        \n    }                                             \n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String args[]) {\n        /* Set the Nimbus look and feel */\n        //<editor-fold defaultstate=\"collapsed\" desc=\" Look and feel setting code (optional) \">\n        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.\n         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html \n         */\n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"Nimbus\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        //</editor-fold>\n\n        /* Create and display the form */\n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new Frame1().setVisible(true);\n            }\n        });\n    }\n\n    // Variables declaration - do not modify                     \n    private javax.swing.JLabel jLabel1;\n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JButton jbttnAddBall;\n    private javax.swing.JButton jbttnClearAll;\n    private javax.swing.JButton jbttnDeleteBall;\n    // End of variables declaration                   \n}\n\n\n","type":"content","url":"/xbounce#frame1-java","position":5},{"hierarchy":{"lvl1":"Bounce Balls Animation","lvl2":"BALL"},"type":"lvl2","url":"/xbounce#ball","position":6},{"hierarchy":{"lvl1":"Bounce Balls Animation","lvl2":"BALL"},"content":"/*\nBounce Balls\nProgrammer: James Goudy\nRev: April, 2024\n */\npackage j2_bounce_rev24;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.Random;\nimport javax.swing.JComponent;\nimport javax.swing.Timer;\n\n/**\n *\n * @author jgoudy\n */\npublic class Ball extends JComponent {\n\n    // private members\n    // position of the ball\n    int xpos = 1;\n    int ypos = 1;\n\n    // direction of the ball - forward or backwards\n    int xdir = 1;\n    int ydir = 1;\n\n    // size of the panel: these are going to be defaults\n    int compWidth = 500;\n    int compHeight = 500;\n\n    // angle of the ball\n    int slopeRun = 1;\n    int slopeRise = 1;\n\n    // speed\n    int ballspeed = 2;\n\n    // radius of the ball\n    int radius = 25;\n\n    // Timer\n    Timer bTimer;\n\n    // ball color\n    Color ballColor;\n\n    Random RNG;\n\n    boolean wasReversed = false;\n\n    //-------------------------------------------------------\n    \n    // Constructor\n    public Ball() {\n\n        RNG = new Random();\n        ballColor = Color.blue;\n\n    }\n\n    // Setters\n    public void setXpos(int xpos) {\n        this.xpos = xpos;\n    }\n\n    public void setYpos(int ypos) {\n        this.ypos = ypos;\n    }\n\n    public int getXpos() {\n        return xpos;\n    }\n\n    public int getYPos() {\n        return ydir;\n    }\n\n\n    //-------------------------------------------------------\n    \n    public void setCompWidth(int compWidth) {\n        this.compWidth = compWidth - (radius);\n    }\n\n    public void setCompHeight(int compHeight) {\n        this.compHeight = compHeight - (radius);\n    }\n\n    public void setSlopeRun(int slopeRun) {\n        this.slopeRun = slopeRun;\n    }\n\n    public void setSlopeRise(int slopeRise) {\n        this.slopeRise = slopeRise;\n    }\n\n    public int getSlopeRise() {\n        return slopeRise;\n    }\n\n    public void setBallspeed(int ballspeed) {\n        this.ballspeed = ballspeed;\n    }\n\n    public void setRadius(int radius) {\n        this.radius = radius;\n    }\n\n    public void setBallColor(Color ballColor) {\n        this.ballColor = ballColor;\n    }\n\n    //-------------------------------------------------------\n    \n    // Draw the ball\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n\n        g.setColor(Color.white);\n\n        // un comment below to visualize the bounding box\n        //g.fillRect(0, 0, radius, radius);\n        g.setColor(ballColor);\n        g.fillOval(0, 0, radius, radius);\n    }\n\n    \n    //-------------------------------------------------------\n    \n    public void moveBall() {\n\n        // check for collision on the left and right of the panel\n        if (xpos > compWidth) {\n            xdir = xdir * -1;\n            xpos = compWidth - 1 - (radius);\n        } else if (xpos < -1) {\n            xdir = xdir * -1;\n            xpos = 0 + (RNG.nextInt(10));\n        }\n\n        // check for collision on the top and bottom of the panel\n        if (ypos > compHeight) {\n            ydir = ydir * -1;\n            ypos = compHeight - 1 - (radiu);\n        } else if (ypos < -1) {\n            ydir = ydir * -1;\n            ypos = 0 + (RNG.nextInt(10));\n        }\n\n        //System.out.println(radius);\n        // increment the x and y positions\n        ypos = ypos + (ydir * slopeRise);\n        xpos = xpos + (xdir * slopeRun);\n\n        // System.out.println(xpos + \" \" + ypos);\n    }\n\n    //-------------------------------------------------------\n    \n    \n    //--- USED IF COLLISION IS PROGRAMMED ON FRAME 1---------\n    \n    // Used for collision if frame 1 is coded for collision\n    public boolean getWasReversed() {\n        return wasReversed;\n    }\n\n    public void setWasReversed() {\n        this.wasReversed = true;\n    }\n\n    public void resetWasReversed() {\n        this.wasReversed = false;\n    }\n    \n    public void reverse() {\n\n        xdir = xdir * -1;\n        ydir = ydir * -1;\n\n    }\n\n}\n","type":"content","url":"/xbounce#ball","position":7},{"hierarchy":{"lvl1":"Bounce With Collision"},"type":"lvl1","url":"/xbouncewithcollision","position":0},{"hierarchy":{"lvl1":"Bounce With Collision"},"content":"","type":"content","url":"/xbouncewithcollision","position":1},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Introduction"},"type":"lvl2","url":"/xbouncewithcollision#introduction","position":2},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Introduction"},"content":"This Java program creates a graphical window where you can add multiple colored balls. These balls move around within a defined area, bouncing realistically off the edges of that area. Crucially, the balls also detect collisions with each other and bounce off one another. You can add new balls, delete the oldest ball, or clear all balls from the screen using the provided buttons\n\nObject-Oriented Programming (OOP): Demonstrates class design (Ball, Frame1), encapsulation (hiding data in Ball with getters/setters), inheritance (Ball extends JComponent, Frame1 extends JFrame), polymorphism (paintComponent override), and object interaction (Frame1 managing Ball objects).\n\nGUI Programming (Java Swing): Shows use of standard components (JFrame, JPanel, JButton), creating custom visual components (Ball), handling events (ActionListener for timer/buttons), custom drawing (paintComponent), and layout management (absolute positioning).\n\nAnimation and Timing: Uses javax.swing.Timer for the animation loop, manages object state changes over time, and uses repaint() to update the display visually.\n\nCollision Detection & Simple Physics: Implements boundary checking (wall bouncing), object-to-object collision detection (distance check), and collision response (swapping vectors, resolving overlap).\n\nData Structures: Utilizes ArrayList to manage a dynamic collection of Ball objects and demonstrates iterating over collections.","type":"content","url":"/xbouncewithcollision#introduction","position":3},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Frame Class"},"type":"lvl2","url":"/xbouncewithcollision#frame-class","position":4},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Frame Class"},"content":"\npackage j2_bounce_rev25_collision;\n\nimport j2_bounce_rev25_collision.Ball;\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport javax.swing.Timer;\n\n/*\nBounce Balls\nProgrammer: James Goudy\nRev: April, 2024 / Modified: 4/2025 for inter-ball collision\n */\n\npublic class Frame1 extends javax.swing.JFrame {\n\n        // Global Variables\n    Timer panelTimer;  //this will control the repaint of the panel\n    boolean TimerStatus;\n\n\n    Random RNG = new Random();\n    // Setup to show one can instantiate an object later\n    // Random RNG2; // RNG2 seems unused, consider removing\n\n\n    // initial ball info (defaults for adding balls)\n    // int x = 1; // No longer needed here\n    // int y = 1; // No longer needed here\n    // int radius = 25; // Default radius used below\n\n\n    // Timer Tick speed (delay in milliseconds)\n    int clockTick = 20; // Reduced for smoother animation\n\n    // Arraylist to hold the balls\n    ArrayList<Ball> alBalls = new ArrayList<>(); // Use diamond operator\n\n    \n    \n    \n    /**\n     * Creates new form Frame1\n     */\n    public Frame1()\n    {\n        initComponents();\n        \n                TimerStatus = false;\n        // RNG2 = new Random(); // Unused\n\n        this.setLocationRelativeTo(null);\n        this.setTitle(\"Bouncing Balls with Collision\"); // Set a title\n    }\n    \n        private void PanelClock() {\n            \n            \n            panelTimer = new Timer(clockTick, new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent e)\n                {\n\n\n                // 1. Move all balls (calculate next position based \n                //    on velocity and wall collision)\n                for (Ball ball : alBalls) {\n                    ball.moveBall();\n                }\n\n                // 2. Check for and handle collisions between balls\n                for (int i = 0; i < alBalls.size(); i++) {\n                    for (int j = i + 1; j < alBalls.size(); j++) {\n                        Ball ball1 = alBalls.get(i);\n                        Ball ball2 = alBalls.get(j);\n\n                        if (ball1.collidesWith(ball2)) {\n                            // Collision detected!\n                            // Resolve overlap first to prevent sticking\n                            ball1.resolveCollision(ball2);\n                            // Swap movement vectors for a simple bounce effect\n                            ball1.swapMovement(ball2);\n\n                            // Alternative: Simple reverse (less realistic)\n                            // ball1.reverse();\n                            // ball2.reverse();\n                        }\n                    }\n                }\n\n\n                // 3. Update the visual location of each ball component on the panel\n                // Use the calculated xpos/ypos which are now adjusted for collisions\n                for (Ball ballComponent : alBalls) {\n                    // Ball IS the component, just set its location\n                    ballComponent.setLocation(ballComponent.getXpos(), ballComponent.getYpos());\n                }\n\n\n                // 4. Repaint the panel to show updated ball positions\n                // Note: Repainting the panel itself might not be enough if balls are separate components.\n                // Repainting each ball or the container might be necessary depending on Swing's behavior.\n                // Calling revalidate() and repaint() on the container (jPanel1) is generally robust.\n                 //jPanel1.revalidate(); // Recalculate layout if sizes changed (e.g., radius)\n                 jPanel1.repaint();    // Redraw the panel and its children\n\n                // panelTimer.setDelay(20); // Delay is set when creating the timer\n            }           \n            });\n\n        panelTimer.start();\n\n    }\n    \n\n    /**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">                          \n    private void initComponents()\n    {\n\n        jPanel1 = new javax.swing.JPanel();\n        jbttnAddBall = new javax.swing.JButton();\n        jbttnDelete = new javax.swing.JButton();\n        jbttnClear = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 600, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 317, Short.MAX_VALUE)\n        );\n\n        jbttnAddBall.setText(\"Add\");\n        jbttnAddBall.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnAddBallActionPerformed(evt);\n            }\n        });\n\n        jbttnDelete.setText(\"Delete\");\n        jbttnDelete.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnDeleteActionPerformed(evt);\n            }\n        });\n\n        jbttnClear.setText(\"Clear\");\n        jbttnClear.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnClearActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(39, 39, 39)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jbttnAddBall, javax.swing.GroupLayout.PREFERRED_SIZE, 88, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(33, 33, 33)\n                        .addComponent(jbttnDelete, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(27, 27, 27)\n                        .addComponent(jbttnClear, javax.swing.GroupLayout.PREFERRED_SIZE, 88, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(99, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(41, 41, 41)\n                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(31, 31, 31)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(jbttnAddBall)\n                    .addComponent(jbttnDelete)\n                    .addComponent(jbttnClear))\n                .addContainerGap(42, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>                        \n\n    private void jbttnClearActionPerformed(java.awt.event.ActionEvent evt)                                           \n    {                                               \n        // Stop the timer if it's running\n        if (TimerStatus) {\n            panelTimer.stop();\n            TimerStatus = false;\n        }\n\n        // Remove all ball components from the panel\n        jPanel1.removeAll();\n\n        // Clear the list of balls\n        alBalls.clear();\n\n        // Repaint the empty panel\n        //jPanel1.revalidate();\n        jPanel1.repaint();\n\n\n    }                                          \n\n    private void jbttnDeleteActionPerformed(java.awt.event.ActionEvent evt)                                            \n    {                                                \n        // Remove the first ball added (FIFO)\n        if (!alBalls.isEmpty()) {\n            Ball ballToRemove = alBalls.remove(0); // Remove from list first\n            jPanel1.remove(ballToRemove); // Then remove component from panel\n            //jPanel1.revalidate();\n            jPanel1.repaint();\n        }\n\n        // Stop timer if no balls left\n        if (alBalls.isEmpty() && TimerStatus) {\n            panelTimer.stop();\n            TimerStatus = false;\n        }\n    }                                           \n\n    private void jbttnAddBallActionPerformed(java.awt.event.ActionEvent evt)                                             \n    {                                                 \n        // create a ball\n        Ball aball = new Ball();\n        int r = RNG.nextInt(25) + 10; // Radius between 10 and 34\n        aball.setRadius(r);\n\n        // Set boundaries based on panel size *and* ball radius\n        aball.setCompHeight(jPanel1.getHeight());\n        aball.setCompWidth(jPanel1.getWidth());\n\n        // Set initial position randomly within bounds (considering radius)\n        aball.setXpos(RNG.nextInt(jPanel1.getWidth() - 2 * r));\n        aball.setYpos(RNG.nextInt(jPanel1.getHeight() - 2 * r));\n\n        // ball characteristics\n        aball.setVisible(true);\n        // aball.setBallspeed(RNG.nextInt(50) + 5); // Speed not directly used in movement yet\n        aball.setSlopeRun(RNG.nextInt(5) + 1);  // Keep slopes reasonable\n        aball.setSlopeRise(RNG.nextInt(5) + 1); // Ensure non-zero rise initially\n        aball.setXDir(RNG.nextBoolean() ? 1 : -1); // Random initial direction\n        aball.setYDir(RNG.nextBoolean() ? 1 : -1); // Random initial direction\n\n        aball.setBallColor(new Color(RNG.nextInt(256),\n                RNG.nextInt(256), RNG.nextInt(256)));\n\n        // Set the component's bounds (position and size)\n        // Position is set via setLocation in the timer loop\n        // Size is set implicitly by setRadius -> setSize\n        aball.setSize(aball.getRadius() * 2, aball.getRadius() * 2);\n\n        // add the ball component to the panel and the list\n        // Ensure Null Layout is set on jPanel1 in the designer or code for absolute positioning\n        jPanel1.setLayout(null); // Make sure layout is null\n        jPanel1.add(aball);\n        alBalls.add(aball);\n\n        // Start the master timer if it's not running\n        if (!TimerStatus) {\n            PanelClock();\n            TimerStatus = true;\n        }\n\n        jPanel1.repaint(); // Repaint after adding\n    }                                            \n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String args[])\n{\n    /* Set the Nimbus look and feel */\n    //<editor-fold defaultstate=\"collapsed\" desc=\" Look and feel setting code (optional) \">\n    /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.\n         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html \n     */\n    try {\n        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n            if (\"Nimbus\".equals(info.getName())) {\n                javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                break;\n            }\n        }\n    } catch (ClassNotFoundException ex) {\n        java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    } catch (InstantiationException ex) {\n        java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    } catch (IllegalAccessException ex) {\n        java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n        java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n    }\n    //</editor-fold>\n\n    /* Create and display the form */\n    java.awt.EventQueue.invokeLater(new Runnable() {\n        public void run()\n        {\n            new Frame1().setVisible(true);\n        }\n    });\n}\n\n    // Variables declaration - do not modify                     \n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JButton jbttnAddBall;\n    private javax.swing.JButton jbttnClear;\n    private javax.swing.JButton jbttnDelete;\n    // End of variables declaration                   \n}\n\n\nOkay, let’s look at the Frame1.java code. If Ball.java is the blueprint for a single bouncing ball, then Frame1.java is like the director and the stage for the whole show.\n\nThink of it as the main program window you see and interact with. Here’s what it does, step-by-step, for a freshman CS student:\n\nIt’s the Main Window: The line public class Frame1 extends javax.swing.JFrame means Frame1 defines the main window of your application. JFrame is Java’s standard class for creating windows with borders, title bars, close buttons, etc.\n\nSets Up the Stage:\n\nInside Frame1, there’s a jPanel1. This is a blank panel within the window, acting as the “stage” or container where the balls will actually bounce around.\n\nThe initComponents() method (usually auto-generated by GUI builders like NetBeans) sets up this panel, along with the buttons (“Add Ball”, “Delete Ball”, “Clear All”) and the title label (“Bounce”). It arranges them visually within the Frame1 window.\n\nKeeps Track of the Balls: It uses an ArrayList<Ball> alBalls = new ArrayList();. An ArrayList is just a flexible list that can grow or shrink. Frame1 uses this list to keep track of every single Ball object that is currently active in the animation.\n\nHandles User Actions:\n\nWhen you click the “Add Ball” button, the jbttnAddBallActionPerformed method runs. It creates a new Ball object (using the Ball blueprint), gives it random properties (size, color, speed, starting position), adds this new ball to the alBalls list, and physically places the ball component onto the jPanel1 stage.\n\nSimilarly, jbttnDeleteBallActionPerformed removes a ball from the list and the stage, and jbttnClearAllActionPerformed removes all of them.\n\nManages the Animation (The Heartbeat):\n\nThis is the most important part!\n\nFrame1 has a Timer panelTimer. Think of this as a metronome or a heartbeat for the animation. It “ticks” at regular intervals (every clockTick milliseconds).\n\nThe PanelClock() method sets up and starts this timer.\n\nEvery time the timer ticks\n\n, the code inside theactionPerformed\n\nmethod runs. This is the animation loop:\n\nTell Balls to Move: It goes through the alBalls list and tells each ball to run its moveBall() method. This updates each ball’s internal position and handles bouncing off the walls.\n\nCheck for Ball Collisions: It then uses nested loops to check every possible pair of balls in the list. For each pair, it asks if (ball1.collidesWith(ball2)). If they are colliding, it calls methods (resolveCollision, swapMovement) to make them bounce off each other realistically.\n\nUpdate the Screen: After calculating all the new positions (including adjustments from collisions), it goes through the list again. For each ball, it calls ballComponent.setLocation(x, y) to visually move the ball component to its new coordinates on jPanel1.\n\nRedraw: Finally, it calls jPanel1.repaint(). This tells the Java graphical system, “Okay, I’ve moved everything, now redraw the panel (and all the balls on it) so the user sees the changes.”\n\nStarts the Program: The public static void main(String args[]) method is the universal starting point for any Java application. Its job here is simply to create the Frame1 window and make it visible on your computer screen.\n\nIn Simple Terms:\n\nFrame1 is the manager. It sets up the window and the bouncing area (jPanel1). It keeps a list of all the balls. It responds to button clicks to add or remove balls. Most importantly, it runs a timer that acts as the animation’s heartbeat. On each heartbeat, it tells all the balls to move, checks if they bump into each other, updates their visual positions on the screen, and redraws everything.","type":"content","url":"/xbouncewithcollision#frame-class","position":5},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Ball Class"},"type":"lvl2","url":"/xbouncewithcollision#ball-class","position":6},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Ball Class"},"content":"\npackage j2_bounce_rev25_collision;\n\n/*\nBounce Balls\nProgrammer: James Goudy\nRev: April, 2024 / Modified: 4/2025 for inter-ball collision\n */\n\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.Random;\nimport javax.swing.JComponent;\nimport javax.swing.Timer;\n\nimport java.awt.Color;\n\nimport java.util.Random;\n\nimport java.awt.Color;\n\nimport java.util.Random;\n\n/**\n *\n * @author jgoudy\n */\npublic class Ball extends JComponent {\n\n    // private members\n    // position of the ball (top-left corner)\n    int xpos = 1;\n    int ypos = 1;\n\n    // direction of the ball - forward or backwards\n    int xdir = 1;\n    int ydir = 1;\n\n    // size of the panel: these are going to be defaults\n    // Note: compWidth and compHeight will now represent the maximum center x/y coordinates\n    int compWidth = 500;\n    int compHeight = 500;\n\n    // angle of the ball (movement step size)\n    int slopeRun = 1;\n    int slopeRise = 1;\n\n    // speed (not currently used in movement logic, but kept for potential future use)\n    int ballspeed = 2;\n\n    // radius of the ball\n    int radius = 25;\n\n    // Timer (seems unused within Ball class itself, consider removing if not needed here)\n    // Timer bTimer;\n\n    // ball color\n    Color ballColor;\n\n    Random RNG;\n\n    // boolean wasReversed = false; // Removed as collision logic is moved to Frame1\n\n    //-------------------------------------------------------\n    // Constructor\n    public Ball() {\n        RNG = new Random();\n        ballColor = Color.blue;\n        // Set component size based on radius for drawing\n        this.setSize(radius * 2, radius * 2);\n        this.setPreferredSize(this.getSize()); // Important for layout managers\n    }\n\n    // Setters\n    public void setXpos(int xpos) {\n        // Ensure xpos stays within bounds if set externally\n        this.xpos = Math.max(0, Math.min(xpos, compWidth - radius));\n    }\n\n    public void setYpos(int ypos) {\n        // Ensure ypos stays within bounds if set externally\n        this.ypos = Math.max(0, Math.min(ypos, compHeight - radius));\n    }\n\n    // Getters for position (top-left)\n    public int getXpos() {\n        return xpos;\n    }\n\n    public int getYpos() { // Corrected method name from getYPos to getYpos\n        return ypos;\n    }\n\n    // Getters for Center Coordinates\n    public int getCenterX() {\n        return xpos + radius;\n    }\n\n    public int getCenterY() {\n        return ypos + radius;\n    }\n\n\n    //-------------------------------------------------------\n    // Setters for component bounds (adjust based on radius)\n    public void setCompWidth(int containerWidth) {\n         // Max center x-coordinate is container width minus radius\n        this.compWidth = containerWidth - radius;\n    }\n\n    public void setCompHeight(int containerHeight) {\n        // Max center y-coordinate is container height minus radius\n        this.compHeight = containerHeight - radius;\n    }\n\n    // Setters and Getters for movement properties\n    public void setSlopeRun(int slopeRun) {\n        this.slopeRun = slopeRun;\n    }\n\n    public int getSlopeRun() {\n        return slopeRun;\n    }\n\n    public void setSlopeRise(int slopeRise) {\n        this.slopeRise = slopeRise;\n    }\n\n    public int getSlopeRise() {\n        return slopeRise;\n    }\n\n    public void setBallspeed(int ballspeed) {\n        this.ballspeed = ballspeed;\n    }\n\n    public int getBallspeed() { // Added getter\n        return ballspeed;\n    }\n\n    public void setRadius(int radius) {\n        this.radius = radius;\n        // Update component size when radius changes\n        this.setSize(radius * 2, radius * 2);\n        this.setPreferredSize(this.getSize());\n    }\n\n    public int getRadius() { \n        return this.radius;\n    }\n\n    public void setBallColor(Color ballColor) {\n        this.ballColor = ballColor;\n    }\n\n    public Color getBallColor() { \n        return ballColor;\n    }\n\n    public int getXDir() {\n        return xdir;\n    }\n\n    public void setXDir(int xdir) {\n        this.xdir = xdir;\n    }\n\n    public int getYDir() {\n        return ydir;\n    }\n\n    public void setYDir(int ydir) {\n        this.ydir = ydir;\n    }\n\n    //-------------------------------------------------------\n    // Draw the ball\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        // Graphics context is relative to the component's top-left corner (0,0)\n        g.setColor(ballColor);\n        // Draw the oval filling the component bounds\n        g.fillOval(0, 0, radius * 2, radius * 2);\n    }\n\n    //-------------------------------------------------------\n    public void moveBall() {\n        // Calculate next potential center position\n        int nextCenterX = getCenterX() + (xdir * slopeRun);\n        int nextCenterY = getCenterY() + (ydir * slopeRise);\n\n        // Check for collision on the left and right walls based on center position\n        if (nextCenterX > compWidth) { // Hit right wall\n            xdir *= -1;\n            // Adjust position to be exactly at the boundary to avoid overshooting\n            xpos = compWidth - radius;\n        } else if (nextCenterX < radius) { // Hit left wall\n             xdir *= -1;\n             // Adjust position to be exactly at the boundary\n             xpos = 0;\n        }\n\n        // Check for collision on the top and bottom walls based on center position\n        if (nextCenterY > compHeight) { // Hit bottom wall\n            ydir *= -1;\n            // Adjust position to be exactly at the boundary\n            ypos = compHeight - radius;\n        } else if (nextCenterY < radius) { // Hit top wall\n             ydir *= -1;\n             // Adjust position to be exactly at the boundary\n             ypos = 0;\n        }\n\n        // Update the position (top-left corner) based on direction and slope\n        // Use the potentially updated directions\n        xpos += (xdir * slopeRun);\n        ypos += (ydir * slopeRise);\n\n        // Ensure position doesn't go out of bounds after adjustment (safety check)\n        xpos = Math.max(0, Math.min(xpos, compWidth - radius));\n        ypos = Math.max(0, Math.min(ypos, compHeight - radius));\n    }\n\n     //-------------------------------------------------------\n    // Method to reverse direction (can be used for simple collision response)\n    public void reverse() {\n        xdir *= -1;\n        ydir *= -1;\n    }\n\n    // Method to swap movement vectors with another ball\n    public void swapMovement(Ball other) {\n        int tempXDir = this.xdir;\n        int tempYDir = this.ydir;\n        int tempSlopeRun = this.slopeRun;\n        int tempSlopeRise = this.slopeRise;\n\n        this.setXDir(other.getXDir());\n        this.setYDir(other.getYDir());\n        this.setSlopeRun(other.getSlopeRun());\n        this.setSlopeRise(other.getSlopeRise());\n\n        other.setXDir(tempXDir);\n        other.setYDir(tempYDir);\n        other.setSlopeRun(tempSlopeRun);\n        other.setSlopeRise(tempSlopeRise);\n    }\n\n    // Method to check collision with another ball\n    public boolean collidesWith(Ball other) {\n        if (this == other) { // A ball cannot collide with itself\n            return false;\n        }\n\n        int dx = this.getCenterX() - other.getCenterX();\n        int dy = this.getCenterY() - other.getCenterY();\n        // Use distance squared to avoid expensive square root calculation\n        double distanceSq = dx * dx + dy * dy;\n\n        int sumRadii = this.radius + other.radius;\n        double sumRadiiSq = sumRadii * sumRadii;\n\n        return distanceSq < sumRadiiSq;\n    }\n\n     // Method to resolve collision by slightly moving balls apart\n     // This helps prevent balls from sticking together\n     public void resolveCollision(Ball other) {\n         int dx = this.getCenterX() - other.getCenterX();\n         int dy = this.getCenterY() - other.getCenterY();\n         double distance = Math.sqrt(dx * dx + dy * dy);\n         int sumRadii = this.radius + other.radius;\n\n         // Calculate overlap amount\n         double overlap = sumRadii - distance;\n\n         if (overlap > 0 && distance > 0) { // Check distance > 0 to avoid division by zero\n             // Calculate normalized direction vector (dx/distance, dy/distance)\n             double moveX = (dx / distance) * (overlap / 2.0); // Move each ball by half the overlap\n             double moveY = (dy / distance) * (overlap / 2.0);\n\n             // Update positions (move them apart along the collision axis)\n             // Ensure positions stay within bounds\n             this.xpos = Math.max(0, Math.min(this.compWidth - this.radius, (int)(this.xpos + moveX)));\n             this.ypos = Math.max(0, Math.min(this.compHeight - this.radius, (int)(this.ypos + moveY)));\n\n             other.xpos = Math.max(0, Math.min(other.compWidth - other.radius, (int)(other.xpos - moveX)));\n             other.ypos = Math.max(0, Math.min(other.compHeight - other.radius, (int)(other.ypos - moveY)));\n         } else if (distance == 0) {\n             // If balls are exactly on top of each other, move one randomly\n             this.xpos = Math.max(0, Math.min(this.compWidth - this.radius, this.xpos + RNG.nextInt(3) - 1));\n             this.ypos = Math.max(0, Math.min(this.compHeight - this.radius, this.ypos + RNG.nextInt(3) - 1));\n         }\n     }\n}\n\n\nOkay, let’s break down the Ball.java code. Imagine you’re building a simple game or animation with bouncing balls on the screen. This Ball.java file acts as the blueprint for creating each individual ball object.\n\nThink of it like this: Ball.java is the recipe, and every time you follow the recipe (create a new Ball()), you get an actual ball that can be put onto the screen (the JPanel in Frame1.java).\n\nHere’s a summary of what the Ball class does, explained simply:\n\nIt’s a Visual Thing: The class Ball extends JComponent. In Java’s Swing library (used for creating graphical user interfaces), a JComponent is basically something you can see on the screen. So, every Ball object is a visual component.\n\nKnows Its Properties:\n\nEach ball object keeps track of its own information:\n\nPosition: xpos, ypos store the coordinates (like on a graph) of the ball’s top-left corner within its container panel.\n\nSize: radius determines how big the ball is.\n\nColor: ballColor stores the ball’s color.\n\nMovement Direction: xdir and ydir tell the ball if it’s currently moving left/right (xdir is 1 for right, -1 for left) and up/down (ydir is 1 for down, -1 for up).\n\nSpeed/Angle: slopeRun and slopeRise determine how many pixels the ball moves horizontally and vertically in each step. Changing these changes the ball’s speed and angle.\n\nBoundaries: compWidth and compHeight store the width and height of the area the ball is allowed to bounce within.\n\nCan Draw Itself: The paintComponent(Graphics g) method is like the ball’s instruction manual for drawing itself. When the program needs to display the ball, it calls this method, which draws a filled oval using the ball’s current ballColor and radius.\n\nKnows How to Move:\n\nThe moveBall()  method contains the logic for updating the ball’s position in each frame or time step.\n\nIt first checks if the ball is about to hit one of the edges (walls) of its container panel. It does this by looking ahead at where the ball’s center will be in the next step.\n\nIf it detects a wall hit, it reverses the corresponding direction (xdir or ydir) so the ball “bounces” off. It also adjusts the position slightly to prevent the ball from going slightly past the wall.\n\nFinally, it updates the xpos and ypos based on the current direction (xdir, ydir) and speed/angle (slopeRun, slopeRise).\n\nKnows How to Interact with Other Balls:\n\ncollidesWith(Ball other): This method checks if this ball is currently overlapping with another ball (other). It calculates the distance between their centers and compares it to the sum of their radii. If the distance is smaller, they’ve collided.\n\nswapMovement(Ball other): This is one way to handle a collision. It makes the two colliding balls swap their direction and speed/angle variables. It’s a simple way to simulate a bounce between them.\n\nresolveCollision(Ball other): Sometimes, when balls collide, they might get stuck together slightly. This method gently pushes the two colliding balls apart just enough so they aren’t overlapping anymore, making the collision look smoother.\n\nCan Change Its Properties: The class includes many “getter” (like getRadius(), getCenterX()) and “setter” (like setRadius(int r), setBallColor(Color c)) methods. These allow other parts of the program (like Frame1.java) to get information about a ball or change its properties after it’s been created.\n\nIn a Nutshell:\n\nThe Ball.java class defines everything a single ball needs to know and do: its appearance (size, color), its position, how to move, how to bounce off walls, and how to detect and react to collisions with other balls. It’s a self-contained blueprint for creating individual, interactive ball objects that can be managed and animated by another class like Frame1.","type":"content","url":"/xbouncewithcollision#ball-class","position":7},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Coding and Computer Science Concepts"},"type":"lvl2","url":"/xbouncewithcollision#coding-and-computer-science-concepts","position":8},{"hierarchy":{"lvl1":"Bounce With Collision","lvl2":"Coding and Computer Science Concepts"},"content":"If you were using this code in a freshman computer science course, it would effectively highlight several important coding techniques and concepts:\n\nObject-Oriented Programming (OOP):\n\nClass Design: Demonstrates how to define classes (Ball, Frame1) to represent real-world concepts or application components.\n\nEncapsulation: The Ball class hides its internal state (like xpos, ypos, radius) and provides controlled access through getter and setter methods.\n\nInheritance: Shows how classes can inherit properties and behaviors from parent classes (Ball extends JComponent, Frame1 extends JFrame). Ball inherits the ability to be a visual component, and Frame1 inherits the features of a standard window.\n\nPolymorphism: The Ball class overrides the paintComponent method inherited from JComponent to provide its specific drawing behavior.\n\nObject Interaction: Frame1 creates and manages multiple Ball objects, storing them in a list and calling their methods (moveBall, collidesWith, etc.), demonstrating how objects collaborate.\n\nGUI Programming (using Java Swing):\n\nComponents: Introduces basic GUI elements like windows (JFrame), panels (JPanel), and buttons (JButton).\n\nCustom Components: Shows how to create a custom visual component (Ball) by extending JComponent and implementing custom drawing logic.\n\nEvent Handling: Uses ActionListener to respond to events, specifically timer ticks (panelTimer) for animation and button clicks (jbttnAddBall, etc.) for user interaction.\n\nDrawing: Demonstrates basic 2D drawing using the Graphics object within paintComponent (drawing ovals).\n\nLayout Management: Uses absolute positioning (setLayout(null)) within jPanel1 to place the balls at specific coordinates.\n\nAnimation and Timing:\n\nTimers: Employs javax.swing.Timer to create a discrete animation loop, triggering updates at regular intervals.\n\nState Management: Shows how the state of objects (Ball positions and directions) is updated over time within the timer’s event handler.\n\nRepainting: Highlights the necessity of calling repaint() to refresh the display and show the updated state after changes have been made.\n\nCollision Detection and Simple Physics:\n\nBoundary Checking: Implementing logic to detect when an object hits the edge of its container (moveBall checking against compWidth, compHeight).\n\nObject Interaction Logic: Developing algorithms to detect collisions between multiple objects (collidesWith using distance formula).\n\nCollision Response: Implementing simple reactions to collisions (reversing direction for walls, swapping vectors for ball-ball collisions).\n\nData Structures:\n\nCollections: Uses ArrayList (alBalls) to store and manage a variable number of Ball objects, demonstrating dynamic data structures.\n\nIteration: Shows how to iterate over collections (the ArrayList) to process each object (e.g., moving each ball, checking collisions).\n\nThese techniques provide a practical context for understanding core CS concepts beyond basic syntax, connecting OOP, algorithms (collision detection), data structures, and event-driven programming within a visual application.","type":"content","url":"/xbouncewithcollision#coding-and-computer-science-concepts","position":9},{"hierarchy":{"lvl1":"Building A String Using Combo, Lists, and Textfield"},"type":"lvl1","url":"/xbuildingstrings","position":0},{"hierarchy":{"lvl1":"Building A String Using Combo, Lists, and Textfield"},"content":"/*\nDeveloper: James Goudy\n\nThe provided Java program defines a simple GUI application using \nthe Swing framework. The application displays several user interface \ncomponents such as a JTextField, JComboBox, JList, JTextArea, and \nJButton within a main JFrame. Each component is positioned manually \nusing absolute positioning, as the layout manager is set to null. \nThe application demonstrates how to build a concatenated string from \nvarious form elements, then display that result in a multi-line text area.\n\n\n */\npackage j2_textfield_combo_list_buildstring;\n\n//import java.awt.List;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.util.List;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport javax.swing.DefaultListModel;\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuItem;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\nimport javax.swing.KeyStroke;\nimport javax.swing.ListSelectionModel;\n\n/**\n *\n * @author jgoudy\n */\npublic class J2_Textfield_Combo_List_BuildString {\n\n    // creating our application frame and controls\n    static JFrame       myFrame     = new JFrame();\n    static JTextField   myTextField = new JTextField();\n    static JComboBox    myCombo     = new JComboBox();\n    static JList        myList      = new JList();\n    static JButton      myButton    = new JButton();\n    static JTextArea    myTextArea  = new JTextArea();\n    static JMenuBar     myMenuBar   = new JMenuBar();\n    static JLabel       myLabel     = new JLabel();\n\n    static int xpos = 50;\n    static int ypos = 50;\n    static int spacing = 20;\n\n    public static void main(String[] args)\n    {\n        setupApp();\n\n    }\n\n    private static void setupApp()\n    {\n        // helper functions to build the \n\n        // Build the menubar first\n        // then add it to the frame\n        setupMenuBar();\n        \n        setupFrame();\n        \n        setupJLabel();\n\n        setupTextField();\n\n        setupCombo();\n\n        setupList();\n\n        setupTextArea();\n\n        setupButton();\n\n    }\n\n\n\n\n    private static void setupMenuBar(){\n\n        // Create a new \"File\" menu\n        JMenu myMenuFile = new JMenu(\"File\");\n    \n        // Create a new menu item (initially without text)\n        JMenuItem myMenuQuit = new JMenuItem();\n        \n        // Set the text label for the Quit menu item\n        myMenuQuit.setText(\"Quit\");\n        \n        // demonstrate colors\n        myMenuQuit.setBackground(Color.yellow); \n        myMenuQuit.setForeground(Color.blue);    \n        \n        // adding the keyboard shortcut\n         // Set Ctrl+Q as shortcut\n        myMenuQuit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q, \n                                            KeyEvent.CTRL_DOWN_MASK ));\n        // Exit the program when selected\n        myMenuQuit.addActionListener(e -> System.exit(0));  \n        \n        // Add the Quit item to the File menu\n        myMenuFile.add(myMenuQuit);\n                \n        // Make the menu bar visible and add the File menu to it\n        myMenuBar.setVisible(true);\n        myMenuBar.add(myMenuFile);\n        \n        // Attach the menu bar to the main application frame\n        myFrame.setJMenuBar(myMenuBar);\n    }\n    \n    \n    private static void setupFrame()\n    {\n\n        // frame size 575 x 460\n        myFrame.setSize(575, 460);\n\n        // set location\n        myFrame.setLocationRelativeTo(null);\n\n        // set visibility\n        myFrame.setVisible(true);\n\n        // set close action\n        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // layout manager\n        myFrame.setLayout(null);\n        \n        // set title\n        myFrame.setTitle(\"Building Strings\");\n        \n    }\n\n    \n    private static void setupJLabel(){\n    \n        // set text\n        myLabel.setText(\"Building Strings\");\n        \n        // set fontsize\n        // Sets the label's font to bold with size 24, \n        // retaining the original font name.\n        // Retrieves the current font name and \n        // creates a new Font object with updated style and size.\n        myLabel.setFont(new Font(myLabel.getFont().getName(),Font.BOLD,24));\n        \n        // set size\n        myLabel.setSize(200, myLabel.getFont().getSize()+ 4);\n                \n        // set visibility\n        myLabel.setVisible(true);\n        \n        // Set position\n        myLabel.setLocation(50, 10);\n        \n        // add to frame\n        myFrame.add(myLabel);\n    \n    }\n    \n    private static void setupTextField()\n    {\n\n        // size 200 x 25\n        myTextField.setSize(200, 25);\n\n        // set location\n        myTextField.setLocation(xpos, ypos);\n\n        // set visibility\n        myTextField.setVisible(true);\n\n        // add to frame\n        myFrame.add(myTextField);\n\n        ypos = ypos + 25 + spacing;\n\n    }\n\n    private static void setupCombo()\n    {\n\n        // combo items\n        String[] myItems = {\"Lions\", \"Tigers\", \"Bears\"};\n\n        //  size 200 x 25\n        myCombo.setSize(200, 25);\n\n        // set location\n        myCombo.setLocation(xpos, ypos);\n\n        // set visibility\n        myCombo.setVisible(true);\n\n        // add data\n        for (String value : myItems) {\n            myCombo.addItem(value);\n        }\n        // ALTERNATIVE WAY TO ADD DATA        \n        //        for(int i = 0; i < myItems.length; i++)\n        //        {\n        //            myCombo.addItem(myItems[i]);\n        //        }\n\n\n\n                // add to frame\n                myFrame.add(myCombo);\n\n                ypos = ypos + 25 + spacing;\n\n            }\n\n    private static void setupList()\n    {\n\n        // combo items\n        String[] myItems = {\"Planes\", \"Trains\", \"Automobiles\", \"Bikes\"};\n\n        //  size  200 x 210\n        myList.setSize(200, 210);\n\n        // set location\n        myList.setLocation(xpos, ypos);\n\n        // set visibility\n        myList.setVisible(true);\n\n        // multi select\n        myList.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n\n        // add data\n        DefaultListModel myListModel = new DefaultListModel();\n        \n        // add data\n        for (String value : myItems) {\n            myListModel.addElement(value);\n        }\n\n        myList.setListData(myItems);\n\n        // add to frame\n        myFrame.add(myList);\n\n    }\n\n    private static void setupTextArea()\n    {\n\n        //  size  200 x 260\n        myTextArea.setSize(200, 260);\n\n        // set location\n        myTextArea.setLocation(300, 90);\n\n        // set visibility\n        myTextArea.setVisible(true);\n\n        // Add to Frame\n        myFrame.add(myTextArea);\n\n    }\n\n    private static void setupButton()\n    {\n\n        // frame size 200 x 25\n        myButton.setSize(200, 25);\n\n        // set location\n        myButton.setLocation(300, 50);\n\n        // set visibility\n        myButton.setVisible(true);\n\n        // set text\n        myButton.setText(\"Create List\");\n        \n        \n        // this is the button press\n        myButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e)\n            {\n                String myString = \"\";\n                \n                // Build the string\n                myString = \"TextField: \" + myTextField.getText() + \"\\n\";\n\n                myString = myString + \"Combo: \"\n                        + myCombo.getSelectedItem() + \"\\n\";\n\n                List mySelectedItems = myList.getSelectedValuesList();\n\n                myString = myString + \"ListBox: \\n\";\n\n                for (Object value : mySelectedItems) {\n                    myString = myString + value + \"\\n\";\n                }\n\n                myTextArea.setText(myString);\n\n            }\n        });\n        \n        \n        // ALTERNATIVE Way To Add Action Listener\n        //        ActionListener myActionListener = new ActionListener() {\n        //            @Override\n        //            public void actionPerformed(ActionEvent e)\n        //            {\n        //                System.out.println(\"Hello World\");\n        //            }\n        //        };\n        //        \n        //        \n        //        myButton.addActionListener(myActionListener);\n\n\n        // add to frame\n        myFrame.add(myButton);\n\n    }\n\n}\n","type":"content","url":"/xbuildingstrings","position":1},{"hierarchy":{"lvl1":"Building Swing Controls Via Code"},"type":"lvl1","url":"/xbuildingswingcontrolsviacode","position":0},{"hierarchy":{"lvl1":"Building Swing Controls Via Code"},"content":"Building GUIs (Graphical User Interfaces) in Java – specifically, creating those buttons, text boxes, and labels directly using Java code. Think of it like giving Java precise, step-by-step instructions on how to draw your application’s interface.\n\nCreating Swing Controls via Code\n\nInstead of using a drag-and-drop visual editor, creating controls via code means you explicitly write Java statements to make each UI element.\n\nInstantiation: You first create an object of the control type you want. Just like creating any other Java object:\n\nJava// Create a button object\nJButton myButton = new JButton(\"Click Me!\");\n\n// Create a label object\nJLabel nameLabel = new JLabel(\"Name:\");\n\n// Create a text field object\nJTextField nameField = new JTextField(20); // 20 is hint for preferred width\n\nRight now, these objects exist in memory, but they aren’t visible on any window yet.\n\nAdding to a Container: Controls don’t float in space; they need to be placed inside a container. The most common containers are JFrame (the main window) and JPanel (a panel you can put inside the window, often used to group related controls).\n\nJava// Assume 'myFrame' is your JFrame (window)\n// Assume 'myPanel' is a JPanel inside the frame\nmyPanel.add(nameLabel); // Add the label to the panel\nmyPanel.add(nameField); // Add the text field to the panel\nmyPanel.add(myButton);  // Add the button to the panel\n\nmyFrame.add(myPanel); // Add the panel (with its controls) to the window\n\nNow, let’s address why we need to configure specific things:\n\nWhy Set Location/Position? (Usually via Layout Managers)\n\nNeed: Controls need to know where to appear within their container. If you just add them, how does Java know whether to put the button next to the label, below it, or somewhere else entirely?\n\nHow (The Smart Way): While you can set exact pixel coordinates (setBounds(x, y, width, height)), this is usually a bad idea. Why? Your window might be resized, or run on a computer with a different screen resolution, and your carefully placed controls will look messy or overlap.\n\nThe Better Way: Layout Managers:\n\nJava’s solution is  Layout Managers. You tell the   container  (JPanel  or  JFrame   ) which layout manager to use (e.g., FlowLayout ,BorderLayout,GridLayout ). The layout manager then automatically arranges the components you add according to its rules (e.g., FlowLayout  places them one after another like words on a line).// Tell the panel to arrange components left-to-right\nmyPanel.setLayout(new FlowLayout());\nmyPanel.add(nameLabel);\nmyPanel.add(nameField); // FlowLayout puts this next to the label\nmyPanel.add(myButton);  // And this next to the text field\n\nWhy Layout Managers are Key: They handle the positioning for you, adapting intelligently to different window sizes and making your UI much more robust and professional. So, you usually set the “location” indirectly by choosing a layout manager and the order you add components.\n\nWhy Set Visibility?\n\nNeed: Just because you’ve created a control and added it to a container doesn’t mean the user can see it yet.\n\nThe Window:   Most importantly, the main window (JFrame ) itself is invisible by default. You   must  make it visible, usually as one of the last steps:\n\nmyFrame.setVisible(true);\n\nIndividual Controls:\n\nComponents added to a visible container are usually visible by default. However, you might  want  to hide or show certain controls dynamically while the program is running. For example, maybe an “Advanced Options” panel should only appear if the user clicks a checkbox. You can control this withsetVisible(true)\n\norsetVisible(false)\n\non the specific component or panel.advancedPanel.setVisible(false); // Start hidden\n// Later, if a checkbox is clicked:\n// advancedPanel.setVisible(true);\n\nWhy: Visibility gives you control over what the user sees and when, making the interface dynamic and less cluttered.\n\nWhy Add a Listener? (When Appropriate)\n\nNeed: What should happen when the user interacts with a control? If you create a JButton, you usually want some code to run when it’s clicked. If you create a JTextField, you might want to react when the user presses Enter.\n\nEvents and Listeners: User actions (clicking, typing, etc.) generate “Events”. You write “Listener” objects that wait for specific events on specific components. When the event occurs, a method in your listener object is automatically called.\n\nExample (Button Click):\n\nThe most common listener isActionListener\n\nfor button clicks.\n\nJava// 1. Define what happens when clicked (often using a lambda expression)\nActionListener buttonAction = event -> {\n    System.out.println(\"Button was clicked!\");\n    String name = nameField.getText(); // Get text from the text field\n    nameLabel.setText(\"Hello, \" + name); // Change the label's text\n};\n\n// 2. Attach the listener to the button\nmyButton.addActionListener(buttonAction);\n\nWhy: Listeners are the link between the user’s actions and your program’s logic. Without them, your GUI controls are just static pictures – they wouldn’t do anything interactive. You add listeners when you need a control to respond to user input.\n\nIn summary: You create controls as objects, add them to containers (which use Layout Managers to handle position), make the main window visible, and add listeners to make the controls interactive. Doing it in code gives you full control and helps you understand exactly how GUIs are built.","type":"content","url":"/xbuildingswingcontrolsviacode","position":1},{"hierarchy":{"lvl1":"Combo boxes"},"type":"lvl1","url":"/xcomboboxes-rev1","position":0},{"hierarchy":{"lvl1":"Combo boxes"},"content":"","type":"content","url":"/xcomboboxes-rev1","position":1},{"hierarchy":{"lvl1":"Combo boxes","lvl2":"Major Properties and Events"},"type":"lvl2","url":"/xcomboboxes-rev1#major-properties-and-events","position":2},{"hierarchy":{"lvl1":"Combo boxes","lvl2":"Major Properties and Events"},"content":"JAVA combo boxes, also known as JComboBox in Swing is a versatile component that allow users to select a single item from a list. They offer a user-friendly way to present a set of options and improve data entry efficiency. Here are some of the major properties of a Java combo box:\n\nBasic Properties:\n\nItems: The core property of a combo box is its list of items. You can add, remove, and modify items programmatically or through a visual editor.\n\nSelected Item: The combo box always has a selected item, which is the currently chosen option displayed in the text field.\n\nJava combo box selected item\n\nEditable: You can configure the combo box to be editable or non-editable. In editable mode, users can type their own values, while non-editable mode restricts them to selecting from the predefined list.\n\nEnabled: This property determines whether the combo box is interactable or disabled (grayed out).\n\nAdvanced Properties:\n\nModel: The combo box model manages the underlying data and presentation of the items. You can use different model implementations for more complex scenarios.\n\nRenderer: The renderer controls how each item is displayed in the list. You can customize the appearance of the items using custom renderers.\n\nPopup Visible: This property controls whether the dropdown list is currently visible. You can programmatically show or hide the list.\n\nMaximum Row Count: This property limits the number of visible items in the dropdown list. If there are more items, a scrollbar appears.\n\nEvent Handling:\n\nItem Selection: When the user selects an item, a selection event is fired. You can listen to these events to react to user choices.\n\nAction Events: In editable mode, typing Enter or clicking outside the text field triggers an action event. You can use this event to capture user input.\n\nThese are just some of the major properties of Java combo boxes. By understanding and manipulating these properties, you can create flexible and user-friendly interfaces for your applications.","type":"content","url":"/xcomboboxes-rev1#major-properties-and-events","position":3},{"hierarchy":{"lvl1":"Combo boxes","lvl2":"Lecture Code Summary"},"type":"lvl2","url":"/xcomboboxes-rev1#lecture-code-summary","position":4},{"hierarchy":{"lvl1":"Combo boxes","lvl2":"Lecture Code Summary"},"content":"Overall Structure\n\nThe entry point is the main method in the J2x_20_comboBoxes class.\n\nInside main, a ComboBoxDemo object is created. That object sets up the entire GUI in its constructor.\n\nGUI Setup\nThe GUI is built using Swing components (JFrame, JLabel, JTextField, JButton, JComboBox) and a manual (absolute) layout.\n\nManual Layout\n\nThe code callsjf1.setLayout(null)\n\n, which disables the default layout managers. Each component’s size and position are set explicitly viasetSize()\n\nandsetLocation()\n\n.\n\nPros: Direct control over positioning.\n\nCons: Not easily resizable or adaptive, and can be cumbersome if the UI must scale or localize.\n\nHelper Methods\nThe constructor for ComboBoxDemo calls various private methods, each dedicated to setting up a particular type of component. This is a clean approach for readability and code reuse:\n\nsetUpTheJFrame(JFrame, int, int, String, Color, boolean)\nConfigures the JFrame size, title, background color, close operation, visibility, and layout.\n\nsetupLabel(...)\nCreates and positions a JLabel with the desired text and font size.\n\nsetupTextFields(...)\nCreates a JTextField, positions it, and sets basic properties like font and visibility.\n\nsetupCombo(...)\nInitializes the JComboBox. If a String[] is provided, all those items are added to it. It also attaches an ActionListener that updates lblSelected each time a new item is chosen.\n\nsetTheButtons(...)\nCreates a JButton with the given text, size, and location. It then attaches both an ActionListener (listening for button clicks) and a KeyListener (listening for the Enter key), both of which call a shared handler method (theButtonAction).\n\nButton Actions\nThe theButtonAction(String bttnText) method handles all the button clicks (and the Enter key on the button). The parameter bttnText is matched against the button label to determine which operation to perform. Specifically:\n\n“Add Item”\nReads text from txtField and, if non-empty, appends it to the combo box (comboBox.addItem(...)).\n\n“Remove Selected”\nRemoves the currently selected item (comboBox.removeItemAt(comboBox.getSelectedIndex())).\n\n“Remove Last”\nRemoves the last item in the combo box (comboBox.removeItemAt(comboBox.getItemCount()-1)).","type":"content","url":"/xcomboboxes-rev1#lecture-code-summary","position":5},{"hierarchy":{"lvl1":"Combo boxes","lvl2":"Lecture Code"},"type":"lvl2","url":"/xcomboboxes-rev1#lecture-code","position":6},{"hierarchy":{"lvl1":"Combo boxes","lvl2":"Lecture Code"},"content":"/*\nProgam: Combo Box\n\nFunction:   The purpose of the program is demostrate the\n            selection of a combobox, add items and subtract items,\n            of a combobox programmically\n\nProgrammer: James Goudy ©2024\n */\npackage j2x_20_comboboxes;\n\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JTextField;\n\n/**\n * Class ComboBoxDemo demonstrates a GUI with a ComboBox (drop-down list),\n * including adding, removing selected, and removing the last item.\n */\nclass ComboBoxDemo {\n\n    // This array holds the initial set of comedian names for the combo box\n    String[] comedians = {\"Larry\", \"Curly\", \"Moe\", \"Shemp\", \"Curly Joe\"};\n\n    // Create a JFrame instance for the application window\n    JFrame Frame1 = new JFrame();\n\n    // Label to prompt or describe the comedian list\n    JLabel lblComedians = new JLabel();\n    // Label to display the currently selected item from the combo box\n    JLabel lblSelected = new JLabel();\n\n    // Text field for user to type a new item to add into the combo box\n    JTextField txtField = new JTextField();\n\n    // Button to remove the currently selected item from the combo box\n    JButton bttnRemoveSelected = new JButton();\n    // Button to add a new item from the text field to the combo box\n    JButton bttnAddItem = new JButton();\n    // Button to remove the last item in the combo box\n    JButton bttnRemoveLast = new JButton();\n\n    // JComboBox to display the set of comedians and any new items\n    // the user might add\n    //JComboBox comboBox  =   new JComboBox(comedians);\n    JComboBox comboBox = new JComboBox();\n\n    /**\n     * Constructor initializes and lays out all the GUI components.\n     */\n    public ComboBoxDemo() {\n\n        float lblFontSize = 12f;\n        int xWidth = 125;\n        int aWidth = 150;\n\n        // Define a custom background color\n        Color myColor = new Color(250, 249, 246);\n        \n        // Set up the JFrame with size, title, background, etc.\n        setUpTheJFrame(Frame1, 550, 300, \"Combobox Demo!\", \n                       myColor , true);\n\n        // Set up labels, combo box, text field, and buttons\n        setupLabel(Frame1, lblSelected, 100, 25,150, \"Selected\", lblFontSize);\n        setupLabel(Frame1, lblComedians, 20, 50, 150, \"Comdians\", lblFontSize);\n\n        setupCombo(Frame1, comboBox, 100, 50, xWidth, lblFontSize, comedians);\n\n        setupTextFields(Frame1, txtField, 100, 90, xWidth, lblFontSize);\n\n        setTheButtons(Frame1, bttnAddItem, 250, 50, aWidth, \"Add Item\",\n                lblFontSize);\n        setTheButtons(Frame1, bttnRemoveSelected, 250, 90,\n                aWidth, \"Remove Selected\", lblFontSize);\n        setTheButtons(Frame1, bttnRemoveLast, 250, 130, aWidth, \"Remove Last\",\n                lblFontSize);\n\n    }\n\n    // Private method to configure the JFrame's visual \n    // and behavioral properties\n    private void setUpTheJFrame(JFrame jf1, int frameWidth, int frameHeight,\n            String frameTitle, Color frameColor,boolean turnLayoutManagerOff) {\n\n        // Set the initial dimensions of the JFrame's window\n        jf1.setSize(frameWidth, frameHeight);\n\n        // Set the JFrame title\n        jf1.setTitle(frameTitle);\n\n        // Apply a custom background color to the content pane\n        // The content pane is the area where items are added to \n        // the frame\n        jf1.getContentPane().setBackground(frameColor);\n\n        // Make the JFrame visible on the screen, \n        // allowing users to interact with it\n        jf1.setVisible(true);\n\n        // Center the JFrame on the user's screen for optimal visibility\n        jf1.setLocationRelativeTo(null);\n\n        // Specify the program's termination behavior \n        // when the JFrame is closed\n        // Exit the program when the frame is closed\n        jf1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Disable the default layout manager, allowing \n        // for manual component positioning\n        // Note: Manual layout can be more complex to manage\n        // disable the default layout manager\n        if (turnLayoutManagerOff) {\n            jf1.setLayout(null);\n        }\n    }\n\n    /**\n     * Helper method to set up a JLabel with custom position,\n     * size, text, and font size.\n     */\n    private void setupLabel(JFrame jf1, JLabel lbl,\n            int xpos, int ypos, int lblWidth,\n            String theText, float labelSize) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        lbl.setFont(lbl.getFont().deriveFont(labelSize));\n\n        // Set the preferred size of the label\n        lbl.setSize(lblWidth, (int) labelSize + 8);\n\n        // Set the text content of the label\n        lbl.setText(theText);\n\n        // Make the label visible\n        lbl.setVisible(true);\n\n        // Position the label at coordinates (xpos, ypos) within the window\n        lbl.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(lbl);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n    /**\n     * Helper method to set up a JTextField with the specified \n     * position, width, and font size.\n     */\n    private void setupTextFields(JFrame jf1, JTextField jtxt,\n            int xpos, int ypos, int tfWidth, float fsize) {\n        \n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        jtxt.setFont(jtxt.getFont().deriveFont(fsize));\n\n        // Set the preferred size of the label\n        jtxt.setSize(tfWidth, (int) fsize + 8);\n\n        // Set the text content of the label (empty by default)\n        jtxt.setText(\"\");\n\n        // Make the text field visible\n        jtxt.setVisible(true);\n\n        // Position the text field at coordinates (xpos, ypos)\n        jtxt.setLocation(xpos, ypos);\n\n        // Add the text field to the window's content pane\n        jf1.add(jtxt);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added text field\n        jf1.repaint();\n    }\n\n    /**\n     * Helper method to set up a JComboBox. It optionally populates \n     * items from a provided String array, sets font/size, and attaches \n     * a listener to update the selected label.\n     */\n    private void setupCombo(JFrame jf1, JComboBox jcmbo,\n            int xpos, int ypos, int cmboWidth,\n            float fsize, String[] comboItems) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        jcmbo.setFont(jcmbo.getFont().deriveFont(fsize));\n\n        // Set the preferred size of the label\n        jcmbo.setSize(cmboWidth, (int) fsize + 8);\n\n        // Make the combo box visible\n        jcmbo.setVisible(true);\n\n        // Enable the combo box so items can be selected\n        jcmbo.setEnabled(true);\n\n        // Position the combo box at coordinates (xpos, ypos)\n        jcmbo.setLocation(xpos, ypos);\n\n        // If the comboItems array is not null, add them all to the combo box\n        if (comboItems != null) {\n            for (String item : comboItems) {\n                jcmbo.addItem(item);\n            }\n        }\n\n        // Add the combo box to the window's content pane\n        jf1.add(jcmbo);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added combo box\n        jf1.repaint();\n\n        // Add an ActionListener to update the \"lblSelected\" label\n        // whenever a new item is chosen\n        jcmbo.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                lblSelected.setText(String.valueOf(jcmbo.getSelectedItem()));\n            }\n        });\n    }\n\n    /**\n     * Helper method to create a JButton, position it, set its text, \n     * attach an ActionListener and a KeyListener, and finally \n     * add it to the frame.\n     */\n    private void setTheButtons(JFrame jf1, JButton bttnABttn, \n            int xpos, int ypos, int bttnWidth, \n            String bttnText, float fsize) {\n\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        bttnABttn.setFont(bttnABttn.getFont().deriveFont(fsize));\n\n        // Set the preferred size of the label\n        bttnABttn.setSize(bttnWidth, (int) fsize + 8);\n\n        // Set the text content of the button\n        bttnABttn.setText(bttnText);\n\n        // Make the button visible\n        bttnABttn.setVisible(true);\n\n        // Position the button at the specified coordinates\n        bttnABttn.setLocation(xpos, ypos);\n\n        // This action listener listens for the mouse click\n        bttnABttn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n\n                theButtonAction(bttnText);\n            }\n        });\n\n        // This key listener is for listening for the keyboard actions\n        bttnABttn.addKeyListener(new KeyListener() {\n\n            // For Reference\n            @Override\n            public void keyTyped(KeyEvent e) {\n                // No action needed here\n            }\n\n            // listen only for the \"Enter\" key\n            @Override\n            public void keyPressed(KeyEvent e) {\n\n                if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n                    theButtonAction(bttnText);\n                }\n            }\n\n            // For Reference\n            @Override\n            public void keyReleased(KeyEvent e) {\n                // No action needed here\n            }\n        });\n\n        // Add the button to the window's content pane\n        jf1.add(bttnABttn);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added button\n        jf1.repaint();\n    }\n\n    /**\n     * theButtonAction method decides what action to perform based on\n     * the text label of the clicked button.\n     * \n     * @param bttnText the button's text, used to identify the intended action\n     */\n    private void theButtonAction(String bttnText) {\n\n        switch (bttnText) {\n            case \"Add Item\" -> {\n                String xAddItem = \"\";\n\n                xAddItem = txtField.getText();\n\n                //check to see if the box is not empty\n                // NOTE: if you want to add it then alphabetize it,\n                // remove all of the items to an arraylist, sort the arraylist,\n                // remove all of the comboBox items, and then readd them\n                // back from the arraylist\n                if (xAddItem.length() > 0) {\n                    comboBox.addItem(txtField.getText());\n                    txtField.setText(null);\n                }\n            }\n            case \"Remove Selected\" -> {\n                // Removes the currently selected item from the combo box\n                comboBox.removeItemAt(comboBox.getSelectedIndex());\n                comboBox.repaint();\n            }\n            case \"Remove Last\" -> {\n                // Removes the last item in the combo box\n                comboBox.removeItemAt(comboBox.getItemCount()-1);\n                comboBox.repaint();\n            }\n        }\n\n    }\n\n    // Remove Last\n} // End Of Class ------------------------------------------------\n\n/**\n * J2x_20_comboBoxes is the main class containing the entry point of the program.\n */\npublic class J2x_20_comboBoxes {\n\n    /**\n     * @param args the command line arguments\n     * The main method creates an instance of ComboBoxDemo, which sets up the GUI.\n     */\n    public static void main(String[] args) {\n\n        ComboBoxDemo myComboDemo = new ComboBoxDemo();\n    }\n\n}\n\n\nUpdated: 2/20/2025","type":"content","url":"/xcomboboxes-rev1#lecture-code","position":7},{"hierarchy":{"lvl1":"Displaying Text"},"type":"lvl1","url":"/xdisplayingtext","position":0},{"hierarchy":{"lvl1":"Displaying Text"},"content":"The differences and use cases for JTextArea, JTextPane, and JEditorPane in Java Swing:","type":"content","url":"/xdisplayingtext","position":1},{"hierarchy":{"lvl1":"Displaying Text","lvl2":"JTextArea:"},"type":"lvl2","url":"/xdisplayingtext#jtextarea","position":2},{"hierarchy":{"lvl1":"Displaying Text","lvl2":"JTextArea:"},"content":"Description: A JTextArea is a versatile component that displays multiple lines of text and optionally allows the user to edit the content.\n\nPros:\n\nSimple and lightweight.\n\nSuitable for displaying and editing plain text.\n\nSupports line wrapping.\n\nCan be placed inside a JScrollPane for scrolling behavior.\n\nCons:\n\nLimited formatting capabilities (no styles or images).\n\nNot suitable for rich text or complex layouts.","type":"content","url":"/xdisplayingtext#jtextarea","position":3},{"hierarchy":{"lvl1":"Displaying Text","lvl2":"JTextPane:"},"type":"lvl2","url":"/xdisplayingtext#jtextpane","position":4},{"hierarchy":{"lvl1":"Displaying Text","lvl2":"JTextPane:"},"content":"Description: A JTextPane extends JEditorPane and provides an editable text component with rich text formatting capabilities.\n\nPros:\n\nSupports styled text (fonts, colors, styles).\n\nAllows embedding images and components directly.\n\nSuitable for implementing text editors, document viewers, etc.\n\nCons:\n\nMore complex than JTextArea.\n\nRequires understanding of styled documents and attributes.\n\nLimited HTML support compared to JEditorPane.","type":"content","url":"/xdisplayingtext#jtextpane","position":5},{"hierarchy":{"lvl1":"Displaying Text","lvl2":"JEditorPane:"},"type":"lvl2","url":"/xdisplayingtext#jeditorpane","position":6},{"hierarchy":{"lvl1":"Displaying Text","lvl2":"JEditorPane:"},"content":"Description: A JEditorPane supports display/editing of HTML and RTF content. It can be extended by creating custom EditorKit implementations.\n\nPros:\n\nSupports HTML and RTF.\n\nCan display web content.\n\nCustomizable with different EditorKit implementations.\n\nCons:\n\nLimited CSS support.\n\nNot as feature-rich as a full web browser.\n\nRequires handling different content types.\n\nIn summary:\n\nUse JTextArea for simple, unstyled text.\n\nUse JTextPane for styled text (fonts, colors) and embedding images.\n\nUse JEditorPane for HTML/RTF content and custom text formats.","type":"content","url":"/xdisplayingtext#jeditorpane","position":7},{"hierarchy":{"lvl1":"Game Piece - Dynamically Adding Pieces to a Panel"},"type":"lvl1","url":"/xdynamic-gamepiece","position":0},{"hierarchy":{"lvl1":"Game Piece - Dynamically Adding Pieces to a Panel"},"content":"Summary:\n\nThis Java code creates a graphical user interface (GUI) application using the Swing library. It demonstrates a custom component called GamePiece. The application displays a 4x4 grid of these GamePiece objects within a panel. Alongside the grid, there are control buttons that allow the user to randomly change the colors, text, or both, displayed on the game pieces, as well as a button to reset them to a default state.\n\nDetailed Analysis:\n\nGUI Setup (J2x_Game_Piece_Demo class):\n\nComponents: It defines standard Swing components: a main window (JFrame), a panel (JPanel) to hold the game pieces, several buttons (JButton), and a label (JLabel).\n\nData Storage:\n\nmyAl: An ArrayList to hold the 16 GamePiece objects.\n\ncolorAl: An ArrayList to store predefined Color objects.\n\nmyWords: A String array containing predefined words.\n\nFunctionality Variables:\n\nRNG: A Random object for generating random numbers.\n\nmyTimer: A Timer object to create an animation-like effect when randomizing.\n\nxChoice: An integer (int) that determines what the timer should randomize (1=colors, 2=words, 3=both).\n\nLayout: The code manually sets the size and position of the frame, panel, label, and buttons using absolute coordinates (setSize, setLocation).\n\nInitialization (main, setupApp, setupFrame, etc.):\n\nThemain\n\nmethod callssetupApp\n\n, which in turn calls helper methods to:\n\nConfigure the main window (setupFrame).\n\nConfigure the panel (setupPanel).\n\nCreate and position the buttons, adding ActionListeners to them (setupButtons).\n\nConfigure and position the label (setupJLabel).\n\nCreate the 16 GamePiece instances, set their initial properties, add MouseListeners, and add them to the panel (PieceSetup).\n\nPopulate the list of available colors (colorSetup).\n\nInitialize the Timer (setupApp).\n\nGamePiece Class:\n\nCustom Component: This class extends JComponent, making it a custom drawable Swing component.\n\nState: Each GamePiece has its own pieceColor (a Color object) and letters (a String).\n\nPainting (paintComponent): This crucial method defines how a GamePiece looks. It draws a black rectangle as a border, then fills a slightly smaller rectangle inside with the pieceColor, and finally draws the letters string centered horizontally within the piece.\n\nGetters/Setters: Provides methods (getPieceColor, setPieceColor, getLetters, setLetters) to access and modify the piece’s state. Importantly, the set methods call repaint() to ensure the component redraws itself whenever its color or text changes.\n\nEvent Handling:\n\nMouse Events (PieceSetup):\n\nEachGamePiece\n\nhas aMouseListener\n\n. When the mouse interacts with a piece:\n\nmouseClicked: Color changes to white.\n\nmousePressed: Color changes to red.\n\nmouseReleased: Color changes to white.\n\nmouseEntered: Color changes to light gray (hover effect).\n\nmouseExited: Color changes back to white.\n\nButton Actions (setupButtons):\n\nmyBttnRndColors, myBttnRndWords, myBttnRndBoth: These buttons set the xChoice variable accordingly (1, 2, or 3) and start the myTimer.\n\nmyBttnReset: This button iterates through all GamePieces in the myAl list and resets their text to “----” and color to yellow.\n\nTimer Action (myActList):\n\nWhen myTimer is running, it fires an event every 40 milliseconds.\n\nTheactionPerformed\n\nmethod checksxChoice\n\n:\n\nIf 1, it picks a random color and applies it to a random GamePiece.\n\nIf 2, it picks a random word and applies it to a random GamePiece.\n\nIf 3, it does both (random color to a random piece, random word to another random piece).\n\nThis happens repeatedly for 150 cycles (150 * 40ms = 6 seconds), creating a shuffling effect, after which the timer stops itself.\n\nIn essence, the application displays a grid of interactive tiles (GamePieces) and provides controls to randomly shuffle their appearance (color and/or text) for a short duration or reset them./*\nEningeer: James Goudy\n */\n/**\n *\n * @author Goudy\n */\npackage j2x_game_piece_demo;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.Graphics;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport javax.swing.BorderFactory;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.Timer;\nimport javax.swing.border.Border;\n\npublic class J2x_Game_Piece_Demo {\n\n    // Create GUI Components\n    static JFrame myFrame = new JFrame();\n    static JPanel myPanel = new JPanel();\n    static JButton myBttnRndColors = new JButton(\"Random Colors\");\n    static JButton myBttnRndWords = new JButton(\"Random Words\");\n    static JButton myBttnRndBoth = new JButton(\"Random Both\");\n    static JButton myBttnReset = new JButton(\"Reset\");\n    static JLabel myLabel = new JLabel(\"Game Pieces\");\n\n    // ----------- Global Variables -------------------\n    //Arraylist to hold game pieces\n    static ArrayList<GamePiece> myAl = new ArrayList();\n\n    //Arraylist to hold colors\n    static ArrayList<Color> colorAl = new ArrayList();\n\n    //Array to hold words\n    static String[] myWords = {\"DOG\", \"CAT\", \"COW\", \"PUP\",\n        \"JAR\", \"STAR\", \"YEP\", \"CAR\",\n        \"BOOK\", \"FLIP\", \"****\", \"####\",\n        \"SHOW\", \"SHOE\", \"SOCK\", \"BOAT\",\n        \"JET\", \"RAIN\", \"TV\", \"RADIO\", \"?\",\n        \"DAISY\", \"ZIPPY\", \"HIPPY\", \"TRIPPY\", \"FLUFFY\"};\n\n    //Random number generator\n    static Random RNG;\n\n    //Timer for shuffling colors and text\n    static Timer myTimer;\n\n    //choice for determine if text, colors or both are shuffled\n    static int xChoice = 0;\n\n    //create a dimension for the box\n    static Dimension myDim = new Dimension(400, 400);\n\n    // button placement and size\n    static int bttnxpos = 500;\n    static int bttnypos = 50;\n    static int bttnSpacing = 25;\n\n    static int bttnLength = 150;\n    static int bttnHeight = 25;\n\n    //create an action listener\n    static ActionListener myActList = new ActionListener() {\n\n        //variable to hold random choice\n        int rc = 0;\n\n        //counter - the shuffles\n        int cntr = 0;\n\n        @Override\n        public void actionPerformed(ActionEvent arg0)\n        {\n\n            try {\n                switch (xChoice) {\n                    case 1:\n                        //random choice - colors\n                        rc = RNG.nextInt(colorAl.size());\n\n                        myAl.get(RNG.nextInt(myAl.size())).\n                                setPieceColor(colorAl.get(rc));\n                        break;\n                    case 2:\n                        //random choice - worlds\n                        rc = RNG.nextInt(myWords.length);\n\n                        myAl.get(RNG.nextInt(myAl.size())).\n                                setLetters(myWords[rc]);\n                        break;\n                    case 3:\n                        // random choice colors and words\n                        rc = RNG.nextInt(colorAl.size());\n\n                        myAl.get(RNG.nextInt(myAl.size())).\n                                setPieceColor(colorAl.get(rc));\n\n                        //random choice\n                        rc = RNG.nextInt(myWords.length);\n\n                        myAl.get(RNG.nextInt(myAl.size())).\n                                setLetters(myWords[rc]);\n                        break;\n                }\n\n            } catch (Exception e) {\n                System.out.println(e.getMessage());\n            }\n\n            cntr++;\n\n            if (cntr == 150) {\n                myTimer.stop();\n                cntr = 0;\n            }\n        }\n    };\n\n    public static void main(String[] args)\n    {\n\n        setupApp();\n\n    }\n\n    // helper function to setup GUI\n    private static void setupApp()\n    {\n\n        RNG = new Random();\n\n        setupFrame();\n\n        setupPanel();\n\n        setupButtons();\n        \n        setupJLabel();\n\n        PieceSetup();\n\n        colorSetup();\n\n        //setup timer\n        myTimer = new Timer(40, myActList);\n\n    }\n\n    private static void setupFrame()\n    {\n\n        // frame size \n        myFrame.setSize(725, 525);\n\n        // set location\n        myFrame.setLocationRelativeTo(null);\n\n        // set visibility\n        myFrame.setVisible(true);\n\n        // set close action\n        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // layout manager\n        myFrame.setLayout(null);\n\n        // set title\n        myFrame.setTitle(\"Game Pieces\");\n\n    }\n\n    static void setupPanel()\n    {\n\n        // set panel size\n        myPanel.setSize(myDim);\n\n        // set visible\n        myPanel.setVisible(true);\n\n        // set location\n        myPanel.setLocation(50, 50);\n\n        // set border\n        Border myPanelBorder = BorderFactory.createLineBorder(Color.BLACK, 2);\n        myPanel.setBorder(myPanelBorder);\n\n        myFrame.add(myPanel);\n\n    }\n\n    private static void setupButtons()\n    {\n\n        // set size\n        myBttnRndColors.setSize(bttnLength, bttnHeight);\n        myBttnRndWords.setSize(bttnLength, bttnHeight);\n        myBttnRndBoth.setSize(bttnLength, bttnHeight);\n        myBttnReset.setSize(bttnLength, bttnHeight);\n\n        // set Visible\n        myBttnRndColors.setVisible(true);\n        myBttnRndWords.setVisible(true);\n        myBttnRndBoth.setVisible(true);\n        myBttnReset.setVisible(true);\n\n        // set location\n        myBttnRndColors.setLocation(bttnxpos, bttnypos);\n        bttnypos = bttnypos + bttnHeight + bttnSpacing;\n\n        myBttnRndWords.setLocation(bttnxpos, bttnypos);\n        bttnypos = bttnypos + bttnHeight + bttnSpacing;\n\n        myBttnRndBoth.setLocation(bttnxpos, bttnypos);\n        bttnypos = bttnypos + bttnHeight + bttnSpacing;\n\n        myBttnReset.setLocation(bttnxpos, bttnypos);\n        bttnypos = bttnypos + bttnHeight + bttnSpacing;\n\n        // set actionlisteners\n        myBttnRndColors.addActionListener(e -> {\n\n            xChoice = 1;\n            myTimer.start();\n        });\n\n        myBttnRndWords.addActionListener(e -> {\n\n            xChoice = 2;\n            myTimer.start();\n        });\n\n        myBttnRndBoth.addActionListener(e -> {\n\n            xChoice = 3;\n            myTimer.start();\n        });\n\n        myBttnReset.addActionListener(e -> {\n\n            for (int cntr = 0; cntr < myAl.size(); cntr++) {\n                myAl.get(cntr).setLetters(\"----\");\n                myAl.get(cntr).setPieceColor(Color.yellow);\n            }\n\n        });\n\n        myFrame.add(myBttnRndColors);\n        myFrame.add(myBttnRndWords);\n        myFrame.add(myBttnRndBoth);\n        myFrame.add(myBttnReset);\n\n    }\n\n    private static void setupJLabel()\n    {\n\n        // set text\n        myLabel.setText(\"Game Pieces\");\n\n        // set fontsize\n        // Sets the label's font to bold with size 24, \n        // retaining the original font name.\n        // Retrieves the current font name and \n        // creates a new Font object with updated style and size.\n        myLabel.setFont(new Font(myLabel.getFont().getName(), Font.BOLD, 24));\n\n        // set size\n        myLabel.setSize(200, myLabel.getFont().getSize() + 4);\n\n        // set visibility\n        myLabel.setVisible(true);\n\n        // Set position\n        myLabel.setLocation(50, 10);\n\n        // add to frame\n        myFrame.add(myLabel);\n\n    }\n\n    // Piece Setup\n    static void PieceSetup()\n    {\n        //setup the pieces\n\n        int x = 0;\n        int y = 0;\n\n        for (int c = 1; c <= 16; c++) {\n\n            //create a new gamepiece\n            GamePiece gp = new GamePiece();\n\n            //set the location, size , visiblility and color\n            gp.setLocation(x, y);\n            gp.setSize(100, 100);\n            gp.setVisible(true);\n            gp.setPieceColor(Color.black);\n\n            //note what each of the mouse events are doing\n            gp.addMouseListener(new MouseListener() {\n                @Override\n                public void mouseClicked(MouseEvent arg0)\n                {\n\n                    gp.setPieceColor(Color.white);\n                }\n\n                @Override\n                public void mousePressed(MouseEvent arg0)\n                {\n                    gp.setPieceColor(Color.red);\n                }\n\n                @Override\n                public void mouseReleased(MouseEvent arg0)\n                {\n                    gp.setPieceColor(Color.white);\n                }\n\n                @Override\n                public void mouseEntered(MouseEvent arg0)\n                {\n                    gp.setPieceColor(Color.lightGray);\n                }\n\n                @Override\n                public void mouseExited(MouseEvent arg0)\n                {\n                    gp.setPieceColor(Color.white);\n                }\n            });\n\n            //add the gamepiec to the arraylist and then to the panel\n            myAl.add(gp);\n            myPanel.add(gp);\n\n            //increment x and y to the location of the next gamepiece\n            x = x + 100;\n\n            if ((c % 4) == 0) {\n                y = y + 100;\n                x = 0;\n            }\n        }\n        //refresh the panel\n        myPanel.repaint();\n    }\n\n    static void colorSetup()\n    {\n\n        //add colors to the color arrraylist\n        colorAl.add(Color.blue);\n        colorAl.add(Color.cyan);\n        colorAl.add(Color.magenta);\n        colorAl.add(Color.red);\n        colorAl.add(Color.orange);\n        colorAl.add(Color.green);\n        colorAl.add(Color.yellow);\n        colorAl.add(Color.pink);\n        colorAl.add(Color.lightGray);\n\n    }\n\n} // end of program  class\n\n// *************  GAME PIECE CLASS *****************\nclass GamePiece extends JComponent {\n\n    Color pieceColor = Color.white;\n\n    String letters = \"GP\";\n\n    public GamePiece()\n    {\n\n        this.setForeground(pieceColor);\n\n        this.setVisible(true);\n\n    }\n\n    @Override\n    public void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n\n        Font myFont = new Font(\"Lucida Console\", Font.BOLD, 18);\n\n        //NOTE: ORDER IS EVERYTHING!\n        g.setColor(Color.black);\n        g.fillRect(0, 0, 100, 100);\n        g.setColor(pieceColor);\n        g.fillRect(5, 5, 90, 90);\n        g.setColor(Color.black);\n\n        g.setFont(myFont);\n\n        //CENTER TEXT HORIZONTALLY\n        int width = g.getFontMetrics().stringWidth(letters);\n        int left = (100 - width) / 2;\n        g.drawString(letters, left, 60);\n\n    }\n\n    //SETTERS AND GETTERS\n    public Color getPieceColor()\n    {\n        return pieceColor;\n    }\n\n    public void setPieceColor(Color pieceColor)\n    {\n        this.pieceColor = pieceColor;\n        this.repaint();\n    }\n\n    public String getLetters()\n    {\n        return letters;\n    }\n\n    public void setLetters(String letters)\n    {\n        this.letters = letters;\n        this.repaint();\n    }\n\n}\n\n","type":"content","url":"/xdynamic-gamepiece","position":1},{"hierarchy":{"lvl1":"First Form"},"type":"lvl1","url":"/xfirstform","position":0},{"hierarchy":{"lvl1":"First Form"},"content":"","type":"content","url":"/xfirstform","position":1},{"hierarchy":{"lvl1":"First Form","lvl2":"JFrame"},"type":"lvl2","url":"/xfirstform#jframe","position":2},{"hierarchy":{"lvl1":"First Form","lvl2":"JFrame"},"content":"Basic Properties:\n\nTitle: The text displayed on the title bar of the window.\n\nSize: Width and height of the window in pixels.\n\nLocation: The position of the window on the screen, specified by the x and y coordinates of its top-left corner.\n\nResizable: Determines whether the user can resize the window.\n\nVisible: Determines whether the window is displayed on the screen.\n\nIcon: The icon displayed in the title bar and taskbar.\n\nDefault Close Operation: Defines what happens when the user tries to close the window (e.g., hide, dispose, exit the application).\n\nContent Pane:\n\nLayout: The layout manager used to organize the components within the frame. Different layout managers offer different ways to arrange components (e.g., BorderLayout, FlowLayout, GridLayout).\n\nComponents: The set of graphical components (buttons, text fields, labels, etc.) displayed within the frame.\n\nBehavior Properties:\n\nModal: Determines whether the window blocks interaction with other windows while it’s open.\n\nAlways on Top: Determines whether the window stays on top of other windows.\n\nFocusable: Determines whether the window can receive keyboard focus.\n\nMinimizable: Determines whether the user can minimize the window to the taskbar.\n\nMaximizable: Determines whether the user can maximize the window to fill the screen.\n\nLook and Feel:\n\nLook and feel: Defines the overall visual appearance of the frame and its components (e.g., Windows, Metal, Nimbus).\n\nFont: The default font used for text within the frame.\n\nColors: The default colors used for various elements of the frame (e.g., background, foreground, border).\n\nAccessibility:\n\nAccessible name: A description of the frame for assistive technologies like screen readers.\n\nAccessible description: A more detailed description of the frame’s purpose and content.\n\nAdditional Properties:\n\nGlass pane: A transparent component that can be used to block user interaction with the underlying components.\n\nRoot pane: The top-level container that holds the frame’s content.\n\nJMenuBar: The menu bar displayed at the top of the frame.\n\nWindowListener: Objects that are notified when specific events occur (e.g., window opens, closes, minimizes).","type":"content","url":"/xfirstform#jframe","position":3},{"hierarchy":{"lvl1":"First Form","lvl2":"JLabel:"},"type":"lvl2","url":"/xfirstform#jlabel","position":4},{"hierarchy":{"lvl1":"First Form","lvl2":"JLabel:"},"content":"text: The main content of the label, displayed as a single line of text.\n\nfont: Controls the typeface, size, and style of the displayed text.\n\nforeground: Sets the color of the text.\n\nbackground: Sets the color background behind the text.\n\nhorizontalAlignment: Controls the horizontal alignment of the text within the label (LEFT, RIGHT, CENTER).\n\nverticalAlignment: Controls the vertical alignment of the text within the label (TOP, BOTTOM, CENTER).\n\nicon: An optional image displayed alongside the text.\n\nenabled: Sets whether the label is visible and usable (true for active, false for disabled).\n\ntooltip: A short explanatory text displayed when hovering over the label.\n\nborder: Optional border around the label for visual styling.\n\nmnemonic: A specific key that, when pressed, focuses the associated component (useful for accessibility).","type":"content","url":"/xfirstform#jlabel","position":5},{"hierarchy":{"lvl1":"First Form","lvl2":"JTextField"},"type":"lvl2","url":"/xfirstform#jtextfield","position":6},{"hierarchy":{"lvl1":"First Form","lvl2":"JTextField"},"content":"","type":"content","url":"/xfirstform#jtextfield","position":7},{"hierarchy":{"lvl1":"First Form","lvl3":"Basic Properties:","lvl2":"JTextField"},"type":"lvl3","url":"/xfirstform#basic-properties","position":8},{"hierarchy":{"lvl1":"First Form","lvl3":"Basic Properties:","lvl2":"JTextField"},"content":"Text: This is the actual content displayed in the field.\n\nColumns: Specifies the preferred width of the field in characters.\n\nEditable: This boolean flag determines whether users can modify the text.\n\nEnabled: This boolean flag determines whether the field is usable or disabled.\n\nVisible: This boolean flag determines whether the field is visible on the screen.\n\nFont: This sets the typeface, size, and style of the text.\n\nForeground: This sets the color of the text.\n\nBackground: This sets the color of the field’s background.\n\nAlignment: This determines how text is positioned within the field (left, center, right).\n\nInput Formatting:\n\nDocument: This allows you to set custom filters and restrictions on the type of text that can be entered (e.g., numbers only, specific format).\n\nCaret position: This specifies where the cursor appears in the field.\n\nSelection: This allows you to highlight a portion of the text.\n\nEvent Handling:\n\nAction command: This defines the text sent when the user performs an action (e.g., pressing Enter) in the field.\n\nAction listeners: These are objects that respond to actions performed in the field.\n\nFocus listeners: These are objects that are notified when the field gains or loses focus.\n\nAdditional Properties:\n\nTooltip: This provides a short informational message that appears when the user hovers over the field.\n\nBorder: This defines the visual appearance of the field’s border.\n\nAccessible name: This describes the field for assistive technologies like screen readers.","type":"content","url":"/xfirstform#basic-properties","position":9},{"hierarchy":{"lvl1":"First Form","lvl2":"Example Code"},"type":"lvl2","url":"/xfirstform#example-code","position":10},{"hierarchy":{"lvl1":"First Form","lvl2":"Example Code"},"content":"/*\nProgam: First Form - Basic Calculator\n\nFunction:   The purpose of the program is to add and subtract two numbers\n            It also needs to have a clear button\n\nProgrammer: James Goudy ©2024\n\n */\npackage j2x_1_firstform;\n\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.*;\n\n// Class to create and manage a basic JFrame\nclass form1 {\n\n    // remember that when a control is created\n    // it has no dimensions, no location,\n    // and its visibility is set to false.\n    \n    // create the frame\n    JFrame jf1 = new JFrame(\"First Form\");\n    \n    // create the lablels\n    JLabel jlbl_Title = new JLabel();\n    JLabel jlblBox1 = new JLabel();\n    JLabel jlblBox2 = new JLabel();\n    JLabel jlblAns = new JLabel();\n    JLabel jlblAnsValue = new JLabel();\n    \n    // create the textfields\n    JTextField jtxt1 = new JTextField();\n    JTextField jtxt2 = new JTextField();\n    \n    // create the buttons\n    JButton jbttnAdd = new JButton();\n    JButton jbttnSub = new JButton();\n    JButton jbttnClear = new JButton();\n    \n    // create a customize color\n    Color myColor = new Color(210, 180, 140);\n    \n    // Constructor to initialize the form\n    public form1() {\n        \n        int TitleSz = 24;       // Title Size\n        int TextSz = 12;        // Text Size\n             \n        // Call the method to set up the JFrame\n        setUpTheJFrame();\n\n        // add Title label to the form\n        setupLabelBox(jlbl_Title, 10, 10, \"Calculator\", TitleSz);\n        \n        // setup the first textfield with a lablel\n        setupLabelBox(jlblBox1, 10, 50, \"First Number\",TextSz);\n        setupTextFields(jtxt1, 150, 50,12);\n\n        // setup the second textfield with a label\n        setupLabelBox(jlblBox2, 10, 75, \"Second Number\", TextSz);\n        setupTextFields(jtxt2, 150, 75,12);\n\n        // setup the answer label and a labele to hold the answer\n        setupLabelBox(jlblAns, 10, 100, \"Answer\",TextSz);\n        setupLabelBox(jlblAnsValue, 150, 100, \"---\",TextSz);\n\n        // setup the buttons\n        setMathButtons(jbttnAdd, 10, 125, \"+\");\n        setMathButtons(jbttnSub,60, 125,\"-\");\n        setMathButtons(jbttnClear, 110, 125, \"C\");\n    }\n\n\t// Private method to configure the JFrame's visual \n        // and behavioral properties\n\tprivate void setUpTheJFrame() {\n\n\t\t// Set the initial dimensions of the JFrame's window\n\t\tjf1.setSize(400, 250); \n\n\t\t// Apply a custom background color to the content pane\n                // The content pane is the area where items are added to \n                // the frame\n\t\tjf1.getContentPane().setBackground(myColor);  \n\n\t\t// Make the JFrame visible on the screen, \n                // allowing users to interact with it\n\t\tjf1.setVisible(true);\n\n\t\t// Center the JFrame on the user's screen for optimal visibility\n\t\tjf1.setLocationRelativeTo(null);\n\n\t\t// Specify the program's termination behavior \n                // when the JFrame is closed\n\t\t// Exit the program when the frame is closed\n\t\tjf1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  \n\n\t\t// Disable the default layout manager, allowing \n\t\t// for manual component positioning\n\t\t // Note: Manual layout can be more complex to manage\n\t\tjf1.setLayout(null); \n\t}\n\n\n    private void setupLabelBox(JLabel lbl, int xpos, int ypos, \n            String theText, float labelSize) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        lbl.setFont(lbl.getFont().deriveFont(labelSize));\n\n        // Set the preferred size of the label\n        lbl.setSize(150, (int)labelSize + 8);\n\n        // Set the text content of the label\n        lbl.setText(theText);\n\n        // Make the label visible\n        lbl.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        lbl.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(lbl);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n    private void setupTextFields(JTextField jtxt, \n            int xpos, int ypos, float fsize) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        jtxt.setFont(jtxt.getFont().deriveFont(12f));\n\n        // Set the preferred size of the label\n        jtxt.setSize(100, (int)fsize + 8);\n\n        // Set the text content of the label\n        jtxt.setText(\"0\");\n\n        // Make the label visible\n        jtxt.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        jtxt.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(jtxt);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n    private void setMathButtons(JButton jbttnMath, int xpos, int ypos,\n            String mathOp) {\n\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        jbttnMath.setFont(jbttnMath.getFont().deriveFont(12f));\n\n        // Set the preferred size of the label\n        jbttnMath.setSize(45, 45);\n\n        // Set the text content of the label\n        jbttnMath.setText(mathOp);\n\n        // Make the label visible\n        jbttnMath.setVisible(true);\n\n        // Position the label at coordinates (xpos, ypos) within the window\n        jbttnMath.setLocation(xpos, ypos);\n\n        // This action listener listens for the mouse click\n        jbttnMath.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n\t\t\t\t// the string operator is passed to the function\n                               \n                mathCalc(mathOp);\n                \n                // in production, if there are complex operations\n                // or many lines of code, then writing out\n                // separate functions may be preferable\n            }\n        });\n\n        // This key listener is for listening for the keyboard actions\n        jbttnMath.addKeyListener(new KeyListener() {\n            \n            // For Reference\n            @Override\n            public void keyTyped(KeyEvent e) {\n\n            }\n\n            // listen only for the \"Enter\" key\n            @Override\n            public void keyPressed(KeyEvent e) {\n\n                if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n                    mathCalc(mathOp);\n                }\n            }\n\n            // For Reference\n            @Override\n            public void keyReleased(KeyEvent e) {\n                \n            }\n        });\n\n        // Add the label to the window's content pane\n        jf1.add(jbttnMath);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n\n    }\n\n    /**    Function to do the appropriate Math operation.\n            Note that the operation sign is being passed to the function */\n    private void mathCalc(String mathOp) {\n        double ans = 0.0;\n\n        try {\n            switch (mathOp) {\n                case \"+\" -> {\n                    // Retreive the text from the textfield \n                    // and parse it into a double datatype\n                    ans = Double.parseDouble(jtxt1.getText())\n                            + Double.parseDouble(jtxt2.getText());\n                    \n                    // place the answer in the Answer Value label\n                    jlblAnsValue.setText(String.valueOf(ans));\n                }\n                case \"-\" -> {\n                    ans = Double.parseDouble(jtxt1.getText())\n                            - Double.parseDouble(jtxt2.getText());\n                    jlblAnsValue.setText(String.valueOf(ans));\n                }\n                case \"C\" -> {\n                    // Clear the textfields by setting the \n                    // contents to an empty string\n                    jtxt1.setText(\"\");\n                    jtxt2.setText(\"\");\n                    jlblAnsValue.setText(\"\"); \n                    \n                    // Place the cursor in the first textfield\n                    // using the requestFocus command\n                    jtxt1.requestFocus();\n                }\n\n            }\n        } catch (Exception e) {\n            jlblAnsValue.setText(\"You had an error\");\n            jtxt1.setText(\"\");\n            jtxt2.setText(\"\");\n            jtxt1.requestFocus();\n        }\n    }\n\n}\n\npublic class J2x_1_firstform {\n\n    public static void main(String[] args) {\n        // create a frame window\n        form1 myForm = new form1();\n    }\n\n}\n","type":"content","url":"/xfirstform#example-code","position":11},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label"},"type":"lvl1","url":"/ximageiconlabel","position":0},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label"},"content":"An ImageIcon in Java is a class from the javax.swing package that encapsulates an image to be used in Swing components. When paired with a JLabel, it enables the display of images within the graphical user interface.","type":"content","url":"/ximageiconlabel","position":1},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Definition and Purpose"},"type":"lvl2","url":"/ximageiconlabel#definition-and-purpose","position":2},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Definition and Purpose"},"content":"ImageIcon is a subclass of javax.swing.Icon.\n\nIt is typically used to load and manage images (like .jpg, .png, .gif) and render them in UI elements.","type":"content","url":"/ximageiconlabel#definition-and-purpose","position":3},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Common Uses"},"type":"lvl2","url":"/ximageiconlabel#common-uses","position":4},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Common Uses"},"content":"Display in JLabel: Most common use. Assign an ImageIcon to a JLabel to show an image:JLabel label = new JLabel(new ImageIcon(\"path/to/image.jpg\"));\n\nButtons and Menus: Used to add icons to JButton, JMenuItem, etc.JButton button = new JButton(new ImageIcon(\"icon.png\"));\n\nToolbars: Icons in JToolBar often use ImageIcon.","type":"content","url":"/ximageiconlabel#common-uses","position":5},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Key Features"},"type":"lvl2","url":"/ximageiconlabel#key-features","position":6},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Key Features"},"content":"Supports image formats via Java’s built-in ImageIO.\n\nHandles automatic repainting of components when icons change.\n\nCan be created from files, URLs, or byte arrays.","type":"content","url":"/ximageiconlabel#key-features","position":7},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"Reference","lvl2":"Key Features"},"type":"lvl3","url":"/ximageiconlabel#reference","position":8},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"Reference","lvl2":"Key Features"},"content":"Java SE Documentation: \n\nImageIcon","type":"content","url":"/ximageiconlabel#reference","position":9},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Example Code"},"type":"lvl2","url":"/ximageiconlabel#example-code","position":10},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl2":"Example Code"},"content":"/*\n Developer: James Goudy\n Description: A simple Java Swing application to read and display an image using a JLabel.\n */\n\n package filereading;\n\n\n import java.awt.Image;\n import java.awt.image.BufferedImage;\n import java.io.IOException;\n import java.net.URL;\n import javax.imageio.ImageIO;\n import javax.swing.*;\n \n public class FileReading {\n \n     public static void main(String[] args) {\n         SwingUtilities.invokeLater(ImageViewerFrame::new);\n     }\n }\n \n class ImageViewerFrame {\n     \n     \n     // global variables\n     private BufferedImage image;\n \n     private final JFrame frame;\n     \n     private final JMenuBar menuBar = new JMenuBar();\n     private final JMenu fileMenu = new JMenu(\"File\");\n     private final JMenuItem quitItem = new JMenuItem(\"Quit\");\n     \n     private final JLabel imageLabel = new JLabel();\n \n     \n     // constructor\n     public ImageViewerFrame() {\n         \n         \n         frame = new JFrame(\"Image Viewer\");\n \n         // helper functions\n         setupMenu();\n         setupFrame();\n         loadImage(\"/images/dog6.jpg\");\n         setupImageLabel();\n \n         frame.setVisible(true);\n     }\n \n     private void setupMenu() {\n         \n         // setup quit menuitem\n         quitItem.addActionListener(e -> System.exit(0));\n         \n         // add quitItem to the menu\n         fileMenu.add(quitItem);\n         \n         // add menu to memubar\n         menuBar.add(fileMenu);\n         \n         // add menubar to Frame\n         frame.setJMenuBar(menuBar);\n     }\n \n     private void setupFrame() {\n         \n         // frame dimensions\n         int width = 800;\n         int height = 600;\n         \n         // set what happens on close\n         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n         \n         // set framesize layoutmanager and screen location\n         frame.setSize(width,height);\n         frame.setLayout(null);\n         frame.setLocationRelativeTo(null);\n     }\n \n     private void loadImage(String filePath) {\n         \n         try {\n             URL imageUrl = getClass().getResource(filePath);\n             \n             // test for  file path\n             if (imageUrl == null) {\n                 \n                 // show error pane if not found\n                 JOptionPane.showMessageDialog(frame, \n                                \"Image not found: \" + filePath,\n                                \"Error\", JOptionPane.ERROR_MESSAGE);\n                 return;\n             }\n             \n             image = ImageIO.read(imageUrl);\n             \n         } catch (IOException e) {\n             // show error pane\n             JOptionPane.showMessageDialog(frame, \n                     \"Failed to load image: \" + e.getMessage(),\n                     \"Error\", JOptionPane.ERROR_MESSAGE);\n         }\n     }\n \n     private void setupImageLabel() {\n         \n         int width = 300;\n         int heigth = 200;\n         \n         if (image != null) {\n             \n             // scale image\n             Image scaledImage = image.getScaledInstance(width, heigth, Image.SCALE_SMOOTH);\n             \n             // add image to image icon\n             ImageIcon icon = new ImageIcon(scaledImage);\n             \n             imageLabel.setIcon(icon);\n             \n             // center the picture on the label\n             imageLabel.setHorizontalAlignment(SwingConstants.CENTER);\n             imageLabel.setVerticalAlignment(SwingConstants.CENTER);\n             \n             // set image location and size\n             imageLabel.setBounds(50,50,width, heigth);\n             \n             // add imagelabel to frame\n             frame.add(imageLabel);\n         }\n     }\n }\n \n\nThe build sequence of this Java Swing program involves several key steps that follow a clear flow from application startup to GUI rendering. Below is a breakdown of the execution (build) sequence from class loading through GUI display:","type":"content","url":"/ximageiconlabel#example-code","position":11},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"1. Application Entry Point","lvl2":"Example Code"},"type":"lvl3","url":"/ximageiconlabel#id-1-application-entry-point","position":12},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"1. Application Entry Point","lvl2":"Example Code"},"content":"The main method in the FileReading class is the entry point:SwingUtilities.invokeLater(ImageViewerFrame::new);\n\nThis line schedules the creation of a new ImageViewerFrame instance on the Event Dispatch Thread (EDT), ensuring thread safety for Swing components (ref: \n\nOracle Swing Tutorial).","type":"content","url":"/ximageiconlabel#id-1-application-entry-point","position":13},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"type":"lvl3","url":"/ximageiconlabel#id-2-construction-of-imageviewerframe","position":14},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"content":"The constructor of ImageViewerFrame is called:public ImageViewerFrame() {\n    ...\n    setupMenu();\n    setupFrame();\n    loadImage(\"/images/dog6.jpg\");\n    setupImageLabel();\n    frame.setVisible(true);\n}\n\nIt initializes the GUI step-by-step:","type":"content","url":"/ximageiconlabel#id-2-construction-of-imageviewerframe","position":15},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"a. setupMenu()","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"type":"lvl4","url":"/ximageiconlabel#a-setupmenu","position":16},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"a. setupMenu()","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"content":"Initializes menu components:\n\nAdds “Quit” menu item with action listener to terminate the application.\n\nAdds the menu item to the menu, then attaches the menu bar to the JFrame.","type":"content","url":"/ximageiconlabel#a-setupmenu","position":17},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"b. setupFrame()","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"type":"lvl4","url":"/ximageiconlabel#b-setupframe","position":18},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"b. setupFrame()","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"content":"Sets up the frame:\n\nDimensions, close operation, layout manager (null = absolute positioning), and centering the window on the screen.","type":"content","url":"/ximageiconlabel#b-setupframe","position":19},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"c. loadImage(String filePath)","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"type":"lvl4","url":"/ximageiconlabel#c-loadimage-string-filepath","position":20},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"c. loadImage(String filePath)","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"content":"Attempts to load an image from the classpath using getClass().getResource(filePath).\n\nIf successful, loads the image into a BufferedImage via ImageIO.read.\n\nDisplays error dialogs if the image is not found or cannot be read.","type":"content","url":"/ximageiconlabel#c-loadimage-string-filepath","position":21},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"d. setupImageLabel()","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"type":"lvl4","url":"/ximageiconlabel#d-setupimagelabel","position":22},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"d. setupImageLabel()","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"content":"If the image is loaded:\n\nScales it to 300×200 using Image.SCALE_SMOOTH.\n\nWraps the scaled image in an ImageIcon and sets it on a JLabel.\n\nPositions the label on the frame with absolute coordinates.\n\nAdds the label to the frame.","type":"content","url":"/ximageiconlabel#d-setupimagelabel","position":23},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"e. frame.setVisible(true)","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"type":"lvl4","url":"/ximageiconlabel#e-frame-setvisible-true","position":24},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl4":"e. frame.setVisible(true)","lvl3":"2. Construction of ImageViewerFrame","lvl2":"Example Code"},"content":"Displays the fully constructed GUI window.","type":"content","url":"/ximageiconlabel#e-frame-setvisible-true","position":25},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"Key Notes","lvl2":"Example Code"},"type":"lvl3","url":"/ximageiconlabel#key-notes","position":26},{"hierarchy":{"lvl1":"Add Image Using Image Icon Label","lvl3":"Key Notes","lvl2":"Example Code"},"content":"Absolute positioning (null layout manager) is used, so components are manually sized and placed.\n\nClasspath resource loading: The image must reside in /images/dog6.jpg relative to the classpath root.\n\nThe use of invokeLater() aligns with Swing’s requirement to create and update GUI components on the EDT for thread safety.\n\nWould you like a diagram of the object construction and method call sequence?","type":"content","url":"/ximageiconlabel#key-notes","position":27},{"hierarchy":{"lvl1":"JAVA Automated Build Tools"},"type":"lvl1","url":"/xjabt-javaautomatedbuildtools","position":0},{"hierarchy":{"lvl1":"JAVA Automated Build Tools"},"content":"Java automated build tools, like Ant, Maven, and Gradle, serve several crucial purposes for development projects:\n\n1. Streamlining Repetitive Tasks:\n\nAutomating the compilation of Java source code into bytecode, eliminating manual steps and saving time.\n\nAutomatically fetching and managing dependencies, ensuring consistent versions and avoiding conflicts.\n\nExecuting unit and integration tests automatically, providing continuous feedback on code quality.\n\nCreating distributions like JAR files, simplifying deployment and distribution.\n\nPotentially automating deployment tasks on servers or other environments, further streamlining the process.\n\n2. Ensuring Consistency and Reproducibility:\n\nDefining a standardized build process ensures everyone builds the project the same way, regardless of their environment.\n\nThis fosters reproducibility, allowing developers to easily rebuild the project on different machines for testing or deployment.\n\nReduces errors and discrepancies that can arise from manual compilation and configuration.\n\n3. Improving Project Management and Maintainability:\n\nBuild tools organize project configurations and dependencies in a centralized location, making them easier to manage and understand.\n\nClear and defined build processes improve collaboration and communication within development teams.\n\nEasier to maintain complex projects with many files and dependencies due to the automated nature of the build process.\n\n4. Enabling Continuous Integration and Deployment (CI/CD):\n\nBuild tools integrate well with CI/CD pipelines, allowing automated builds and deployments upon code changes.\n\nThis facilitates faster development cycles and quicker delivery of new features or bug fixes.\n\nPromotes a more agile and efficient development approach.\n\nIn summary, Java automated build tools are indispensable for:\n\nIncreased developer productivity and efficiency.\n\nEnsuring consistent and reliable builds across different environments.\n\nImproved project management and maintainability.\n\nEnabling modern development practices like CI/CD.","type":"content","url":"/xjabt-javaautomatedbuildtools","position":1},{"hierarchy":{"lvl1":"JAVA Automated Build Tools","lvl2":"Comparision"},"type":"lvl2","url":"/xjabt-javaautomatedbuildtools#comparision","position":2},{"hierarchy":{"lvl1":"JAVA Automated Build Tools","lvl2":"Comparision"},"content":"Feature\n\nAnt\n\nMaven\n\nGradle\n\nType\n\nXML-based scripting\n\nConvention-based with XML configuration\n\nGroovy-based Domain Specific Language (DSL)\n\nLearning Curve\n\nModerate\n\nEasy\n\nModerate to Steep\n\nFlexibility\n\nHigh\n\nModerate\n\nHigh\n\nCommunity & Resources\n\nLarge and mature\n\nLarge and active\n\nGrowing and expanding\n\nDependency Management\n\nManual configuration\n\nCentralized repositories\n\nFlexible, supports various sources\n\nPlugins\n\nLarge ecosystem\n\nLarge ecosystem\n\nVery large and extensible ecosystem\n\nBuild Speed\n\nFast\n\nModerate\n\nCan be slower for large projects\n\nSuitable for\n\nSimple to complex projects, legacy projects\n\nEnterprise projects, standardized configurations\n\nComplex projects, diverse technologies, customization\n\nKey strengths\n\nFlexibility, fine-grained control\n\nConsistency, simplicity, centralized dependencies\n\nPower, flexibility, multi-language support\n\nKey weaknesses\n\nVerbose build files, can be complex\n\nLess flexible, steeper learning curve for advanced features\n\nPotential performance overhead for large projects","type":"content","url":"/xjabt-javaautomatedbuildtools#comparision","position":3},{"hierarchy":{"lvl1":"Java Ant: Build Automation"},"type":"lvl1","url":"/xjabt-javaant","position":0},{"hierarchy":{"lvl1":"Java Ant: Build Automation"},"content":"Java Ant is an open-source, XML-based build automation tool designed specifically for Java projects. It allows developers to automate repetitive tasks involved in building, testing, and deploying Java applications. Here’s a breakdown of its key features:\n\nWhat it does:\n\nAutomates compilation: Compiles Java source code into bytecode using a specified Java compiler.\n\nManages dependencies: Downloads and manages external libraries and dependencies required by the project.\n\nRuns tests: Executes unit and integration tests automatically and reports results.\n\nCreates distributions: Packages compiled classes and resources into distributable formats like JAR files.\n\nDeployment: Can be configured to automate deployment tasks on servers or other environments.\n\nKey Features:\n\nXML-based build files: Build instructions are defined in XML files called build.xml, facilitating readability and maintainability.\n\nTargets and tasks: Tasks are atomic actions performing specific operations like compiling or testing, while targets group related tasks based on functionality.\n\nExtensibility: Supports extension libraries (antlibs) with pre-built tasks for various purposes.\n\nCross-platform: Runs on any platform with Java installed, ensuring consistency across development environments.\n\nBenefits of using Ant:\n\nIncreased productivity: Automates repetitive tasks, saving developers time and effort.\n\nImproved consistency: Enforces consistent build processes across different environments.\n\nFlexibility: Highly customizable to suit specific project needs.\n\nLarge community and resources: Extensive documentation, tutorials, and community support available.\n\nDrawbacks of Ant:\n\nSteeper learning curve: XML syntax can be unfamiliar for beginners compared to more modern tools.\n\nVerbose build files: Complex projects can lead to lengthy and difficult to maintain build files.\n\nLess intuitive compared to newer tools: Newer build tools often offer simpler syntax and more user-friendly interfaces.\n\nAlternatives to Ant:\n\nMaven: Widely adopted build tool with pre-defined conventions and dependency management.\n\nGradle: Groovy-based build tool offering flexibility and a powerful DSL (Domain Specific Language).","type":"content","url":"/xjabt-javaant","position":1},{"hierarchy":{"lvl1":"Java Gradle: Build Automation"},"type":"lvl1","url":"/xjabt-javagradle","position":0},{"hierarchy":{"lvl1":"Java Gradle: Build Automation"},"content":"Java Gradle is an open-source, build automation tool designed for Java and many other programming languages. It offers a powerful Domain Specific Language (DSL) based on Groovy, providing flexibility and customization beyond traditional XML-based tools like Ant and Maven. Here’s a breakdown of its key features:\n\nWhat it does:\n\nAutomates compilation: Compiles source code for various languages (Java, Scala, Kotlin, etc.) using specific compilers.\n\nManages dependencies: Fetches and manages external libraries and dependencies from various sources (repositories, local files, etc.).\n\nRuns tests: Executes unit and integration tests automatically and reports results.\n\nCreates distributions: Packages compiled classes and resources into various formats like JARs, WARs, or APKs.\n\nDeployment: Can be configured to automate deployment tasks on servers or other environments.\n\nKey Features:\n\nGroovy-based DSL: Provides a concise and readable way to define build processes, making them more intuitive than verbose XML configurations.\n\nFlexibility: Highly customizable to suit specific project needs with a wide range of built-in tasks and plugins.\n\nMulti-language support: Not limited to Java, allowing building projects with diverse languages and technologies.\n\nPowerful plugin ecosystem: Extensive plugin ecosystem caters to various needs, from testing frameworks to code analysis tools.\n\nBenefits of Using Gradle:\n\nIncreased productivity: Concise DSL and automation save time and effort compared to more verbose tools.\n\nImproved maintainability: Readable build scripts enhance code comprehension and collaboration.\n\nFlexibility and customization: Highly adaptable to diverse project requirements with plugins and custom extensions.\n\nLarge community and resources: Growing community offering support, documentation, and best practices.\n\nDrawbacks of Gradle:\n\nSteeper learning curve: Groovy-based DSL might require additional learning compared to simpler tools.\n\nComplexity for simple projects: Can be overkill for very basic projects with minimal needs.\n\nPotential performance overhead: Can be slower than Ant for very large projects due to its dynamic nature.\n\nAlternatives to Gradle:\n\nAnt: Traditional, XML-based tool offering flexibility but requiring more manual configuration.\n\nMaven: Popular tool with conventions and dependency management, but less flexible than Gradle.\n\nIs Gradle still relevant?\n\nDespite its learning curve, Gradle’s flexibility and power make it a popular choice for various projects, especially in larger environments or those requiring customization. Understanding Gradle is valuable for Java developers, particularly those working with modern project structures and diverse technologies.\n\nAdditional Notes:\n\nGradle can be integrated with other tools like IDEs and CI/CD pipelines.\n\nLearning Gradle involves understanding the Groovy DSL, available plugins, and best practices for building efficient and maintainable projects.","type":"content","url":"/xjabt-javagradle","position":1},{"hierarchy":{"lvl1":"Java Maven:  Build Automation"},"type":"lvl1","url":"/xjabt-javamaven","position":0},{"hierarchy":{"lvl1":"Java Maven:  Build Automation"},"content":"Java Maven is an open-source, build automation tool designed specifically for Java projects. It simplifies the software development lifecycle by automating common tasks like:\n\nCompilation: Automatically converts Java source code into bytecode using a specified compiler.\n\nDependency Management: Fetches and manages all external libraries and dependencies your project needs from centralized repositories like Maven Central.\n\nTesting: Executes unit and integration tests automatically and reports the results.\n\nPackaging: Creates various distribution formats like JAR files for easy deployment.\n\nDeployment: Can be configured to automate deployment tasks on servers or other environments.\n\nThe Core of Maven: The Project Object Model (POM):\n\nUnlike Ant, which relies on verbose XML build files, Maven uses a standardized format called the Project Object Model (POM). The POM is written in XML and defines all project configurations, dependencies, and build instructions. This simplifies build processes and promotes consistency across different environments.\n\nKey Principles of Maven:\n\nConvention over Configuration: Many aspects of the build process follow pre-defined conventions, reducing the need for extensive configuration.\n\nDeclarative Style: You declare what you want to achieve instead of specifying the exact steps, making the build process more readable and maintainable.\n\nDependency Management: Maven utilizes a central repository system like Maven Central, ensuring everyone uses the same versions of libraries and dependencies, reducing conflicts.\n\nPlugin-based Architecture: Plugins provide extensibility, allowing you to customize the build process for specific needs using predefined or custom plugins.\n\nBenefits of Using Maven:\n\nIncreased Productivity: Automating repetitive tasks saves time and reduces manual effort.\n\nImproved Consistency: Enforces consistent build processes across different environments and teams.\n\nSimplified Project Management: POM provides a centralized configuration point for all project details.\n\nLarge Community and Resources: Extensive documentation, tutorials, and community support are available.\n\nAlternatives to Maven:\n\nAnt: An older, XML-based build tool offering more flexibility but requiring more manual configuration.\n\nGradle: A modern Groovy-based build tool offering a powerful DSL and more flexibility compared to Maven.\n\nIs Maven still relevant?\n\nDespite newer tools like Gradle, Maven remains a dominant player in the Java ecosystem. Its focus on simplicity, conventions, and a large community makes it a popular choice for various project types, especially for enterprise-level applications. Understanding Maven is valuable for Java developers as it forms the foundation of many large-scale projects and is frequently encountered in the industry.\n\nAdditional Notes:\n\nMaven can be integrated with other tools like IDEs and continuous integration/continuous delivery (CI/CD) pipelines.\n\nLearning Maven involves understanding the POM format, available plugins, and best practices for project configuration.","type":"content","url":"/xjabt-javamaven","position":1},{"hierarchy":{"lvl1":"Slider and Progress Bar"},"type":"lvl1","url":"/xjslider-progbar","position":0},{"hierarchy":{"lvl1":"Slider and Progress Bar"},"content":"This Java program demonstrates the interaction between GUI components—specifically JSlider, JProgressBar, and JCheckBox—to visually represent temperature conversion from Fahrenheit to Celsius. Users move a slider to choose a temperature, see the Celsius equivalent, and view progress on a bar. They can also toggle descriptive labels on the slider using a checkbox.","type":"content","url":"/xjslider-progbar","position":1},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":"Key Component Properties:"},"type":"lvl2","url":"/xjslider-progbar#key-component-properties","position":2},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":"Key Component Properties:"},"content":"","type":"content","url":"/xjslider-progbar#key-component-properties","position":3},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl3":"JSlider:","lvl2":"Key Component Properties:"},"type":"lvl3","url":"/xjslider-progbar#jslider","position":4},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl3":"JSlider:","lvl2":"Key Component Properties:"},"content":"minValue, maxValue: Sets the minimum and maximum selectable values.\n\nsetMajorTickSpacing, setMinorTickSpacing: Control tick mark intervals.\n\nsetPaintTicks(true): Displays tick marks.\n\nsetPaintLabels(true): Enables or disables label display.\n\nsetLabelTable: Allows custom descriptive labels at specific values.","type":"content","url":"/xjslider-progbar#jslider","position":5},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl3":"JProgressBar:","lvl2":"Key Component Properties:"},"type":"lvl3","url":"/xjslider-progbar#jprogressbar","position":6},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl3":"JProgressBar:","lvl2":"Key Component Properties:"},"content":"Visual indicator of progress within a range (set by minimum and maximum).\n\nsetStringPainted(true): Displays custom text within the progress bar.\n\nsetValue: Updates current progress visually.","type":"content","url":"/xjslider-progbar#jprogressbar","position":7},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl3":"JCheckBox:","lvl2":"Key Component Properties:"},"type":"lvl3","url":"/xjslider-progbar#jcheckbox","position":8},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl3":"JCheckBox:","lvl2":"Key Component Properties:"},"content":"A toggle control allowing users to enable or disable features (in this case, descriptive slider labels).\n\nAction listeners respond immediately to user interaction, updating the interface dynamically.","type":"content","url":"/xjslider-progbar#jcheckbox","position":9},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":"Build Sequence Explanation:"},"type":"lvl2","url":"/xjslider-progbar#build-sequence-explanation","position":10},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":"Build Sequence Explanation:"},"content":"The program’s GUI elements are built in a deliberate sequence to ensure correct layout and functionality:\n\nJFrame setup: Initializes the window size, layout, and default behaviors first since all components rely on this container.\n\nJLabel setup: Labels must exist before dynamic updates happen; they’re essential for displaying temperature values clearly.\n\nJCheckBox setup: Created before the slider because it controls slider labeling—initializing it first ensures it’s ready for interaction.\n\nJSlider setup: Relies on checkbox functionality for label toggling; therefore, it must follow checkbox initialization.\n\nJProgressBar setup: Set up last, as it reflects the slider’s current value dynamically, depending upon previous components’ interactions.\n\nThis sequence ensures each component has the required context and dependencies met, providing smooth, error-free interactions.","type":"content","url":"/xjslider-progbar#build-sequence-explanation","position":11},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":"Example Code"},"type":"lvl2","url":"/xjslider-progbar#example-code","position":12},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":"Example Code"},"content":"","type":"content","url":"/xjslider-progbar#example-code","position":13},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":""},"type":"lvl2","url":"/xjslider-progbar","position":14},{"hierarchy":{"lvl1":"Slider and Progress Bar","lvl2":""},"content":"/*\nDeveloper: James Goudy\n */\npackage j2x_slider;\n\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.util.Hashtable;\nimport javax.swing.BorderFactory;\nimport javax.swing.JCheckBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JProgressBar;\nimport javax.swing.JSlider;\n\nclass ScrollBarDemo {\n\n    // JFrame and JFrame Components\n    JFrame myFrame;\n\n    JLabel lblTempDesc;\n    JLabel lblTempCon;\n    JLabel lblSliderValue;\n\n    JSlider sb;\n\n    JProgressBar pb;\n\n    JCheckBox checkBox;\n\n    // slider max and min values\n    int minValue;\n    int maxValue;\n\n    // constructor\n    public ScrollBarDemo()\n    {\n\n        // slider max and min values\n        minValue = -50;\n        maxValue = 225;\n\n        // helper functions \n        setupFrame();\n        setupLabel();\n        setupCheckBox();\n        setupSlider();\n        setupProgressBar();\n\n        // better to put set visible here\n        // forces a redraw to all components\n        myFrame.setVisible(true);\n\n        // setup initial vaues\n        convertFtoC();\n        getFarenheit();\n    }\n\n    private void setupFrame()\n    {\n        // create frame\n        myFrame = new JFrame(\"Scrollbar Demo\");\n        \n        // set frame properties\n        myFrame.setLayout(null);\n        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        myFrame.setSize(800, 300);\n        myFrame.setLocationRelativeTo(null);\n    }\n\n    private void setupLabel()\n    {\n        // remember setbounds(x position, y position, width, height)\n        \n        // create temp description label\n        lblTempDesc = new JLabel(\"Celsius: \");\n        lblTempDesc.setBounds(25, 30, 50, 25);\n\n        // create temp conversion  label\n        lblTempCon = new JLabel(\"0.0\");\n        lblTempCon.setBounds(75, 30, 50, 25);\n\n        // create slider value  label\n        lblSliderValue = new JLabel(\"0.0\");\n        lblSliderValue.setBounds(125, 30, 50, 25);\n\n        // add the labels to the form\n        myFrame.add(lblTempDesc);\n        myFrame.add(lblTempCon);\n        myFrame.add(lblSliderValue);\n    }\n\n    private void setupCheckBox()\n    {\n        // create the checkbox\n        checkBox = new JCheckBox(\"Toggle Labels\");\n        \n        // set location and dimensions\n        checkBox.setBounds(175, 30, 150, 25);\n\n        // add a listener to check if the box is checked\n        checkBox.addActionListener((ActionEvent e) -> {\n            updateSliderLabels();\n        });\n\n        // add checkbox to frame\n        myFrame.add(checkBox);\n    }\n\n    private void setupSlider()\n    {\n        // create slider\n        // not that the max, min, and value could be set separately\n        sb = new JSlider(minValue, maxValue, 32);\n        \n        // set location and dimension\n        sb.setBounds(25, 60, 725, 100);\n        \n        // set colors\n        sb.setForeground(Color.blue);\n        sb.setBackground(Color.white);\n        \n        // set ticks\n        sb.setMajorTickSpacing(10);\n        sb.setMinorTickSpacing(5);\n        \n        // remember to paint the ticks and the labels\n        sb.setPaintTicks(true);\n        sb.setPaintLabels(true);\n\n        sb.addChangeListener((e) -> {\n            // update the degree labels if slider is changed\n            convertFtoC();\n            getFarenheit();\n        });\n\n        // add slider to frame\n        myFrame.add(sb);\n    }\n\n    // Converts Fahrenheit to Celsius based on slider's current value\n    private void convertFtoC()\n    {\n        // get slider value\n        double fahrenheit = sb.getValue();\n        \n        // convert to celsius\n        double celsius = (5.0 / 9.0) * (fahrenheit - 32.0);\n        \n        // update label\n        lblTempCon.setText(String.format(\"%.2f\", celsius));\n    }\n\n    // Updates Fahrenheit label and progress bar based on slider value\n    private void getFarenheit()\n    {\n        // update slider value label\n        lblSliderValue.setText(sb.getValue() + \" F °\");\n        \n        // update progressbar value\n        pb.setValue(sb.getValue());\n    }\n\n    // Toggles custom descriptive labels on the slider\n    private void updateSliderLabels()\n    {\n        if (checkBox.isSelected()) {\n            \n            Hashtable<Integer, JLabel> labelTable = new Hashtable<>();\n            labelTable.put(-30, new JLabel(\"Frigid\"));\n            labelTable.put(0, new JLabel(\"Cold\"));\n            labelTable.put(32, new JLabel(\"Freezing\"));\n            labelTable.put(75, new JLabel(\"Nice\"));\n            labelTable.put(115, new JLabel(\"HOT\"));\n            labelTable.put(150, new JLabel(\"Really Hot\"));\n            labelTable.put(212, new JLabel(\"Water Boils\"));\n\n            sb.setLabelTable(labelTable);\n        } else {\n            sb.setLabelTable(null);\n        }\n        sb.setPaintLabels(true);\n        sb.repaint();\n    }\n\n    private void setupProgressBar()\n    {\n        // create progress bar\n        pb = new JProgressBar(minValue, maxValue);\n        \n        // set colors\n        pb.setBackground(Color.darkGray);\n        pb.setForeground(Color.blue);\n        \n        // add a border\n        pb.setBorder(BorderFactory.createEtchedBorder(Color.lightGray, Color.yellow));\n        \n        // add label\n        pb.setString(\"Temperature Scale\");\n        pb.setStringPainted(true);\n        \n        // set location and dimensions\n        pb.setBounds(25, 185, 725, 25);\n\n        // add to frames\n        myFrame.add(pb);\n    }\n}\n\npublic class J2x_Slider {\n\n    public static void main(String[] args)\n    {\n        ScrollBarDemo sbd = new ScrollBarDemo();\n    }\n}\n","type":"content","url":"/xjslider-progbar","position":15},{"hierarchy":{"lvl1":"JTable"},"type":"lvl1","url":"/xjtable","position":0},{"hierarchy":{"lvl1":"JTable"},"content":"","type":"content","url":"/xjtable","position":1},{"hierarchy":{"lvl1":"JTable","lvl2":"Lecture Code Explanation"},"type":"lvl2","url":"/xjtable#lecture-code-explanation","position":2},{"hierarchy":{"lvl1":"JTable","lvl2":"Lecture Code Explanation"},"content":"This code creates a graphical user interface (GUI) application that displays and allows editing of a sample data table. Here’s a breakdown of the code:\n\nClass and Variables:\n\nThe code defines a class Frame1 that extends javax.swing.JFrame. This means it creates a window with a frame border.\n\nSeveral variables are declared to store data used throughout the program:\n\nRNG: A Random object for generating random data.\n\nRows and Cols: Integers specifying the number of rows and columns in the data table.\n\nmySampleData: A 2D String array to hold the sample data.\n\nmodel: A DefaultTableModel object used as the data model for the JTable.\n\nmyTable: A JTable object representing the data table.\n\nALinputFields: An ArrayList of JTextField objects used for adding new records.\n\nmyColNames: An array of Strings containing the column names for the table.\n\nCity_Array: An array of Strings containing city names used in the program.\n\nSeveral other variables are used to store UI layout properties and references to UI components.\n\nData Creation:\n\nThe CreateSampleData method generates random sample data. It populates the mySampleData array with first names, last names, cities, salaries, and unique IDs.\n\nGUI Setup:\n\nThe initComponents method (generated by the GUI builder) initializes the Swing components used in the frame.\n\nThe Frame1   constructor performs most of the application logic:\n\nSets the frame size and location.\n\nCalls CreateSampleData to generate sample data.\n\nCalls setupDataModel to set up the data model for the table.\n\nCalls SetUpMyTable to configure and display the JTable.\n\nCalls other methods to add functionalities like:\n\nA label to display data from a selected row (addDataLabel).\n\nA button to delete a selected row (addDeleteButton).\n\nA search bar to filter data (addSearch).\n\nA checkbox to hide the ID column (hideIDColumn).\n\nInput fields and a button to add new records (setupAddRecord).\n\nTable Configuration (SetUpMyTable):\n\nThis method configures the JTable’s behavior and appearance:\n\nSets the table’s columns to automatically resize.\n\nEnables sorting by clicking column headers.\n\nSets the table selection mode to single selection.\n\nAttaches listeners to the table for selection changes and cell edits.\n\nMakes the table editable.\n\nSets a custom renderer for the salary column to format the numbers.\n\nCreates a scroll pane to hold the table and adds it to the frame.\n\nOther Methods:\n\nsetupDataModel: Creates the data model for the JTable and specifies that all cells are editable.\n\naddDataLabel: Creates and configures a label to display data from the selected row.\n\naddDeleteButton: Creates and configures a button to delete the selected row. It ensures deletion by ID to avoid errors.\n\naddSearch: Creates and configures a search bar to filter the table data based on user input.\n\nfilterRecords: Filters the table data based on the text entered in the search bar.\n\nhideIDColumn: Creates and configures a checkbox to hide the ID column of the table.\n\nsetupAddRecord: Creates and configures input fields and a button to allow adding new records to the table.\n\nSetupCityDropDown: Creates a dropdown menu in the city column to allow users to select pre-defined city names.\n\nformatSalary: Sets a custom renderer for the salary column to format the numbers.\n\nprintArray: Prints the contents of the data model to the console for debugging purposes.\n\njmnuPrintActionPerformed: Handles the action when the “Print” menu item is clicked. It attempts to print the JTable using the default printing functionality.\n\nOverall, this code demonstrates how to create a data table with functionalities like sorting, filtering, editing, adding new records, and basic printing using Swing components in Java.","type":"content","url":"/xjtable#lecture-code-explanation","position":3},{"hierarchy":{"lvl1":"JTable","lvl2":"class NumberTableCellRenderer"},"type":"lvl2","url":"/xjtable#class-numbertablecellrenderer","position":4},{"hierarchy":{"lvl1":"JTable","lvl2":"class NumberTableCellRenderer"},"content":"This code defines a custom table cell renderer class named NumberTableCellRenderer that inherits from DefaultTableCellRenderer. It’s specifically designed to format table cell values as currency.\n\nHere’s a breakdown of the code:\n\nClass Inheritance:\n\nThe class NumberTableCellRenderer extends DefaultTableCellRenderer. This means it inherits all the functionalities of the default renderer and can override specific methods to customize the rendering behavior.\n\nConstructor (NumberTableCellRenderer):\n\nThe constructor sets the horizontal alignment of the text in the cell to right-aligned (JLabel.RIGHT). This is commonly used for displaying numeric values.\n\nMethod: getTableCellRendererComponent:\n\nThis is the most important method in a custom cell renderer. It’s called whenever a cell needs to be rendered in the table.\n\nIt takes several arguments:\n\ntable: The JTable object.\n\nvalue: The value of the object to be rendered in the cell.\n\nisSelected: Whether the cell is currently selected.\n\nhasFocus: Whether the cell has focus.\n\nrow: The row index of the cell.\n\ncolumn: The column index of the cell.\n\nThe method performs the following steps:\n\nTries to format the value as currency:\n\nIf the value is a Number object, it uses NumberFormat.getNumberInstance().format(value) to format it according to the current locale’s number formatting rules (e.g., commas for thousands separators).\n\nIf the value is a String, it attempts to parse it as an integer using Integer.parseInt(String.valueOf(value)). Then, it prepends a dollar sign (“$”) and formats the integer value using NumberFormat.getNumberInstance().format(ivalue).\n\nCalls the super.getTableCellRendererComponent(...) method. This is important because it retrieves the base renderer component and applies any customizations we made (like setting the alignment) on top of the default behavior.\n\nIf any exception occurs during formatting (catch (Exception ez)), it returns null. This might indicate an issue with the data type or format, and the cell will likely be left blank.\n\nSummary:\n\nThis custom renderer ensures that any numeric values displayed in the table are formatted as currency, improving readability and user experience.","type":"content","url":"/xjtable#class-numbertablecellrenderer","position":5},{"hierarchy":{"lvl1":"JTable","lvl2":"The Code"},"type":"lvl2","url":"/xjtable#the-code","position":6},{"hierarchy":{"lvl1":"JTable","lvl2":"The Code"},"content":"/*\nProgrammer: James Goudy\nProject: JTable\nDate: April 19, 2024\n\n\n */\npackage j2_jtable_lecture_rev24;\n\nimport java.awt.Component;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.FocusEvent;\nimport java.awt.event.FocusListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport javax.swing.DefaultCellEditor;\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JTextField;\nimport javax.swing.ListSelectionModel;\nimport javax.swing.event.ListSelectionListener;\nimport javax.swing.event.TableModelEvent;\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.DefaultTableModel;\nimport javax.swing.table.TableColumn;\nimport javax.swing.table.DefaultTableCellRenderer;\nimport java.text.NumberFormat;\nimport javax.swing.JCheckBox;\nimport javax.swing.RowFilter;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.table.TableColumnModel;\nimport javax.swing.table.TableModel;\nimport javax.swing.table.TableRowSorter;\n\nclass NumberTableCellRenderer extends DefaultTableCellRenderer {\n\n    public NumberTableCellRenderer() {\n        // Align the text right-justified within the table cell\n        setHorizontalAlignment(JLabel.RIGHT);\n    }\n\n    @Override\n    public Component getTableCellRendererComponent(JTable table, Object value,\n            boolean isSelected, boolean hasFocus, int row, int column) {\n\n        try {\n            // Check if the value is already a Number object\n            if (value instanceof Number) {\n                // Use the default number formatter to format the value\n                value = NumberFormat.getNumberInstance().format(value);\n            } else if (value instanceof String) {\n                // If the value is a String, try to parse it to an integer\n                int intValue = Integer.parseInt(String.valueOf(value));\n                // Prepend a dollar sign ($) and format the integer value\n                value = \"$\" + NumberFormat.getNumberInstance().format(intValue);\n            } else {\n                // If the value isn't a Number or a parsable String, keep it as is\n            }\n\n            // Call the superclass method to set other cell renderer properties\n            return super.getTableCellRendererComponent(table, value, isSelected,\n                    hasFocus, row, column);\n        } catch (Exception exception) {\n            // Handle potential exceptions during conversion or formatting\n            // (e.g., NumberFormatException if the String cannot be parsed)\n            // In this case, return null to indicate an error\n            return null;\n        }\n    }\n}\n\npublic class Frame1 extends javax.swing.JFrame {\n\n    // Random number generator object\n    Random RNG;\n\n    // Define number of rows and columns in the data table\n    int Rows = 50;\n    int Cols = 5;\n\n    // Create a 2D String array to hold the sample data\n    String[][] mySampleData;\n\n    // Default table data model object\n    DefaultTableModel model;\n\n    // JTable object representing the data table\n    JTable myTable;\n\n    // ArrayList to store JTextField objects used for adding new records\n    ArrayList<JTextField> ALinputFields = new ArrayList();\n\n    // Define column names for the table\n    String[] myColNames = {\n        \"First Name\", \"Last Name\", \"City\", \"Salary\", \"ID\"\n    };\n\n    // String array containing pre-defined city names\n    String[] City_Array = {\n        \"Kalispell\", \"Polson\", \"Whitefish\", \"Missoula\", \"Helena\",\n        \"Bozeman\", \"Chicago\", \"New York\", \"Seatle\", \"Rock Island\"\n    };\n\n    // Text field for search functionality\n    JTextField jtfSearch;\n\n    // ListSelectionModel object to handle table selection\n    ListSelectionModel mySelectModel;\n\n    // Label to display data from the selected row\n    JLabel jlblData;\n\n    // Define initial Y positions for label components\n    int RowLabel = 10;\n    int Row1YPos = 40;\n    int Row2YPos = 85;\n    int Row3Ypos = 115;\n    int Row4yYpos = 150;\n\n    // Boolean flag to control ID column visibility\n    Boolean showIdCol = true;\n\n    public Frame1() {\n        // Initialize Swing components using GUI builder (generated code)\n        initComponents();\n\n        // Set frame size and location\n        this.setSize(700, 750);\n        this.setLocationRelativeTo(null);\n        \n        // Set Frame Title\n        this.setTitle(\"JTable - Create, Read, Update, Delete\");\n\n        // Generate random sample data\n        createSampleData();\n\n        // Setup data model for the table\n        setupDataModel();\n\n        // Configure and display the JTable\n        SetUpMyTable();\n\n        // Add label to display data from selected row\n        addDataLabel(300);\n\n        // Add button to delete the selected row\n        addDeleteButton();\n\n        // Add search functionality\n        addSearch();\n\n        // Add checkbox to hide the ID column\n        hideIDColumn();\n\n        // Add functionality to add new records\n        setupAddRecord();\n    }\n\n    private void setupDataModel() {\n        // Define data types for each column\n        final Class[] columnClass = new Class[]{\n            String.class, String.class,\n            String.class, Integer.class, Integer.class\n        };\n\n        // Setup the data model with sample data and column names\n        model = new DefaultTableModel(mySampleData, myColNames) {\n            @Override\n            public boolean isCellEditable(int row, int column) {\n                // Allow editing all cells\n                return true;\n            }\n\n            @Override\n            public Class<?> getColumnClass(int columnIndex) {\n                // Return the corresponding data type for each column\n                return columnClass[columnIndex];\n            }\n        };\n\n        // Create the JTable using the data model\n        myTable = new JTable(model);\n    }\n\n    private void SetUpMyTable() {\n\n        // Resize the columns automatically to fit their content\n        myTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);\n\n        // Enable sorting by clicking column headers\n        myTable.setAutoCreateRowSorter(true);\n\n        // Make the table visible and enabled\n        myTable.setVisible(true);\n        myTable.setEnabled(true);\n\n        // Selection Options\n        // ListSelectionModel.MULTIPLE_INTERVAL_SELECTION, \n        // ListSelectionModel.SINGLE_INTERVAL_SELECTION\n        // ListSelectionModel.SINGLE_SELECTION\n        // Set the selection mode to single selection \n        // (only one row can be selected at a time)\n        myTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n        // Get the ListSelectionModel object associated with the table\n        ListSelectionModel mySelectModel = myTable.getSelectionModel();\n\n        // Add a listener for changes in row selection\n        mySelectModel.addListSelectionListener(new ListSelectionListener() {\n\n            @Override\n            public void valueChanged(ListSelectionEvent e) {\n\n                // Check if the selection change has finished \n                // (prevents firing multiple times)\n                if (!e.getValueIsAdjusting()) {\n                    int selectedRow = myTable.getSelectedRow();\n                    String rowdata = \"\";\n\n                    // If a row is selected, \n                    //build a string representation of its data\n                    if (selectedRow != -1) {\n                        for (int c = 0; c < Cols; c++) {\n                            rowdata += myTable.getValueAt(selectedRow, c)\n                                    .toString() + \" \";\n                        }\n                    }\n                    jlblData.setText(rowdata);\n                }\n            }\n        });\n\n        // Add a listener for changes\n        // in the table model (for debugging purposes)\n        myTable.getModel().addTableModelListener(new TableModelListener() {\n            @Override\n            public void tableChanged(TableModelEvent e) {\n                // Print the current table data (for testing)\n                printArray();\n            }\n        });\n\n        // Setup a dropdown menu for the \"City\" column\n        setupCityDropDown();\n\n        // Format the \"Salary\" column to display currency\n        formatSalary();\n\n        // Create a scroll pane to hold the table and add it to the frame\n        JScrollPane myScrollPane = new JScrollPane(myTable);\n        myScrollPane.setLocation(50, Row4yYpos);\n        myScrollPane.setVisible(true);\n        myScrollPane.setSize(600, 400);\n        this.add(myScrollPane);\n    }\n\n    private void addDataLabel(int lblWidth) {\n        // Create and configure the label to display data from the selected row\n        jlblData = new JLabel();\n        jlblData.setSize(lblWidth, 25);\n        jlblData.setVisible(true);\n        jlblData.setLocation(50, Row3Ypos);\n\n        this.add(jlblData);\n    }\n\n    private void addDeleteButton() {\n\n        // Define button width and height\n        int btnWidth = 150;\n        int btnHeight = 25;\n\n        // Create a JButton for deleting the selected row\n        JButton btnDelete = new JButton();\n\n        // Set button text and make it visible\n        btnDelete.setText(\"Delete Selected\");\n        btnDelete.setVisible(true);\n\n        // Set button size and location\n        btnDelete.setSize(btnWidth, btnHeight);\n        btnDelete.setLocation(50, Row2YPos);\n\n        // Add action listener to handle button clicks\n        btnDelete.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n\n                    // **Important:** Delete by a key \n                    // instead of selected row index\n                    int selectedRow = myTable.getSelectedRow();\n\n                    // Extract the unique key from the selected row \n                    // (assuming column 4 holds the key)\n                    String selectedKey = myTable.getValueAt(selectedRow, 4)\n                            .toString();\n\n                    System.out.println(\"Key to be deleted: \" + selectedKey);\n\n                    // Loop through all rows in the table model\n                    for (int row = 0; row < model.getRowCount(); row++) {\n                        String currentKey = model.getValueAt(row, 4).toString();\n\n                        // Compare current row's key with the selected key\n                        if (currentKey.equals(selectedKey)) {\n                            // If keys match, remove that row from the model\n                            model.removeRow(row);\n                            break; // Exit the loop after finding a match\n                        }\n                    }\n\n                } catch (Exception exception) {\n                    // Display an error message dialog if something goes wrong\n                    JOptionPane.showMessageDialog(null, exception.getMessage());\n                }\n\n                // Refresh the table to reflect the changes\n                myTable.repaint();\n            }\n        });\n\n        // Add the button to the frame\n        this.add(btnDelete);\n    }\n\n    private void addSearch() {\n\n        // Define button width and height\n        int btnWidth = 150;\n        int btnHeight = 25;\n\n        // Create a label for the search bar\n        JLabel lblSearch = new JLabel();\n        lblSearch.setText(\"Search\");\n        lblSearch.setVisible(true);\n        lblSearch.setSize(btnWidth, btnHeight);\n        lblSearch.setLocation(50 + btnWidth + 10, Row2YPos);\n\n        // Add the search label to the frame\n        this.add(lblSearch);\n\n        try {\n            // Create a text field for entering search terms\n            jtfSearch = new JTextField();\n\n            // Add a key listener to handle user input in the search bar\n            jtfSearch.addKeyListener(new KeyListener() {\n\n                @Override\n                public void keyTyped(KeyEvent e) {\n                    // Trigger search filtering whenever a key is typed\n                    filterRecords();\n                    // Request focus back to the search bar for usability\n                    jtfSearch.requestFocus();\n                }\n\n                @Override\n                public void keyPressed(KeyEvent e) {\n                    // Not currently used, but reserved for potential key \n                    // press functionality\n                    // Example: Handle 'Esc' to clear search\n                    if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n                        jtfSearch.setText(\"\");\n                        filterRecords();\n                    }\n                }\n\n                @Override\n                public void keyReleased(KeyEvent e) {\n                    // Not currently used, but reserved \n                    // for potential key release functionality\n                }\n            });\n\n            // Set the size and location of the search text field\n            jtfSearch.setSize((int) (1 * btnWidth), btnHeight);\n            jtfSearch.setVisible(true);\n            jtfSearch.setLocation(50 + (int) (1.25 * btnWidth) + 20, Row2YPos);\n\n            // Add the search text field to the frame\n            this.add(jtfSearch);\n        } catch (Exception e) {\n            // Handle any potential exceptions \n            // during search component creation (optional)\n        }\n    }\n\n    private void filterRecords() {\n\n        // Request focus back to the search bar for usability\n        jtfSearch.requestFocus();\n\n        // Get the current text from the search bar\n        String filterText = jtfSearch.getText();\n\n        // Get the table row sorter object\n        TableRowSorter<TableModel> sorter\n                = (TableRowSorter) myTable.getRowSorter();\n\n        // Create a regular expression filter based on the search text\n        // This filters columns 0, 1, and 2 (adjust based on your search needs)\n        sorter.setRowFilter(RowFilter.regexFilter(filterText, 0, 1, 2));\n\n        // Refresh the table to reflect the filtered data\n        myTable.repaint();\n    }\n\n    private void hideIDColumn() {\n\n        // Define button width and height \n        int btnWidth = 150;\n        int btnHeight = 25;\n\n        // Create a checkbox to allow hiding the ID column\n        JCheckBox chkHideID = new JCheckBox(\"Hide ID Column\");\n        chkHideID.setVisible(true);\n        chkHideID.setSize(btnWidth, btnHeight);\n        chkHideID.setLocation(420, Row2YPos);  // Adjust location as needed\n\n        // Add action listener to handle checkbox selection changes\n        chkHideID.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                // Get the table column model\n                TableColumnModel colModel = myTable.getColumnModel();\n\n                // Get the column object for the ID column\n                TableColumn colID = colModel.getColumn(4);\n\n                // Set the column resizable\n                colID.setResizable(true);\n\n                /*\n                 * IMPORTANT: Set minimum, maximum, \n                 * and preferred width before calling setWidth\n                 * This ensures the column width changes \n                 * are applied correctly.\n                 */\n                int minWidth = 1;\n                int maxWidth = 100;\n\n                if (chkHideID.isSelected()) {\n                    // Hide the ID column by setting \n                    // its width to a minimal value\n                    colID.setMinWidth(minWidth);\n                    colID.setMaxWidth(minWidth);\n                    colID.setPreferredWidth(minWidth);\n                    colID.setWidth(minWidth);\n                } else {\n                    // Show the ID column by setting \n                    // its width to a reasonable value\n                    colID.setMinWidth(maxWidth);\n                    colID.setMaxWidth(maxWidth);\n                    colID.setPreferredWidth(maxWidth);\n                    colID.setWidth(maxWidth);\n                }\n\n                // Refresh the table to reflect the changes\n                myTable.repaint();\n            }\n        });\n\n        // Add the checkbox to the frame\n        this.add(chkHideID);\n    }\n\n    private void setupAddRecord() {\n\n        // Define label positioning variables (x, y, width, height, spacing)\n        int labelX = 50;\n        int labelY = RowLabel;\n        int labelWidth = 100;\n        int labelHeight = 30;\n        int labelSpacing = 10;\n\n        // Define text field positioning variables\n        int fieldX = 50;\n        int fieldY = Row1YPos;\n        int fieldWidth = 100;\n        int fieldHeight = 30;\n        int fieldSpacing = 10;\n\n        // Labels for each input field\n        String[] inputLabels = {\n            \"First Name\", \"Last Name\", \"City\", \"Salary\"\n        };\n\n        // Create and position labels and text fields for each input\n        for (int i = 0; i < inputLabels.length; i++) {\n            JLabel label = new JLabel();\n            label.setSize(labelWidth, labelHeight);\n            label.setText(inputLabels[i]);\n            label.setVisible(true);\n            label.setLocation(labelX, labelY);\n\n            JTextField inputField = new JTextField();\n            inputField.setSize(fieldWidth, fieldHeight);\n            // Initially set the text field value to an empty string\n            inputField.setText(\"\");\n            inputField.setVisible(true);\n            inputField.setLocation(fieldX, fieldY);\n\n            // Add the text field to an ArrayList for easier access later\n            ALinputFields.add(inputField);\n\n            // Add the label and text field to the frame\n            this.add(label);\n            this.add(inputField);\n\n            // Update positions for the next label and text field\n            fieldX += fieldWidth + fieldSpacing;\n            labelX += labelWidth + labelSpacing;\n        }\n\n        // Create and position the \"Add\" button\n        JButton btnAdd = new JButton();\n        btnAdd.setSize(fieldWidth, fieldHeight);\n        btnAdd.setText(\"Add\");\n        btnAdd.setVisible(true);\n        btnAdd.setLocation(fieldX, fieldY); // Use the last calculated positions\n\n        // Add action listener to handle the \"Add\" button click\n        btnAdd.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                addData();\n            }\n\n            private void addData() {\n                // Check if the salary field contains a valid double value\n                try {\n                    Double.valueOf(ALinputFields.get(3).getText());\n                } catch (Exception exception) {\n                    // Display error message and clear the salary field\n                    jlblData.setText(\"Error: \" + exception.getMessage());\n                    ALinputFields.get(3).setText(\"\");\n                    ALinputFields.get(3).requestFocus();\n                    return;  // Exit the method if there's an error\n                }\n\n                // Check if all required fields \n                // (first name, last name, city) are filled\n                if (ALinputFields.get(0).getText().length() != 0\n                        && ALinputFields.get(1).getText().length() != 0\n                        && ALinputFields.get(2).getText().length() != 0) {\n\n                    // Create a new object array to hold the data for the new row\n                    // Add space for the key\n                    Object[] newData = new Object[ALinputFields.size() + 1];\n\n                    // Copy data from text fields into the new data array\n                    for (int i = 0; i < ALinputFields.size(); i++) {\n                        newData[i] = ALinputFields.get(i).getText();\n                    }\n\n                    // Generate a unique key for the new record\n                    String key = String.valueOf(ALinputFields.get(0).toString()\n                            + ALinputFields.get(1).toString()\n                            + ALinputFields.get(2).toString());\n\n                    // Use a combination of hash and random number\n                    // This ensures a unique key incase there are duplicate\n                    // names and places\n                    key = String.valueOf(Math.abs(key.hashCode()\n                            + RNG.nextInt()));\n                    newData[4] = key;\n\n                    // Add the new row to the table model\n                    model.addRow(newData);\n\n                    // Clear all text fields after adding the data\n                    for (int i = 0; i < ALinputFields.size(); i++) {\n                        ALinputFields.get(i).setText(\"\");\n                    }\n\n                    // Display success message\n                    jlblData.setText(\"Record Added\");\n                }\n            }\n        });\n    }\n\n    private void setupCityDropDown() {\n\n        // Get the \"City\" column from the table model\n        // Assuming \"City\" is at index 2\n        TableColumn cityColumn = myTable.getColumnModel().getColumn(2);\n\n        // Create a combo box with city options\n        JComboBox cityCombo = new JComboBox();\n        for (int i = 0; i < City_Array.length; i++) {\n            // Add each city from the City_Array to the combo box\n            cityCombo.addItem(City_Array[i]);\n        }\n\n        // Set the cell editor for the \"City\" column to the combo box\n        cityColumn.setCellEditor(new DefaultCellEditor(cityCombo));\n        // This allows users to select a city from the dropdown in that column\n    }\n\n    private void formatSalary() {\n\n        // Get the \"Salary\" column from the table model\n        // Assuming \"Salary\" is at index 3\n        TableColumn salaryColumn = myTable.getColumnModel().getColumn(3);\n\n        // Set a cell renderer for the \"Salary\" column \n        // to display numbers in a specific format\n        salaryColumn.setCellRenderer(new NumberTableCellRenderer());\n        // This class typically formats numbers with commas for thousands separators.\n\n        // **Alternative way to format numbers (commented out):**\n        // DecimalFormat df = new DecimalFormat(\"###,###,###\");\n        // df.format(111222333);\n        // You can use this approach if you need more control \n        // over the formatting (e.g., number of decimal places).\n        // This creates a DecimalFormat object with a specific pattern \n        // and then uses it to format a number.\n    }\n\n    private void createSampleData() {\n\n        // Declare variables for first name, last name, city, and salary\n        String firstName, lastName, city;\n        int salary = 0;\n        // Create a Random object for generating random values\n        RNG = new Random();\n\n        // Define arrays for first names and last names\n        String[] firstNameArray = {\n            \"Bob\", \"Jim\", \"Jane\", \"Jody\", \"Jill\", \"Tom\", \"Steve\",\n            \"Sue\", \"Sara\", \"Dave\", \"Darla\", \"Deb\", \"Emily\", \"Joe\",\n            \"Brian\", \"Rodney\"\n        };\n        String[] lastNameArray = {\n            \"Rogers\", \"Smith\", \"Rodes\",\n            \"Brady\", \"Gravey\", \"Knucles\", \"Heavers\",\n            \"Harvey\", \"Brackman\", \"Graves\", \"Swanson\"\n        };\n\n        // Sort the city array (assuming it's already defined)\n        // Create a 2D String array to store sample data\n        mySampleData = new String[Rows][Cols];\n\n        // Fill the sample data array with random values\n        for (int row = 0; row < Rows; row++) {\n\n            // Get random first name, last name, \n            // and city from their respective arrays\n            firstName = firstNameArray[RNG.nextInt(firstNameArray.length)];\n            lastName = lastNameArray[RNG.nextInt(lastNameArray.length)];\n            city = City_Array[RNG.nextInt(City_Array.length)];\n\n            // Generate a random salary between 40,000 and 499,999\n            salary = RNG.nextInt(500000) + 40000;\n\n            // Assign values to the corresponding columns \n            // in the sample data array\n            mySampleData[row][0] = firstName;\n            mySampleData[row][1] = lastName;\n            mySampleData[row][2] = city;\n            // Convert salary to string\n            mySampleData[row][3] = String.valueOf(salary);\n\n            // Generate a unique key for the data row\n            String key = String.valueOf(Math.abs(\n                    (long) (firstName + lastName + city).hashCode()\n                    + RNG.nextInt()));\n            mySampleData[row][4] = key;\n        }\n    }\n\n    /**\n     * This method prints the contents of the table model to the console.\n     */\n    private void printArray() {\n\n        // Loop through all rows and columns of the table model\n        for (int row = 0; row < model.getRowCount(); row++) {\n            for (int col = 0; col < model.getColumnCount(); col++) {\n                // Get the value at the current row and column from the model\n                Object value = model.getValueAt(row, col);\n                // Print the value with a space separator\n                System.out.print(value + \" \");\n            }\n            // Print a new line after each row\n            System.out.println(\"\");\n        }\n\n        // Print a separator line for readability\n        System.out.println(\"\\n---------------\\n\");\n    }\n\n    /**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jMenuBar1 = new javax.swing.JMenuBar();\n        jMenu1 = new javax.swing.JMenu();\n        jmnuPrint = new javax.swing.JMenuItem();\n        jmuQuit = new javax.swing.JMenuItem();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n\n        jMenu1.setText(\"File\");\n\n        jmnuPrint.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.CTRL_DOWN_MASK));\n        jmnuPrint.setText(\"Print\");\n        jmnuPrint.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jmnuPrintActionPerformed(evt);\n            }\n        });\n        jMenu1.add(jmnuPrint);\n\n        jmuQuit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_DOWN_MASK));\n        jmuQuit.setText(\"Quit\");\n        jmuQuit.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                jmuQuitActionPerformed(evt);\n            }\n        });\n        jMenu1.add(jmuQuit);\n\n        jMenuBar1.add(jMenu1);\n\n        setJMenuBar(jMenuBar1);\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 565, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 536, Short.MAX_VALUE)\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void jmnuPrintActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jmnuPrintActionPerformed\n    {//GEN-HEADEREND:event_jmnuPrintActionPerformed\n\n        // Create a JFrame window with the title \"Printing\"\n        JFrame myFrame = new JFrame(\"Printing\");\n\n        // Set the frame to always stay on top of other windows\n        myFrame.setAlwaysOnTop(true);\n\n        try {\n            // Attempt to print the table using the table's print method\n            if (!myTable.print()) {\n                // Printing was cancelled by the user\n                System.err.println(\"User Cancelled Printing\");\n\n                // Display an error message dialog to the user\n                JOptionPane.showMessageDialog(myFrame,\n                        \"User Cancelled Printing\",\n                        \"User Cancelled Printing\",\n                        JOptionPane.ERROR_MESSAGE);\n            }\n        } catch (java.awt.print.PrinterException ex) {\n            // An exception occurred during printing\n            // Display an error message dialog with the exception message\n            JOptionPane.showMessageDialog(myFrame,\n                    ex.getMessage(),\n                    \"Printer Error\",\n                    JOptionPane.ERROR_MESSAGE);\n        }\n\n\n    }//GEN-LAST:event_jmnuPrintActionPerformed\n\n    private void jmuQuitActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jmuQuitActionPerformed\n    {//GEN-HEADEREND:event_jmuQuitActionPerformed\n        // Terminate the program with a successful exit code (0)\n        System.exit(0);\n    }//GEN-LAST:event_jmuQuitActionPerformed\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String args[]) {\n        /*\n         * Set the Nimbus look and feel\n         */\n        //<editor-fold defaultstate=\"collapsed\" desc=\" Look and feel setting code (optional) \">\n        /*\n         * If Nimbus (introduced in Java SE 6) is not available, stay with the\n         * default look and feel.\n         * For details see\n         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html\n         */\n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"Nimbus\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        //</editor-fold>\n        //</editor-fold>\n        //</editor-fold>\n        //</editor-fold>\n        //</editor-fold>\n        //</editor-fold>\n        //</editor-fold>\n        //</editor-fold>\n\n        /*\n         * Create and display the form\n         */\n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new Frame1().setVisible(true);\n            }\n        });\n    }\n\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JMenu jMenu1;\n    private javax.swing.JMenuBar jMenuBar1;\n    private javax.swing.JMenuItem jmnuPrint;\n    private javax.swing.JMenuItem jmuQuit;\n    // End of variables declaration//GEN-END:variables\n\n}\n","type":"content","url":"/xjtable#the-code","position":7},{"hierarchy":{"lvl1":"JTable","lvl2":"Finished Application"},"type":"lvl2","url":"/xjtable#finished-application","position":8},{"hierarchy":{"lvl1":"JTable","lvl2":"Finished Application"},"content":"","type":"content","url":"/xjtable#finished-application","position":9},{"hierarchy":{"lvl1":"Layout Managers"},"type":"lvl1","url":"/xlayoutmangers","position":0},{"hierarchy":{"lvl1":"Layout Managers"},"content":"FlowLayout\n\nBorderLayout\n\nGridLayout\n\nBoxLayout\n\nGridBagLayout\n\nEach layout will be demonstrated in a tabbed pane, so you can easily switch between layouts during the demonstration.","type":"content","url":"/xlayoutmangers","position":1},{"hierarchy":{"lvl1":"Layout Managers","lvl2":"Example code"},"type":"lvl2","url":"/xlayoutmangers#example-code","position":2},{"hierarchy":{"lvl1":"Layout Managers","lvl2":"Example code"},"content":"/*\nDemo of Layout Managers\n */\npackage j2_layoutmanager_demo;\n\n\n\nimport javax.swing.*;\nimport java.awt.*;\n\nclass LayoutManagerDemo extends JFrame {\n\n    public LayoutManagerDemo() {\n        setTitle(\"Layout Manager Demonstration\");\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setSize(600, 400);\n        setLocationRelativeTo(null); // Center on screen\n\n        JTabbedPane tabbedPane = new JTabbedPane();\n\n        tabbedPane.addTab(\"FlowLayout\", createFlowLayoutPanel());\n        tabbedPane.addTab(\"BorderLayout\", createBorderLayoutPanel());\n        tabbedPane.addTab(\"GridLayout\", createGridLayoutPanel());\n        tabbedPane.addTab(\"BoxLayout\", createBoxLayoutPanel());\n        tabbedPane.addTab(\"GridBagLayout\", createGridBagLayoutPanel());\n\n        add(tabbedPane);\n\n        setVisible(true);\n    }\n\n    private JPanel createFlowLayoutPanel() {\n        JPanel panel = new JPanel(new FlowLayout(FlowLayout.CENTER, 10, 10));\n        for (int i = 1; i <= 5; i++) {\n            panel.add(new JButton(\"Button \" + i));\n        }\n        return panel;\n    }\n\n    private JPanel createBorderLayoutPanel() {\n        JPanel panel = new JPanel(new BorderLayout(5, 5));\n        panel.add(new JButton(\"North\"), BorderLayout.NORTH);\n        panel.add(new JButton(\"South\"), BorderLayout.SOUTH);\n        panel.add(new JButton(\"East\"), BorderLayout.EAST);\n        panel.add(new JButton(\"West\"), BorderLayout.WEST);\n        panel.add(new JButton(\"Center\"), BorderLayout.CENTER);\n        return panel;\n    }\n\n    private JPanel createGridLayoutPanel() {\n        JPanel panel = new JPanel(new GridLayout(2, 3, 5, 5));\n        for (int i = 1; i <= 6; i++) {\n            panel.add(new JButton(\"Button \" + i));\n        }\n        return panel;\n    }\n\n    private JPanel createBoxLayoutPanel() {\n        JPanel panel = new JPanel();\n        panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n        for (int i = 1; i <= 5; i++) {\n            panel.add(Box.createRigidArea(new Dimension(1, 10))); // Add space between buttons\n            panel.add(new JButton(\"Button \" + i));\n        }\n        return panel;\n    }\n\n    private JPanel createGridBagLayoutPanel() {\n        JPanel panel = new JPanel(new GridBagLayout());\n        GridBagConstraints gbc = new GridBagConstraints();\n        gbc.insets = new Insets(5, 5, 5, 5); // Padding around components\n\n        for (int i = 0; i < 3; i++) {\n            gbc.gridx = i;\n            gbc.gridy = 0;\n            panel.add(new JButton(\"Button \" + (i + 1)), gbc);\n        }\n\n        gbc.gridx = 0;\n        gbc.gridy = 1;\n        gbc.gridwidth = 3; // Span across 3 columns\n        panel.add(new JButton(\"Wide Button\"), gbc);\n\n        return panel;\n    }\n\n//    public static void main(String[] args) {\n//        SwingUtilities.invokeLater(LayoutManagerDemo::new);\n//    }\n}\n\n\n\n/**\n *\n * @author jgoudy\n */\npublic class J2_LayoutManager_Demo {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args)\n    {\n        \n        LayoutManagerDemo LMD = new LayoutManagerDemo();\n        \n    }\n    \n}\n","type":"content","url":"/xlayoutmangers#example-code","position":3},{"hierarchy":{"lvl1":"Layout Managers","lvl2":"Notes:"},"type":"lvl2","url":"/xlayoutmangers#notes","position":4},{"hierarchy":{"lvl1":"Layout Managers","lvl2":"Notes:"},"content":"FlowLayout: Places components in a line, wrapping as needed.\n\nBorderLayout: Divides the container into five regions (North, South, East, West, Center).\n\nGridLayout: Arranges components in a grid of equal-sized cells.\n\nBoxLayout: Aligns components either vertically (Y_AXIS) or horizontally (X_AXIS).\n\nGridBagLayout: Flexible, allows fine-tuned positioning and sizing.","type":"content","url":"/xlayoutmangers#notes","position":5},{"hierarchy":{"lvl1":"Layout Managers","lvl2":"References:"},"type":"lvl2","url":"/xlayoutmangers#references","position":6},{"hierarchy":{"lvl1":"Layout Managers","lvl2":"References:"},"content":"Oracle, Creating a GUI with Swing - Layout Management (\n\nlink)\n\nOracle, How to Use BorderLayout (\n\nlink)\n\nOracle, How to Use BoxLayout (\n\nlink)\n\nOracle, How to Use GridBagLayout (\n\nlink)","type":"content","url":"/xlayoutmangers#references","position":7},{"hierarchy":{"lvl1":"Letters vs Digits"},"type":"lvl1","url":"/xlettersvsdigits","position":0},{"hierarchy":{"lvl1":"Letters vs Digits"},"content":"","type":"content","url":"/xlettersvsdigits","position":1},{"hierarchy":{"lvl1":"Letters vs Digits","lvl2":"Key Points"},"type":"lvl2","url":"/xlettersvsdigits#key-points","position":2},{"hierarchy":{"lvl1":"Letters vs Digits","lvl2":"Key Points"},"content":"","type":"content","url":"/xlettersvsdigits#key-points","position":3},{"hierarchy":{"lvl1":"Letters vs Digits","lvl3":"Character.isAlphabetic()","lvl2":"Key Points"},"type":"lvl3","url":"/xlettersvsdigits#character-isalphabetic","position":4},{"hierarchy":{"lvl1":"Letters vs Digits","lvl3":"Character.isAlphabetic()","lvl2":"Key Points"},"content":"The Character.isAlphabetic() method in Java is used to determine whether a specified character is an alphabet or not. It checks if the character has the characteristics of an alphabet according to the Unicode Standard. Here are the details:\n\nSyntax: Javapublic static boolean isAlphabetic(chr_var)\n\nParameters:chr-var: The Unicode code point of the character to be tested.\n\nReturn Value:\n\nReturns true if the character is a Unicode alphabet character (i.e., an uppercase letter, lowercase letter, title case letter, modifier letter, other letter, or letter number). Otherwise, it returns false.","type":"content","url":"/xlettersvsdigits#character-isalphabetic","position":5},{"hierarchy":{"lvl1":"Letters vs Digits","lvl3":"Character.isDigit()","lvl2":"Key Points"},"type":"lvl3","url":"/xlettersvsdigits#character-isdigit","position":6},{"hierarchy":{"lvl1":"Letters vs Digits","lvl3":"Character.isDigit()","lvl2":"Key Points"},"content":"The Character.isDigit() method in Java is used to determine whether a specified character is a digit or not. Let’s break it down:\n\nSyntax: Javapublic static boolean isDigit(char ch_var)\n\nParameters:\n\nch_var: The character to be tested.\n\nReturn Value:\n\nReturns true if the character is a digit (0-9), and false otherwise.","type":"content","url":"/xlettersvsdigits#character-isdigit","position":7},{"hierarchy":{"lvl1":"Letters vs Digits","lvl3":"Character.isLetter()","lvl2":"Key Points"},"type":"lvl3","url":"/xlettersvsdigits#character-isletter","position":8},{"hierarchy":{"lvl1":"Letters vs Digits","lvl3":"Character.isLetter()","lvl2":"Key Points"},"content":"The Character.isLetter() method in Java is used to determine whether a specified character is a letter or not. Let’s break it down:\n\nSyntax:  Javapublic static boolean isLetter(ch_var)\n\nAI-generated code. Review and use carefully. \n\nMore info on FAQ.\n\nParameters:\n\nch_var: The character to be tested.\n\nReturn Value:\n\nReturns true if the character is a letter (uppercase, lowercase, titlecase, modifier, or other letter), and false otherwise.\n\nIt’s important to note that Character.isAlphabetic might consider some characters as alphabetic that you wouldn’t typically consider letters in English. This is because it adheres to the broader Unicode definition of alphabetic characters. If you specifically want to check for characters that are common letters (a-z, A-Z), you might consider using the Character.isLetter method instead, which has a slightly stricter definition of what constitutes a letter./*\nProject: Menu\nProgrammer: James Goudy\nCopyright: 2024\nThis program demonstrates how to programmically determines numbers and letters\n */\npackage j2x_55_lettersnumbers;\n\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.JTextField;\nimport javax.swing.KeyStroke;\n\npublic class J2x_55_LettersNumbers {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n\n        LettersNumbers myLN = new LettersNumbers();\n\n    }\n\n}\n\nclass LettersNumbers {\n\n    JFrame myJFrame;\n    JTextField myTextField;\n    JLabel myLetters;\n    JLabel myExplain;\n    JLabel myNumbers;\n    JButton myReset;\n\n    JMenuBar mb = new JMenuBar();\n    JMenu mn_File = new JMenu();\n    JMenuItem mi_Quit = new JMenuItem();\n\n    public LettersNumbers() {\n\n        int xPos = 25;\n        int yPos = 15;\n        int myWidth = 300;\n        int myHeight = 25;\n        int myGap = 25;\n        float fsize = 12;\n\n        // Note that we can use HTML for text in a label\n        String purpose = \"\"\"\n                        <html>\n                        <h2 style=\"color:blue;\">Separate Numbers and Letters</h2>\n                        <p>Enter letters and numbers in the text field.\n                        The program will automatically separate them by\n                        letters and numbers.\n                        </p>\n                        </html>\n                         \"\"\";\n\n        // instatiate controls\n        myJFrame = new JFrame();\n        myTextField = new JTextField();\n        myLetters = new JLabel();\n        myNumbers = new JLabel();\n        myExplain = new JLabel();\n        myReset = new JButton();\n\n        // setup\n        setupMenu1(myJFrame, mb, null);\n\n        setUpTheJFrame(myJFrame, 375, 325, \"Letters and Numbers\",\n                Color.white, true);\n\n        setupTextFields(myJFrame, myTextField, xPos, yPos + (myGap * 1),\n                myWidth, fsize, \"\");\n        myTextField.addKeyListener(myKls);\n\n        setupLabel(myJFrame, myLetters, xPos, yPos + (myGap * 2), myWidth,\n                \"\", fsize);\n\n        setupLabel(myJFrame, myNumbers, xPos, yPos + (myGap * 3), myWidth,\n                \"\", fsize);\n\n        setupButton(myJFrame, myReset, xPos, yPos + (myGap * 4), myWidth,\n                \"Reset\", fsize, myAlsReset, myResetKls);\n\n        setupLabel(myJFrame, myExplain, xPos,\n                yPos + (myGap * 4), 500, purpose, 12);\n        // resize the box for the explanation\n        myExplain.setBounds(xPos, yPos + (myGap * 4), 300, 150);\n        myExplain.setText(purpose);\n\n    }\n\n    // Listeners\n    ActionListener myAlsReset = (ActionEvent e) -> {\n        // listener to reset\n        myLetters.setText(\"\");\n        myNumbers.setText(\"\");\n        myTextField.setText(\"\");\n    };\n\n    KeyListener myKls = new KeyListener() {\n        @Override\n        public void keyTyped(KeyEvent e) {\n\n        }\n\n        @Override\n        public void keyPressed(KeyEvent e) {\n            SortLetters(e);\n        }\n\n        @Override\n        public void keyReleased(KeyEvent e) {\n\n        }\n    };\n\n    KeyListener myResetKls = new KeyListener() {\n\n        @Override\n        public void keyTyped(KeyEvent e) {\n        }\n\n        @Override\n        public void keyPressed(KeyEvent e) {\n            if (e.getKeyChar() == KeyEvent.VK_ENTER) {\n                myReset.doClick();\n            }\n        }\n\n        @Override\n        public void keyReleased(KeyEvent e) {\n        }\n    };\n\n    private void SortLetters(KeyEvent evt) {\n\n        String xnumbers;\n        String xletters;\n\n        xnumbers = myNumbers.getText();\n        xletters = myLetters.getText();\n\n        // Is it a number?\n        if (Character.isDigit(evt.getKeyChar())) {\n            xnumbers = xnumbers + evt.getKeyChar();\n            myNumbers.setText(xnumbers);\n\n        }\n\n        // Is it a letter?\n        if (Character.isAlphabetic(evt.getKeyChar())) {\n            xletters = xletters + evt.getKeyChar();\n            myLetters.setText(xletters);\n        }\n\n        // turn letters blue if an 'A' is depre\n        if (evt.getKeyChar() == KeyEvent.VK_A) {\n            myLetters.setForeground(Color.blue);\n        } else {\n            myLetters.setForeground(Color.black);\n\n        }\n    }\n\n    private void setUpTheJFrame(JFrame jf1,\n            int frameWidth, int frameHeight,\n            String frameTitle, Color frameColor,\n            boolean turnLayoutManagerOff) {\n\n        // Set the initial dimensions of the JFrame's window\n        jf1.setSize(frameWidth, frameHeight);\n\n        // Set the JFrame title\n        jf1.setTitle(frameTitle);\n\n        // Apply a custom background color to the content pane\n        // The content pane is the area where items are added to\n        // the frame\n        jf1.getContentPane().setBackground(frameColor);\n\n        // Make the JFrame visible on the screen,\n        // allowing users to interact with it\n        jf1.setVisible(true);\n\n        // Center the JFrame on the user's screen for optimal visibility\n        jf1.setLocationRelativeTo(null);\n\n        // Specify the program's termination behavior\n        // when the JFrame is closed\n        // Exit the program when the frame is closed\n        jf1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Disable the default layout manager, allowing\n        // for manual component positioning\n        // Note: Manual layout can be more complex to manage\n        // disable the default layout manager\n        if (turnLayoutManagerOff) {\n            jf1.setLayout(null);\n        }\n    }  //-----------------------------------------------------\n\n    private void setupLabel(JFrame jf1, JLabel lbl,\n            int xpos, int ypos, int lblWidth,\n            String theText, float labelSize) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        lbl.setFont(lbl.getFont().deriveFont(labelSize));\n\n        // Set the preferred size of the label\n        lbl.setSize(lblWidth, (int) labelSize + 8);\n\n        // Set the text content of the label\n        lbl.setText(theText);\n\n        // Make the label visible\n        lbl.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        lbl.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(lbl);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n    private void setupTextFields(JFrame jf1, JTextField jtxt,\n            int xpos, int ypos, int tfLength, float fsize, String tfText) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        jtxt.setFont(jtxt.getFont().deriveFont(12f));\n\n        // Set the preferred size of the label\n        jtxt.setSize(tfLength, (int) fsize + 8);\n\n        // Set the text content of the label\n        jtxt.setText(tfText);\n\n        // Make the label visible\n        jtxt.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        jtxt.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(jtxt);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n    private void setupButton(JFrame jf1, JButton bttnABttn,\n            int xpos, int ypos, int bttnWidth,\n            String bttnText, float fsize,\n            ActionListener acl, KeyListener keyls) {\n\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        bttnABttn.setFont(bttnABttn.getFont().deriveFont(fsize));\n\n        // Set the preferred size of the label\n        bttnABttn.setSize(bttnWidth, (int) fsize + 8);\n\n        // Set the text content of the label\n        bttnABttn.setText(bttnText);\n\n        // Make the label visible\n        bttnABttn.setVisible(true);\n\n        // Position the label at coordinates (xpos, ypos) within the window\n        bttnABttn.setLocation(xpos, ypos);\n\n        // This action listener listens for the mouse click\n        bttnABttn.addActionListener(acl);\n\n        // This key listener is for listening for the keyboard actions\n        bttnABttn.addKeyListener(keyls);\n\n        // Add the label to the window's content pane\n        jf1.add(bttnABttn);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n\n    }\n\n// Make sure the menu is setup before the frame in the constructor\n// Setup the File menu\n    private void setupMenu1(JFrame frm, JMenuBar mb, ActionListener acl) {\n\n        // Set the text for the first menu\n        mn_File.setText(\"File\");\n\n        // add an ActionListener to each menuItem\n        // note that the program is calling an action listener\n        // mn_File.addSeparator();\n        // setup the quit menu item\n        mi_Quit.setText(\"Quit\");\n\n        // set the ctrl-Q shortcut for quitting\n        mi_Quit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,\n                InputEvent.CTRL_DOWN_MASK));\n\n        // add an action listener to close down the program\n        mi_Quit.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.exit(0);\n            }\n        });\n\n        // add the Menu item to Menu\n        mn_File.add(mi_Quit);\n\n        // add the menu to the menubar\n        mb.add(mn_File);\n\n        // set the menubar to the form\n        frm.setJMenuBar(mb);\n    }\n\n}\n","type":"content","url":"/xlettersvsdigits#character-isletter","position":9},{"hierarchy":{"lvl1":"Menus"},"type":"lvl1","url":"/xmenus","position":0},{"hierarchy":{"lvl1":"Menus"},"content":"Java menus provide a convenient way for users to choose from several options within a graphical user interface. Let’s dive into the details:","type":"content","url":"/xmenus","position":1},{"hierarchy":{"lvl1":"Menus","lvl2":"Menu Basics:"},"type":"lvl2","url":"/xmenus#menu-basics","position":2},{"hierarchy":{"lvl1":"Menus","lvl2":"Menu Basics:"},"content":"A menu allows users to select one option from a list of choices.\n\nOther components that offer similar one-of-many choices include combo boxes, lists, radio buttons, spinners, and toolbars.\n\nMenus are typically not placed directly with other UI components. Instead, they appear either in a menu bar or as a popup menu.\n\nA menu bar contains one or more menus and is usually positioned along the top of a window.\n\nA popup menu remains invisible until the user triggers it with a platform-specific mouse action (e.g., right-clicking) over a component.","type":"content","url":"/xmenus#menu-basics","position":3},{"hierarchy":{"lvl1":"Menus","lvl2":"Components in a Menu:"},"type":"lvl2","url":"/xmenus#components-in-a-menu","position":4},{"hierarchy":{"lvl1":"Menus","lvl2":"Components in a Menu:"},"content":"Menus consist of several related components:\n\nMenu Bar: Contains menus and is usually located at the top of a window.\n\nMenus: Represent a group of related options.\n\nMenu Items: The actual choices within a menu.\n\nRadio Button Menu Items: Allow single selection from a group.\n\nCheck Box Menu Items: Enable multiple selections.\n\nSeparators: Divide menu items visually.\n\nMenu items can have text, images, or both.","type":"content","url":"/xmenus#components-in-a-menu","position":5},{"hierarchy":{"lvl1":"Menus","lvl2":"Hierarchy and Activation:"},"type":"lvl2","url":"/xmenus#hierarchy-and-activation","position":6},{"hierarchy":{"lvl1":"Menus","lvl2":"Hierarchy and Activation:"},"content":"Menu items (including menus) are essentially buttons.\n\nWhen a menu is activated (e.g., clicked), it displays a popup menu containing its menu items.","type":"content","url":"/xmenus#hierarchy-and-activation","position":7},{"hierarchy":{"lvl1":"Menus","lvl2":"Lecture Code"},"type":"lvl2","url":"/xmenus#lecture-code","position":8},{"hierarchy":{"lvl1":"Menus","lvl2":"Lecture Code"},"content":"/*\nProject: Menu\nProgrammer: James Goudy\n\nThis program demonstrates how to programmically create a menus\n */\npackage jx_menu;\n\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JMenu;\n\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.KeyStroke;\n\nclass MenuDemo {\n\n    // create our controls\n    JFrame Frame1 = new JFrame();\n\n    JMenuBar mb = new JMenuBar();\n\n    JMenu mn_File = new JMenu();\n    JMenu mn_MyMenu = new JMenu();\n\n    JMenuItem mi_example1 = new JMenuItem(\"Example 1\");\n    JMenuItem mi_example2 = new JMenuItem(\"Example 2\");\n    JMenuItem mi_example3 = new JMenuItem(\"Example 3\");\n    JMenuItem mi_example4 = new JMenuItem(\"Example 4\");\n    JMenuItem mi_example5 = new JMenuItem(\"Example 5\");\n    JMenuItem mi_Quit = new JMenuItem();\n\n    JLabel lblMenuPress = new JLabel();\n\n    public MenuDemo() {\n\n        Color frameColor = Color.lightGray;\n\n        setupMenu1(Frame1);\n        setupMenu2(Frame1);\n\n        setUpTheJFrame(Frame1, 800, 600, \"Menu Demo\", frameColor, true);\n\n        setupLabel(Frame1, lblMenuPress, 300, 250, 150, \"---\", 14);\n\n        Frame1.repaint();\n    }\n\n    // Make sure the menu is setup before the frame\n    // Setup the File menu\n    private void setupMenu1(JFrame frm) {\n\n        // Set the text for the first menu\n        mn_File.setText(\"File\");\n\n        // add an ActionListener to each menuItem\n        // note that the program is calling an action listener\n        mi_example1.addActionListener(myActionListner);\n        mi_example2.addActionListener(myActionListner);\n\n        // setup the quit menu item\n        mi_Quit.setText(\"Quit\");\n\n        // set the ctrl-Q shortcut for quitting\n        mi_Quit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,\n                InputEvent.CTRL_DOWN_MASK));\n\n        // add an action listener to close down the program\n        mi_Quit.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.exit(0);\n            }\n        });\n\n        // add menu items to menu\n        mn_File.add(mi_example1);\n        mn_File.add(mi_example2);\n\n        mn_File.addSeparator();\n\n        // add the Menu item to Menu\n        mn_File.add(mi_Quit);\n\n        // add the menu to the menubar\n        mb.add(mn_File);\n\n        // set the menubar to the form\n        frm.setJMenuBar(mb);\n\n    }\n\n    private void setupMenu2(JFrame frm) {\n\n        // make sure that setupMenu2 runs after setup Menu1\n        // set text for the second menu\n        mn_MyMenu.setText(\"My Menu\");\n\n        // add an ActionListener to each menuItem\n        // note that the menu item is adding an action listener\n        // myactionListener if programmed later in the code.\n        mi_example3.addActionListener(myActionListner);\n        mi_example4.addActionListener(myActionListner);\n        mi_example5.addActionListener(myActionListner);\n\n        // Add the menu items to the menu\n        mn_MyMenu.add(mi_example3);\n        mn_MyMenu.add(mi_example4);\n\n        mn_MyMenu.addSeparator();\n\n        // Add the menu item to teh menu\n        mn_MyMenu.add(mi_example5);\n\n        // add the menu to menubar\n        mb.add(mn_MyMenu);\n\n    }\n\n    ActionListener myActionListner = new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            // e is the thing that was clicked on\n            \n            // e.getSource tells it to get the thing that was clicked on\n            // which in this case is the menu item\n            // since e could be anything it needs to be identified by the \n            // (JMenuItem)\n            JMenuItem x = (JMenuItem) e.getSource();\n            \n            // get the text from the menu item and set it in the JLablel\n            lblMenuPress.setText(x.getText());\n\n        }\n    };\n\n    private void setUpTheJFrame(JFrame jf1, int frameWidth, int frameHeight,\n            String frameTitle, Color frameColor,\n            boolean turnLayoutManagerOff) {\n\n        // Set the initial dimensions of the JFrame's window\n        jf1.setSize(frameWidth, frameHeight);\n\n        // Set the JFrame title\n        jf1.setTitle(frameTitle);\n\n        // Apply a custom background color to the content pane\n        // The content pane is the area where items are added to\n        // the frame\n        jf1.getContentPane().setBackground(frameColor);\n\n        // Make the JFrame visible on the screen,\n        // allowing users to interact with it\n        jf1.setVisible(true);\n\n        // Center the JFrame on the user's screen for optimal visibility\n        jf1.setLocationRelativeTo(null);\n\n        // Specify the program's termination behavior\n        // when the JFrame is closed\n        // Exit the program when the frame is closed\n        jf1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Disable the default layout manager, allowing\n        // for manual component positioning\n        // Note: Manual layout can be more complex to manage\n        // disable the default layout manager\n        if (turnLayoutManagerOff) {\n            jf1.setLayout(null);\n        }\n    }\n\n    private void setupLabel(JFrame jf1, JLabel lbl,\n            int xpos, int ypos, int lblWidth,\n            String theText, float labelSize) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        lbl.setFont(lbl.getFont().deriveFont(labelSize));\n\n        // Set the preferred size of the label\n        lbl.setSize(lblWidth, (int) labelSize + 8);\n\n        // Set the text content of the label\n        lbl.setText(theText);\n\n        // Make the label visible\n        lbl.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        lbl.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(lbl);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n}\n\npublic class Jx_Menu {\n\n    public static void main(String[] args) {\n\n        MenuDemo demo1 = new MenuDemo();\n\n    }\n\n}\n","type":"content","url":"/xmenus#lecture-code","position":9},{"hierarchy":{"lvl1":"Pictures and Sound"},"type":"lvl1","url":"/xpicturesandsound","position":0},{"hierarchy":{"lvl1":"Pictures and Sound"},"content":"","type":"content","url":"/xpicturesandsound","position":1},{"hierarchy":{"lvl1":"Pictures and Sound","lvl2":"Build Sequence"},"type":"lvl2","url":"/xpicturesandsound#build-sequence","position":2},{"hierarchy":{"lvl1":"Pictures and Sound","lvl2":"Build Sequence"},"content":"Why the setup calls in the Frame1 constructor is a logical and common way to organize GUI setup code, especially helpful for beginners:\n\nCreate the Container First:\n\nmyFrame = new JFrame(\"Picture and Sound\");\n\nWhy first? This line creates the main window object (JFrame). Think of it like getting the main box or the foundation before you can put anything inside it or build upon it. Everything else in the GUI will belong to this frame in some way. You can’t add panels, buttons, or menus to a window that doesn’t exist yet.\n\nPrepare Data/Resources (Optional but Good Practice):\n\nloadDogsPaths();\n\nWhy early? This method gets the list of image file paths ready. While it doesn’t directly build a visible part of the GUI, it prepares data that will be needed later by other components (specifically, the setupDogButton method needs these paths for its action listener). Getting data ready before setting up the components that use it prevents potential errors and keeps related logic together.\n\nBuild Components That Need Other Components:\n\nsetupMenu();\n\nWhy before setupFrame? This creates the menu bar (JMenuBar) and its contents. The menu bar itself needs to be attached to the JFrame. The setupFrame method likely contains the line myFrame.setJMenuBar(myMenuBar);. Therefore, the menu bar must exist before you try to attach it in setupFrame.\n\nConfigure the Main Container:\n\nsetupFrame();\n\nWhy here? This method sets up the properties of the main window itself – its size, layout (even if null), what happens when you close it, and crucially, it attaches the menu bar created in setupMenu. It prepares the “stage” where the other visual elements will be placed. It needs myFrame (created first) and myMenuBar (created by setupMenu) to be ready.\n\nCreate and Add Child Components (Panels):\n\nsetupDogPanel();\n\nsetupShapePanel();\n\nWhy after setupFrame? These methods create the custom panels (DogPanel, ShapePanel) where drawing will occur. They need the myFrame object to exist so they can be added to its content area (using myFrame.add(...)). They are the main visual building blocks inside the frame.\n\nCreate and Add Interactive Controls (Buttons):\n\nsetupDogButton();\n\nsetupShapeButton();\n\nWhy last (or after the components they control)?\n\nThese methods create the buttons.\n\nThey need the myFrame to exist so they can be added to it.\n\nCrucially, their action listeners\n\nTip\n\n\n\n(the code that runs when clicked) often need references to the components they interact with.)\n\nsetupDogButton needs dogPanel (to tell it to draw) and the dogImagePaths (loaded earlier).\n\nsetupShapeButton needs shapePanel (to tell it which shape to draw).\n\nPlacing the button setup after the panels they control ensures those panels exist and are ready to be referenced by the button’s actions.\n\nKey Takeaways:\n\nDependency Order: The sequence respects dependencies. You create things before you use or add them to something else.\n\nLogical Grouping: It groups related setup tasks into separate, well-named methods (like setupMenu, setupDogPanel), making the constructor cleaner and the code easier to understand and modify.\n\nReadability: Following this logical flow makes the code read more naturally, showing the progression from the main container down to the individual interactive elements./*\n\nDeveloper: James Goudy\nRev: 2025\n\n */\npackage j2_pictures_sound_rev25;\n\nimport java.awt.Color;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport javax.swing.BorderFactory;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.JPanel;\n\nclass DogPanel extends JPanel {\n\n    // create a buffered image and a boolean status flag\n    BufferedImage dogImage;\n    boolean drawDog = false;\n\n    // variables for the height and width of the panel\n    int width;\n    int height;\n\n    public DogPanel(int width, int height)\n    {\n\n        this.width = width;\n        this.height = height;\n\n    }\n\n    public void setDogImage(BufferedImage dogpix)\n    {\n        this.dogImage = dogpix;\n        this.drawDog = true;\n        repaint();\n    }\n\n    @Override\n    protected void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n        \n        // ensure there is a dog pix and it is not null\n        if (drawDog && dogImage != null) {\n            g.drawImage(dogImage, 0, 0, width, height, this);\n        }\n    }\n}\n\nclass ShapePanel extends JPanel {\n\n    public enum ShapeChoice {\n        CIRCLE, SQUARE, WORD\n    }\n    public ShapeChoice myShapeChoice;\n\n    String myString;\n\n    int width;\n    int height;\n\n    public ShapePanel(int width, int height)\n    {\n\n        // set the panel width, height, default String, and default shape\n        this.width = width;\n        this.height = height;\n        myString = \"Hello\";\n        myShapeChoice = ShapeChoice.CIRCLE;\n\n    }\n\n    public void setTheString(String theString)\n    {\n        this.myString = theString;\n    }\n\n    public void drawShape(ShapeChoice myShapechoice)\n    {\n        this.myShapeChoice = myShapechoice;\n        repaint();\n    }\n\n    @Override\n    protected void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n\n        // FontMeterics is used to get the string width\n        FontMetrics fontMetrics = g.getFontMetrics();\n\n        // based on the enum - draw a circle, square or string\n        // the 5,5 are setting the shape 5 pixels over and 5 down\n        // the -10 will insure there is a 5 pixel space all around the shape\n        \n        switch (myShapeChoice) {\n\n            case CIRCLE -> {\n                g.setColor(Color.red);\n                g.fillOval(5, 5, width - 10, height - 10);\n            }\n            case SQUARE -> {\n                g.setColor(Color.blue);\n                g.fillRect(5, 5, width - 10, height - 10);\n            }\n            case WORD -> {\n                g.setColor(Color.darkGray);\n                g.drawString(myString,\n                        (width - fontMetrics.stringWidth(myString)) / 2,\n                        height / 2);\n            }\n            default -> {\n                g.setColor(Color.yellow);\n                g.fillOval(5, 5, width - 10, height - 10);\n            }\n        }\n\n    }\n}\n\nclass Frame1 {\n\n    // Create Frame\n    JFrame myFrame;\n\n    // Create Panels To Put On Frame\n    DogPanel dogPanel;\n    ShapePanel shapePanel;\n\n    // Create counter to cycle through shapes\n    int shapeCntr = 0;\n\n    // Create menubar, menu and one menu item to put on menu\n    JMenuBar myMenuBar = new JMenuBar();\n    JMenu myMenuFile = new JMenu(\"File\");\n    JMenuItem myMenuItemQuit = new JMenuItem(\"Quit\");\n\n    // Create a dog image variable and an array to keep their file paths\n    BufferedImage dogImage;\n    String[] dogImagePaths = new String[5];\n\n    // Create counter to cycle through dogs\n    int dogCntr = 0;\n\n    // create the buttons\n    JButton mybttnDrawDog = new JButton(\"Draw Dog\");\n    JButton mybttnDrawShape = new JButton(\"Draw Shape\");\n\n    public Frame1()\n    {\n\n        // instansiate a new Frame\n        myFrame = new JFrame(\"Picture and Sound\");\n\n        // functions to build the GUI\n        loadDogsPaths();\n        setupMenu();\n        setupFrame();\n        setupDogPanel();\n        setupShapePanel();\n        setupDogButton();\n        setupShapeButton();\n\n    }\n\n    private void setupMenu()\n    {\n\n        // add exit to menuItem\n        myMenuItemQuit.addActionListener(e -> System.exit(0));\n\n        // add quit it File Menu\n        myMenuFile.add(myMenuItemQuit);\n\n        // Add File Menu to File Bar\n        myMenuBar.add(myMenuFile);\n\n    }\n\n    private void setupFrame()\n    {\n\n        // setup basic frame\n        int width = 800;\n        int height = 600;\n\n        // set layout manager\n        myFrame.setLayout(null);\n\n        // set close behavior of frame\n        myFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // add menu        \n        myFrame.setJMenuBar(myMenuBar);\n\n        // setup size, visibility and screen location\n        myFrame.setSize(width, height);\n        myFrame.setVisible(true);\n        myFrame.setLocationRelativeTo(null);\n    }\n\n    private void setupDogPanel()\n    {\n\n        // set panel dimensions\n        int width = 300;\n        int height = 200;\n\n        // instansiate a new dogpanel, set location and dimensions,\n        // create a border, set visibility and add it to the frame.\n        dogPanel = new DogPanel(width, height);\n\n        dogPanel.setBounds(25, 75, 300, 200);\n        dogPanel.setBorder(BorderFactory.createLineBorder(Color.blue, 3));\n        dogPanel.setVisible(true);\n\n        myFrame.add(dogPanel);\n    }\n\n    private void setupShapePanel()\n    {\n        // set panel dimensions\n        int width = 200;\n        int height = 200;\n\n        // instansiate a new dogpanel, set location and dimensions,\n        // create a border, set visibility and add it to the frame.\n        shapePanel = new ShapePanel(width, height);\n\n        shapePanel.setBounds(350, 75, 200, 200);\n        shapePanel.setBorder(BorderFactory.createLineBorder(Color.blue, 3));\n        shapePanel.setVisible(true);\n\n        myFrame.add(shapePanel);\n    }\n\n    private void setupDogButton()\n    {\n\n        // setup button dimensions and location\n        \n        int buttonWidth = 100;\n        int buttonHeight = 25;\n\n        int xpos = 25;\n        int ypos = 25;\n\n        // setup the action listener - what happens when the button is press\n        \n        mybttnDrawDog.addActionListener(e -> {\n  \n            // the remainder is being calculated.  This will correspond\n            // to the array index for the dog paths\n            \n            int dogChoice = dogCntr % dogImagePaths.length;\n            \n\n            try {\n\n                // alternative way\n                //dogImage = ImageIO.read(new File(dogImagePaths[dogChoice]));\n                \n                // read in a dog image\n                dogImage = \n                 ImageIO.read(getClass().getResource(dogImagePaths[dogChoice]));\n\n                // update the dog image on the dog panel\n                dogPanel.setDogImage(dogImage);\n\n                // bark\n                bark();\n                \n            } catch (IOException ex) {\n\n                System.out.println(ex.getMessage());\n            }\n            \n            dogCntr++;\n\n        });\n\n        // set the button location and dimensions, set the visibility,\n        // and add it to the frame\n        \n        mybttnDrawDog.setBounds(xpos, ypos, buttonWidth, buttonHeight);\n        mybttnDrawDog.setVisible(true);\n\n        myFrame.add(mybttnDrawDog);\n\n    }\n\n    private void setupShapeButton()\n    {\n\n        // setup button dimensions and location\n        \n        int buttonWidth = 200;\n        int buttonHeight = 25;\n\n        int xpos = 350;\n        int ypos = 25;\n\n        // setup the action listener - what happens when the button is press\n        \n        mybttnDrawShape.addActionListener(e -> {\n\n            \n            // calculate the button choices for the shape. \n            // by using the remainder, the choices will always be 0,1,2\n            \n            int choice = shapeCntr % 3;\n\n\n            switch (choice) {\n                case 0:\n                    shapePanel.drawShape(ShapePanel.ShapeChoice.CIRCLE);\n                    break;\n                case 1:\n                    shapePanel.drawShape(ShapePanel.ShapeChoice.SQUARE);\n                    break;\n                case 2:\n                    shapePanel.drawShape(ShapePanel.ShapeChoice.WORD);\n                    break;\n                default:\n                    break;\n            }\n\n            // increment the counter \n            shapeCntr++;\n\n        });\n\n        // set the button location and dimensions, set the visibility,\n        // and add it to the frame\n        \n        mybttnDrawShape.setBounds(xpos, ypos, buttonWidth, buttonHeight);\n        mybttnDrawShape.setVisible(true);\n\n        myFrame.add(mybttnDrawShape);\n\n    }\n\n    private void loadDogsPaths()\n    {\n\n        for (int i = 0; i < dogImagePaths.length; i++) {\n\n            // NOTE: THE SLASHES MUST LEAN TO THE RIGHT\n            // NOTE: THE SLASHES MUST LEAN TO THE RIGHT!!!\n            // Building the string paths to the dog.\n            // Assumes the file is in the src folder.\n            \n            dogImagePaths[i] = \"/images/images/dog\" + (i + 1) + \".jpg\";\n\n        }\n\n    }\n\n    private void bark()\n    {\n\n        // get the string path of where the file is located\n        // from below it assumes it is in the src file\n        \n        String soundPath = \"/Sounds/howl.wav\";\n\n        try {\n            \n            // create a sound clip\n            Clip barkclip = AudioSystem.getClip();\n\n           // create an audiostream\n           AudioInputStream inputStream\n           = AudioSystem.getAudioInputStream(getClass().getResource(soundPath));\n\n            // open the stream\n            barkclip.open(inputStream);\n\n            // play the stream\n            barkclip.start();\n\n            // demonstrates that a clip can be looped\n            barkclip.loop(2);\n\n        } catch (UnsupportedAudioFileException e) {\n            System.out.println(e.getMessage());\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n\n    }\n\n}\n\npublic class J2_Pictures_Sound_Rev25 {\n\n    public static void main(String[] args)\n    {\n\n        Frame1 myFrame = new Frame1();\n\n    }\n\n}\n","type":"content","url":"/xpicturesandsound#build-sequence","position":3},{"hierarchy":{"lvl1":"Radio Buttons"},"type":"lvl1","url":"/xradiobuttons","position":0},{"hierarchy":{"lvl1":"Radio Buttons"},"content":"","type":"content","url":"/xradiobuttons","position":1},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"Properties:"},"type":"lvl2","url":"/xradiobuttons#properties","position":2},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"Properties:"},"content":"Text: You can set the display text for the radio button using the setText(String s) method.\n\nSelected State: The isSelected() method allows you to check whether the radio button is currently selected.\n\nEnabled/Disabled: You can enable or disable the radio button using the setEnabled(boolean b) method.\n\nIcon: The setIcon(Icon icon) method lets you set an icon for the radio button.\n\nMnemonic: You can assign a keyboard shortcut (mnemonic) to the radio button using the setMnemonic(int a) method.","type":"content","url":"/xradiobuttons#properties","position":3},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"Events:"},"type":"lvl2","url":"/xradiobuttons#events","position":4},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"Events:"},"content":"Action Event: When a radio button is pressed and released, an ActionEvent is sent. You can handle this event using an ActionListener.\n\nItem Event: When the selection state of the radio button changes, an ItemEvent is generated. You can handle this event using an ItemListener.\n\nIn Java, an ActionListener is an interface that allows you to handle action events triggered by user interactions with components such as buttons, menu items, or text fields. When the user performs a specific action (e.g., clicks a button or presses Enter in a text field), an action event occurs, and the registered ActionListener responds to it.","type":"content","url":"/xradiobuttons#events","position":5},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"ButtonGroup"},"type":"lvl2","url":"/xradiobuttons#buttongroup","position":6},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"ButtonGroup"},"content":"Is a class that allows you to group together a set of radio buttons. When you create a group of radio buttons using a ButtonGroup, only one radio button within that group can be selected at a time. Here are the key points about ButtonGroup:\n\nPurpose:\n\nA ButtonGroup ensures that only one radio button in the group can be selected simultaneously.\n\nIt prevents users from selecting multiple radio buttons within the same group.\n\nUsage:\n\nTo create a ButtonGroup:\n\nInstantiate a new ButtonGroup object: ButtonGroup group = new ButtonGroup();\n\nAdd individual radio buttons to the group using the add(AbstractButton button) method: group.add(radioButton1);\n\nBehavior:\n\nWhen a radio button is selected, any previously selected radio button in the same group is automatically deselected.\n\nRadio buttons within the same group share the same selection state.","type":"content","url":"/xradiobuttons#buttongroup","position":7},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"ActionListener:"},"type":"lvl2","url":"/xradiobuttons#actionlistener","position":8},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"ActionListener:"},"content":"Purpose:\n\nAn ActionListener defines what should happen when a specific action occurs on a component.\n\nIt is commonly used for handling button clicks, menu selections, or other user interactions.\n\nImplementation:\n\nTo create an ActionListener, you can either:\n\nImplement the ActionListener interface directly in your class.\n\nExtend a class that already implements ActionListener.\n\nThe only method in the ActionListener interface isactionPerformed(ActionEvent e)\n\nThis method is called when the associated action event occurs.\n\nThe ActionEvent object provides information about the event and its source.\n\nRegistration:\n\nTo use an ActionListener:\n\nCreate an instance of your event handler class (which implements ActionListener).\n\nRegister this instance as an action listener on the relevant component using addActionListener(this).","type":"content","url":"/xradiobuttons#actionlistener","position":9},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"Code"},"type":"lvl2","url":"/xradiobuttons#code","position":10},{"hierarchy":{"lvl1":"Radio Buttons","lvl2":"Code"},"content":"/*\nProject:        Radio Buttons\nDescription:    This shows how to programmically create radio buttons.\n                And, to make an appropriate selection if a radio button is \n                selected.\n                The program allows the user to click a radio button for a dog.\n                It then displays the dog in the a label. And the user\n                has the option of getting a description of the dog by\n                clicking the button or hitting the enter key.\n                Note: That the radio buttons are assign to a radio button group.\n\nProgrammer:     James Goudy\n */\npackage j2x_5_radiobuttons;\n\nimport java.awt.Color;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport javax.swing.ButtonGroup;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JMenu;\nimport javax.swing.JMenuBar;\nimport javax.swing.JMenuItem;\nimport javax.swing.JRadioButton;\nimport javax.swing.JTextArea;\nimport javax.swing.KeyStroke;\n\nclass Frame1 {\n\n    // create our controls\n    // Frame\n    JFrame Frame1 = new JFrame();\n\n    // Menu Bar\n    JMenuBar mb = new JMenuBar();\n    JMenu mn_File = new JMenu();\n    JMenuItem mi_Quit = new JMenuItem();\n\n    // Radio Buttons\n    JRadioButton jrbGolden = new JRadioButton();\n    JRadioButton jrbLab = new JRadioButton();\n    JRadioButton jrbSpring = new JRadioButton();\n\n    ButtonGroup jbgDog = new ButtonGroup();\n\n    // Labels\n    JLabel lblSelectedDog = new JLabel();\n\n    // Text\n    JTextArea jtaDescription = new JTextArea();\n\n    // Description Button\n    JButton jbttnDesc = new JButton();\n\n    // Descriptions\nString GoldDesc = \"\"\"\nGolden retrievers, known for their radiant coats \nand sunny personalities, are beloved companions prized \nfor their gentle nature and intelligence. These \nversatile dogs excel as both family pets and \nworking partners, offering unwavering loyalty, \neagerness to please, and boundless enthusiasm \nfor life's adventures.                  \n\"\"\";\n\n    String LabDesc = \"\"\"\nBlack Labradors, with their sleek, shiny coats \nand expressive eyes, are the most popular \ncolor variation of this beloved breed. These \nmedium-sized dogs boast a playful and \naffectionate personality, making them excellent \ncompanions for families and active individuals. \nRenowned for their intelligence and eagerness \nto please, black Labs excel in training and are \noften employed as guide dogs, service dogs, and \neven search and rescue partners. However, their \nboundless energy requires ample daily exercise \nand mental stimulation to keep them happy and \nwell-behaved.\n\"\"\";\n\n    String SpringDesc = \"\"\"\nSpringer spaniels are energetic and intelligent \ndogs known for their sweet nature and playful \nspirit. These medium-sized bundles of joy boast \na soft, double coat in various colors and a gentle \nexpression that melts hearts. Bred for hunting, \nthey possess impressive stamina and agility, making \nthem excellent companions for active families and \noutdoor enthusiasts. However, their eagerness to \nplease and trainability also make them adaptable \nto different lifestyles, as long as their need \nfor exercise and mental stimulation is met.\n\"\"\";\n\n    // final means that the varaible contents cannot change\n    // making the following variable \"final\", will allow \n    // the variables to be used in the switch statement\n    final String gldText = \"Golden Retreiver\";\n    final String labText = \"Labrador\";\n    final String sprngText = \"Springer Spaniel\";\n\n    ActionListener aclGolden = new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            lblSelectedDog.setText(gldText);\n            jtaDescription.setText(\"\");\n        }\n    };\n\n    ActionListener aclSpring = new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            lblSelectedDog.setText(\"Springer Spaneil\");\n            jtaDescription.setText(\"\");\n        }\n    };\n\n    ActionListener aclLab = new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            lblSelectedDog.setText(labText);\n            jtaDescription.setText(\"\");\n        }\n    };\n\n    public Frame1() {\n\n        int frameWidth = 750;\n        int frameHeight = 350;\n\n        int rbxPos = 20;\n        int rbyPos = 20;\n\n        int vspacing = 50;\n\n        int rbWidth = 150;\n        int rbHeight = 25;\n\n        // -----------  Frame Setup -------------------------------\n        // this has to go before setting up the frame\n        setupMenu1(Frame1);\n\n        // frame setup\n        setUpTheJFrame(Frame1, frameWidth, frameHeight,\n                \"Radio Buttons\", Color.white, true);\n\n        // -----------  Radio Buttons Setup -----------------------\n        // add the radio buttons after the frame has been setup\n        setupRadioButtons(jrbGolden, rbxPos, rbyPos, rbWidth, rbHeight, jbgDog,\n                gldText, true, true, Frame1, aclGolden);\n\n        setupLabel(Frame1, lblSelectedDog, 200, rbyPos, rbWidth, gldText, 12);\n\n        rbyPos = rbyPos + vspacing;\n        \n\n        setupRadioButtons(jrbLab, rbxPos, rbyPos, rbWidth, rbHeight, jbgDog,\n                labText, true, true, Frame1, aclLab);\n\n        rbyPos = rbyPos + vspacing;\n\n        setupRadioButtons(jrbSpring, rbxPos, rbyPos, rbWidth, rbHeight, jbgDog,\n                sprngText, true, true, Frame1, aclSpring);\n\n        // -----------  Description Button Setup ------------------\n        // add the jbutton\n        setupButton(Frame1, jbttnDesc, 200, 72, rbWidth, \"Description\", 12);\n        \n        // -----------  TextArea Setup -----------------------------\n        // add the description text\n        setupTextArea(Frame1, jtaDescription , 400, 20, 400, 500, \n                \"---\", 12,false);\n\n        Frame1.repaint();\n\n    }\n\n    private void setUpTheJFrame(JFrame jf1, int frameWidth, int frameHeight,\n            String frameTitle, Color frameColor,\n            boolean turnLayoutManagerOff) {\n\n        // Set the initial dimensions of the JFrame's window\n        jf1.setSize(frameWidth, frameHeight);\n\n        // Set the JFrame title\n        jf1.setTitle(frameTitle);\n\n        // Apply a custom background color to the content pane\n        // The content pane is the area where items are added to\n        // the frame\n        jf1.getContentPane().setBackground(frameColor);\n\n        // Make the JFrame visible on the screen,\n        // allowing users to interact with it\n        jf1.setVisible(true);\n\n        // Center the JFrame on the user's screen for optimal visibility\n        jf1.setLocationRelativeTo(null);\n\n        // Specify the program's termination behavior\n        // when the JFrame is closed\n        // Exit the program when the frame is closed\n        jf1.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        // Disable the default layout manager, allowing\n        // for manual component positioning\n        // Note: Manual layout can be more complex to manage\n        // disable the default layout manager\n        if (turnLayoutManagerOff) {\n            jf1.setLayout(null);\n        }\n    }\n\n    // Make sure the menu is setup before the frame\n    // Setup the File menu\n    private void setupMenu1(JFrame frm) {\n\n        // Set the text for the first menu\n        mn_File.setText(\"File\");\n\n        // setup the quit menu item\n        mi_Quit.setText(\"Quit\");\n\n        // set the ctrl-Q shortcut for quitting\n        mi_Quit.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,\n                InputEvent.CTRL_DOWN_MASK));\n\n        // add an action listener to close down the program\n        mi_Quit.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.exit(0);\n            }\n        });\n\n        mn_File.addSeparator();\n\n        // add the Menu item to Menu\n        mn_File.add(mi_Quit);\n\n        // add the menu to the menubar\n        mb.add(mn_File);\n\n        // set the menubar to the form\n        frm.setJMenuBar(mb);\n\n    }\n\n    private void setupRadioButtons(JRadioButton jrb, int xpos, int ypos,\n            int rbWidth, int rbHeight, ButtonGroup jbg, String rbText,\n            boolean rbVisible, boolean rbSelected,\n            JFrame frm, ActionListener acl) {\n\n        // Set position on frame\n        jrb.setLocation(xpos, ypos);\n\n        // set the size\n        jrb.setSize(rbWidth, rbHeight);\n\n        // set visiblity\n        jrb.setVisible(rbVisible);\n\n        // alternative placement\n        //jrb.setBounds(xpos, ypos, rbWidth, rbHeight);\n        \n        // select it\n        jrb.setSelected(rbSelected);\n\n        // set button text\n        jrb.setText(rbText);\n        jrb.addActionListener(acl);\n\n        // add radio button to Radio Button Group\n        jbg.add(jrb);\n\n        // add radio button to form\n        frm.add(jrb);\n\n        frm.repaint();\n    }\n\n    private void setupLabel(JFrame jf1, JLabel lbl,\n            int xpos, int ypos, int lblWidth,\n            String theText, float labelSize) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        lbl.setFont(lbl.getFont().deriveFont(labelSize));\n\n        // Set the preferred size of the label\n        lbl.setSize(lblWidth, (int) labelSize + 8);\n\n        // Set the text content of the label\n        lbl.setText(theText);\n\n        // Make the label visible\n        lbl.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        lbl.setLocation(xpos, ypos);\n\n        // Add the label to the window's content pane\n        jf1.add(lbl);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n    \n    private void setupTextArea(JFrame jf1, JTextArea jta,\n            int xpos, int ypos, int jtaWidth,int jtaHeight,\n            String theText, float fontSize, boolean jtaIsEditable) {\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        jta.setFont(jta.getFont().deriveFont(fontSize));\n\n        // Set the preferred size of the label\n        jta.setSize(jtaWidth,jtaHeight);\n\n        // Set the text content of the label\n        jta.setText(theText);\n\n        // Make the label visible\n        jta.setVisible(true);\n\n        // Position the label at coordinates (10, 10) within the window\n        jta.setLocation(xpos, ypos);\n                \n        // Set editable status\n        jta.setEditable(jtaIsEditable);\n        \n        // Add the label to the window's content pane\n        jf1.add(jta);  // Assuming jf1 is the main window object      \n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n    }\n\n    private void setupButton(JFrame jf1, JButton bttnABttn,\n            int xpos, int ypos, int bttnWidth,\n            String bttnText, float fsize) {\n\n        // Set the font size to 12 points\n        // NOTE: Have to do this before we add the text\n        bttnABttn.setFont(bttnABttn.getFont().deriveFont(fsize));\n\n        // Set the preferred size of the label\n        bttnABttn.setSize(bttnWidth, (int) fsize + 8);\n\n        // Set the text content of the label\n        bttnABttn.setText(bttnText);\n\n        // Make the label visible\n        bttnABttn.setVisible(true);\n\n        // Position the label at coordinates (xpos, ypos) within the window\n        bttnABttn.setLocation(xpos, ypos);\n\n        // This action listener listens for the mouse click\n        bttnABttn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                theButtonAction(bttnText);\n            }\n        });\n\n        // This key listener is for listening for the keyboard actions\n        bttnABttn.addKeyListener(new KeyListener() {\n\n            // For Reference\n            @Override\n            public void keyTyped(KeyEvent e) {\n\n            }\n\n            // listen only for the \"Enter\" key\n            @Override\n            public void keyPressed(KeyEvent e) {\n\n                if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n                    theButtonAction(bttnText);\n                }\n            }\n\n            // For Reference\n            @Override\n            public void keyReleased(KeyEvent e) {\n\n            }\n        });\n\n        // Add the label to the window's content pane\n        jf1.add(bttnABttn);  // Assuming jf1 is the main window object\n\n        // Request the window to be redrawn, reflecting the added label\n        jf1.repaint();\n\n    }\n\n    private void theButtonAction(String bttnText) {\n  \n        if(jrbGolden.isSelected())\n        {\n            jtaDescription.setText(GoldDesc);\n        }else if(jrbLab.isSelected())\n        {\n            jtaDescription.setText(LabDesc);\n        }\n        else if(jrbSpring.isSelected())\n        {\n            jtaDescription.setText(SpringDesc);\n        }\n        \n\n    }\n} // End of class\n\n// --------------------------------------------------------\npublic class J2x_5_RadioButtons {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Frame1 myFrame = new Frame1();\n    }\n\n}\n","type":"content","url":"/xradiobuttons#code","position":11},{"hierarchy":{"lvl1":"Threading"},"type":"lvl1","url":"/xthreadinga","position":0},{"hierarchy":{"lvl1":"Threading"},"content":"In computing, a process is an instance of a computer program that is being executed. Each process has its own memory space. Threading, in the context of Java (and other programming languages), is a way to achieve concurrency within a single process.\n\nThink of a process like a workshop.\n\nA single-threaded process is like having only one worker in the workshop. This worker has to do every task sequentially (e.g., build a chair part by part, paint it, then package it). If one task takes a long time (like waiting for paint to dry), the entire workshop’s progress stops.\n\nA multi-threaded process is like having multiple workers (threads) in the same workshop. They all share the same tools and materials (the process’s memory space). One worker can build the chair parts, another can paint a finished chair, and a third can package a painted one, potentially all happening concurrently or interleaved. This allows the workshop (the program) to make progress on multiple tasks simultaneously, leading to better efficiency and responsiveness.\n\nKey Concepts of Java Threading:\n\nConcurrency vs. Parallelism:\n\nConcurrency: Tasks appear to run at the same time. The system switches between tasks rapidly, giving the illusion of simultaneous execution, even on a single-core processor.\n\nParallelism: Tasks actually run at the same time on different processor cores. This requires a multi-core processor. Java threading enables both concurrency and, on suitable hardware, parallelism.\n\nShared Memory: Threads within the same Java process share the same memory space (heap memory). This makes communication between threads relatively easy (they can access the same objects) but also introduces challenges like race conditions if access to shared data isn’t carefully managed.\n\nThread Lifecycle: Threads go through various states (e.g., NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED).\n\nBenefits:\n\nResponsiveness: Keep applications (especially GUIs) responsive by performing long-running tasks in background threads.\n\nPerformance: Utilize multi-core processors effectively for computationally intensive tasks.\n\nResource Sharing: Efficient sharing of resources compared to creating separate processes.\n\nChallenges:\n\nComplexity: Writing correct concurrent code is harder than single-threaded code.\n\nSynchronization Issues: Need to manage access to shared data to prevent race conditions (where the outcome depends on the unpredictable timing of thread execution).\n\nDeadlock: Two or more threads waiting indefinitely for each other to release resources.\n\nLivelock: Threads are active but unable to make progress.\n\nStarvation: One thread is perpetually denied access to resources.","type":"content","url":"/xthreadinga","position":1},{"hierarchy":{"lvl1":"Threading","lvl2":"Example Code"},"type":"lvl2","url":"/xthreadinga#example-code","position":2},{"hierarchy":{"lvl1":"Threading","lvl2":"Example Code"},"content":"Overall Program Summary\n\nThis Java application demonstrates the use of multithreading within a Swing GUI framework. It presents a window containing three distinct panels, each capable of hosting an animated ball. Users can independently control the animation within each panel using “Start”/“Stop” and “Pause”/“Resume” buttons. When started, each ball runs on its own dedicated thread, calculating its movement according to a predefined path (bouncing, horizontal wave, or vertical wave) and redrawing its position asynchronously.\n\nThe program effectively showcases how background threads can manage computationally intensive or time-based tasks like animation without freezing the main user interface thread (Event Dispatch Thread). It utilizes core Java threading concepts like Runnable, Thread, volatile, synchronized, wait(), and notify(), along with Swing’s mechanism (SwingUtilities.invokeLater) for safely updating the GUI from these background threads. This separation ensures the application remains responsive while animations are running.","type":"content","url":"/xthreadinga#example-code","position":3},{"hierarchy":{"lvl1":"Threading","lvl2":"Ball"},"type":"lvl2","url":"/xthreadinga#ball","position":4},{"hierarchy":{"lvl1":"Threading","lvl2":"Ball"},"content":"Ball Class Summary\n\nThe Ball class serves a dual purpose: it’s a graphical component (JComponent) responsible for drawing a colored circle, and it’s a Runnable task that controls its own animation logic on a separate thread. Each Ball instance manages its position (xpos, ypos), size, color, movement direction (xdir, ydir), speed (sleepTime), and path type (bounce or wave). Its run() method contains the main animation loop, which periodically updates the ball’s position, checks for collisions with the panel boundaries (reversing direction and changing color upon impact), and then schedules a repaint on the Event Dispatch Thread using SwingUtilities.invokeLater. The class includes synchronized methods (startBall, stopBall, pauseBall, resumeBall) and uses volatile variables and wait/notify mechanisms to safely manage the thread’s lifecycle and state changes (like pausing) from other threads./*\nDeveloper: James Goudy\nThe ball class is to be added to a JPanel. \nThis program is to demonstate threads.\nProject: J2_Threading_Rev25\n\n */\npackage j2_threading_rev25;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JComponent;\nimport javax.swing.SwingUtilities;\n\n/**\n *\n * @author jgoudy\n */\npublic class Ball extends JComponent implements Runnable {\n\n    // thread variables\n    private volatile Thread ballThread;\n    private volatile boolean threadSuspended;\n\n    // When class elements are public, there is no ability to check if the\n    // data is correct as compared to setters and getters.\n    // In many cases, using getter and setters is the better way.\n    \n    \n    // component dimension - usually overlaid a jpanel\n    public int compWidth;\n    public int compHeight;\n\n    // graphic properties\n    // will use this for both height and width\n    public int ballSize = 10;\n    public volatile Color color;\n\n    // position of graphic on component panel\n    public volatile int xpos = 0;\n    public volatile int ypos = 0;\n\n    // direction based on slope\n    public int rise = 1;\n    public int run = 2;\n\n    // direction based on slope\n    public int xdir = 1;\n    public int ydir = 1;\n\n    // since this is a thread, we need a sleep time\n    public long sleepTime = 10;\n\n    // ball path - 1 is bounce, 2 is horizontal wave, 3 is vertical wave\n    //public int ballPath;\n    public enum BallPath {\n        BOUNCE, HORIZONTAL_WAVE, VERTICAL_WAVE\n    }\n    public BallPath currentBallPath;\n\n    // variables for wave action\n    public double waveAngle = 0.1;\n    public double waveAngleVelocity = 0.5;\n    public double waveAmplitude = 30;\n\n    // constructors\n    public Ball()\n    {\n        ballThread = new Thread(this);\n        color = Color.blue;\n    }\n\n    public Ball(int compWidth, int compHeight, int ballSize, Color color,\n            int xpos, int ypos, int rise, int run)\n    {\n        this.compWidth = compWidth;\n        this.compHeight = compHeight;\n        this.ballSize = ballSize;\n        this.color = color;\n        this.xpos = xpos;\n        this.ypos = ypos;\n        this.rise = rise;\n        this.run = run;\n\n        threadSuspended = false;\n\n        ballThread = new Thread(this);\n\n    }\n\n    @Override\n    public void run()\n    {\n        Thread thisThread = Thread.currentThread();\n\n        while (ballThread == thisThread) {\n            try {\n                Thread.sleep(sleepTime);\n\n                synchronized (this) {\n\n                    // this is for pausing the thread\n                    while (threadSuspended && ballThread == thisThread) {\n                        wait();\n                    }\n\n                    //put code here\n                    //-----------------\n                    moveBall();\n                    //---------------\n                }\n            } catch (InterruptedException e) {\n            }\n\n        }\n\n    }\n\n    @Override\n    public void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n        g.setColor(this.color);\n        g.fillOval(xpos, ypos, ballSize, ballSize);\n\n    }\n\n    public void moveBall()\n    {\n\n        checkIfBallHitASide();\n\n        switch (currentBallPath) {\n            case BOUNCE -> {\n                // ball bounces when hits side\n                xpos = xpos + (xdir * run);\n                ypos = ypos + (ydir * rise);\n\n            }\n            case HORIZONTAL_WAVE -> {\n                // ball travels a horizontal wave\n                ypos = (int) (waveAmplitude * Math.sin(waveAngle))\n                        + (compHeight / 2 - 10);\n                xpos = xpos + (xdir * run);\n\n                waveAngle = waveAngle + waveAngleVelocity;\n\n            }\n            case VERTICAL_WAVE -> {\n                // ball travels vertical wave\n                xpos = (int) (waveAmplitude * Math.sin(waveAngle))\n                        + (compWidth / 2 - 10);\n                ypos = ypos + (ydir * rise);\n\n                waveAngle = waveAngle + waveAngleVelocity;\n\n            }\n            default -> {\n                currentBallPath = BallPath.BOUNCE;\n            }\n        }\n       \n        // schedule repaint on the EDT (wait until the tread is done)\n        SwingUtilities.invokeLater(() -> {\n            repaint();\n        });\n\n    }\n\n    private void checkIfBallHitASide()\n    {\n        // check right and left\n        if (xpos > compWidth - ballSize) {\n            // check if ball hits/exceeds right side\n            xdir = xdir * -1;\n            xpos = compWidth - ballSize - 1;\n            if (color == Color.blue) {\n                color = Color.red;\n            } else {\n                color = Color.blue;\n            }\n\n        } else if (xpos <= 0) {\n            // check if ball hits/exceeds left side\n            xdir = xdir * -1;\n            xpos = 0;\n            color = Color.green;\n        }\n\n        // check bottom and top\n        if (ypos > compHeight - ballSize) {\n            // check if ball hits/exceeds bottom side\n            ydir = ydir * -1;\n            ypos = compHeight - ballSize;\n            color = Color.yellow;\n\n        } else if (ypos <= 0) {\n            // check if ball hits/exceeds top side\n            ydir = ydir * -1;\n            ypos = 0;\n            color = Color.lightGray;\n        }\n\n    }\n\n    // start stop pause resume thread - the ball\n    public synchronized void stopBall()\n    {\n        ballThread = null;\n        \n        // notify is to let the other threads and \n        // the main program know that this thread\n        // is no longer in existence \n        \n        notify();\n    }\n\n    public synchronized void startBall()\n    {\n        threadSuspended = false;\n        ballThread.start();\n    }\n\n    public synchronized void pauseBall()\n    {\n        threadSuspended = true;\n    }\n\n    public synchronized void resumeBall()\n    {\n        threadSuspended = false;\n        \n        // notify is to let the other threads\n        // and the main program  know that the\n        // thread is starting up again\n        \n        notify();\n    }\n\n}\n","type":"content","url":"/xthreadinga#ball","position":5},{"hierarchy":{"lvl1":"Threading","lvl2":"Frame1.java"},"type":"lvl2","url":"/xthreadinga#frame1-java","position":6},{"hierarchy":{"lvl1":"Threading","lvl2":"Frame1.java"},"content":"Frame1 Class Summary\n\nThe Frame1 class defines the main application window using javax.swing.JFrame and contains the user interface elements. It sets up three JPanel components, each acting as a container for a Ball animation, along with corresponding “Start”/“Stop” and “Pause”/“Resume” buttons for each panel. Frame1 is responsible for orchestrating the creation, addition, and removal of Ball instances within their respective panels in response to button clicks. It maintains state variables (isBallStartedX, isBallPausedX) to track the status of each ball and toggle the button functionalities appropriately. The action listeners for the buttons call the relevant control methods (startBall, stopBall, pauseBall, resumeBall) on the correct Ball object stored in an array, effectively linking the UI controls to the underlying animation threads./*\n\nDeveloper: James Goudy\nThe purpose of this program is to demonstrate the use of threads in Java.\nProject Name: J2_Threading_Rev25\n */\npackage j2_threading_rev25;\n\n\nimport javax.swing.JPanel;\n\n/**\n *\n * @author jgoudy\n */\npublic class Frame1 extends javax.swing.JFrame {\n\n    // an array to keep track of the balls\n    Ball[] balls = new Ball[3];\n\n    \n    // status variables for ball\n    boolean isBallStarted1 = true;\n    boolean isBallStarted2 = true;\n    boolean isBallStarted3 = true;\n    \n\n    boolean isBallPaused1 = true;\n    boolean isBallPaused2 = true;\n    boolean isBallPaused3 = true;\n    \n    /**\n     * Creates new form Frame1\n     */\n    public Frame1()\n    {\n        initComponents();\n\n        this.setLocationRelativeTo(this);\n\n    }\n\n    private void addBall(JPanel jp, int ballSize, Ball.BallPath ballpath,\n            int sleepTime, int rise, int run, int arrayIndex)\n    {\n\n        Ball nb = new Ball();\n\n        // set characteristics of the ball\n        // set ball path\n        switch (ballpath) {\n            case Ball.BallPath.BOUNCE -> {\n                nb.currentBallPath = Ball.BallPath.BOUNCE;\n            }\n            case Ball.BallPath.HORIZONTAL_WAVE-> {\n                nb.currentBallPath = Ball.BallPath.HORIZONTAL_WAVE;\n            }\n            case Ball.BallPath.VERTICAL_WAVE -> {\n                nb.currentBallPath = Ball.BallPath.VERTICAL_WAVE;\n            }\n            default -> {\n                nb.currentBallPath = Ball.BallPath.BOUNCE;\n            }\n        }\n\n        nb.compHeight = jp.getHeight();\n        nb.compWidth = jp.getWidth();\n        nb.ballSize = ballSize;\n        nb.rise = rise;\n        nb.run = run;\n        nb.sleepTime = sleepTime;\n\n        // remember when a component (ball) is added to a panel\n        // the visibility, the size of the component, height and width\n        // and the location of the top right corner has to be set\n        nb.setVisible(true);\n        nb.setSize(jp.getWidth(), jp.getHeight());\n        nb.setLocation(0, 0);\n\n        //nb.startBall();\n        jp.add(nb);\n        balls[arrayIndex] = nb;\n\n    }\n\n    /**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents()\n    {\n\n        jPanel1 = new javax.swing.JPanel();\n        jbttnStart1 = new javax.swing.JButton();\n        jbttnPause1 = new javax.swing.JButton();\n        jPanel2 = new javax.swing.JPanel();\n        jbttnStart2 = new javax.swing.JButton();\n        jbttnPause2 = new javax.swing.JButton();\n        jPanel3 = new javax.swing.JPanel();\n        jbttnStart3 = new javax.swing.JButton();\n        jbttnPause3 = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n\n        jPanel1.setBackground(new java.awt.Color(255, 255, 255));\n        jPanel1.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 0, Short.MAX_VALUE)\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 275, Short.MAX_VALUE)\n        );\n\n        jbttnStart1.setText(\"Start\");\n        jbttnStart1.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnStart1ActionPerformed(evt);\n            }\n        });\n\n        jbttnPause1.setText(\"Pause\");\n        jbttnPause1.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnPause1ActionPerformed(evt);\n            }\n        });\n\n        jPanel2.setBackground(new java.awt.Color(255, 255, 255));\n        jPanel2.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));\n\n        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 0, Short.MAX_VALUE)\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 275, Short.MAX_VALUE)\n        );\n\n        jbttnStart2.setText(\"Start\");\n        jbttnStart2.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnStart2ActionPerformed(evt);\n            }\n        });\n\n        jbttnPause2.setText(\"Pause\");\n        jbttnPause2.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnPause2ActionPerformed(evt);\n            }\n        });\n\n        jPanel3.setBackground(new java.awt.Color(255, 255, 255));\n        jPanel3.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));\n\n        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);\n        jPanel3.setLayout(jPanel3Layout);\n        jPanel3Layout.setHorizontalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 0, Short.MAX_VALUE)\n        );\n        jPanel3Layout.setVerticalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 275, Short.MAX_VALUE)\n        );\n\n        jbttnStart3.setText(\"Start\");\n        jbttnStart3.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnStart3ActionPerformed(evt);\n            }\n        });\n\n        jbttnPause3.setText(\"Pause\");\n        jbttnPause3.addActionListener(new java.awt.event.ActionListener()\n        {\n            public void actionPerformed(java.awt.event.ActionEvent evt)\n            {\n                jbttnPause3ActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(59, 59, 59)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jbttnStart1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jbttnPause1, javax.swing.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE))\n                .addGap(38, 38, 38)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jbttnStart2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jbttnPause2, javax.swing.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE))\n                .addGap(39, 39, 39)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jbttnStart3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(jbttnPause3, javax.swing.GroupLayout.PREFERRED_SIZE, 204, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(75, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(70, 70, 70)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(30, 30, 30)\n                        .addComponent(jbttnStart3)\n                        .addGap(30, 30, 30)\n                        .addComponent(jbttnPause3))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(30, 30, 30)\n                        .addComponent(jbttnStart2)\n                        .addGap(30, 30, 30)\n                        .addComponent(jbttnPause2))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(30, 30, 30)\n                        .addComponent(jbttnStart1)\n                        .addGap(30, 30, 30)\n                        .addComponent(jbttnPause1)))\n                .addContainerGap(25, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void jbttnStart1ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jbttnStart1ActionPerformed\n    {//GEN-HEADEREND:event_jbttnStart1ActionPerformed\n\n        // toggle the start button to stop\n        if (isBallStarted1) {\n            jbttnStart1.setText(\"Stop\");\n            addBall(jPanel1, 20, Ball.BallPath.BOUNCE, 10, 1, 1, 0);\n            balls[0].startBall();\n            isBallStarted1 = false;\n        } else {\n            jbttnStart1.setText(\"Start\");\n            balls[0].stopBall();\n            balls[0] = null;\n            jPanel1.removeAll();\n            jPanel1.repaint();\n\n            // reset the pause button\n            isBallStarted1 = true;\n            isBallPaused1 = true;\n            jbttnPause1.setText(\"Pause\");\n        }\n\n\n    }//GEN-LAST:event_jbttnStart1ActionPerformed\n\n    private void jbttnPause1ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jbttnPause1ActionPerformed\n    {//GEN-HEADEREND:event_jbttnPause1ActionPerformed\n\n        try {\n\n            if (isBallPaused1) {\n                jbttnPause1.setText(\"Resume\");\n                balls[0].pauseBall();\n                isBallPaused1 = false;\n            } else {\n                jbttnPause1.setText(\"Pause\");\n                balls[0].resumeBall();\n                isBallPaused1 = true;\n            }\n        } catch (Exception e) {\n            \n            // in production we would log the error\n        }\n\n    }//GEN-LAST:event_jbttnPause1ActionPerformed\n\n    private void jbttnStart2ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jbttnStart2ActionPerformed\n    {//GEN-HEADEREND:event_jbttnStart2ActionPerformed\n        \n        \n        // toggle the start button to stop\n        if (isBallStarted2) {\n            jbttnStart2.setText(\"Stop\");\n            addBall(jPanel2, 20, Ball.BallPath.HORIZONTAL_WAVE, 25, 1, 1, 1);\n            balls[1].startBall();\n            isBallStarted2 = false;\n        } else {\n            jbttnStart2.setText(\"Start\");\n            balls[1].stopBall();\n            balls[1] = null;\n            jPanel2.removeAll();\n            jPanel2.repaint();\n\n            // reset the pause button\n            isBallStarted2 = true;\n            isBallPaused2 = true;\n            jbttnPause2.setText(\"Pause\");\n        }\n        \n        \n\n\n    }//GEN-LAST:event_jbttnStart2ActionPerformed\n\n    private void jbttnPause2ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jbttnPause2ActionPerformed\n    {//GEN-HEADEREND:event_jbttnPause2ActionPerformed\n        try {\n\n            if (isBallPaused2) {\n                jbttnPause2.setText(\"Resume\");\n                balls[1].pauseBall();\n                isBallPaused2 = false;\n            } else {\n                jbttnPause2.setText(\"Pause\");\n                balls[1].resumeBall();\n                isBallPaused2 = true;\n            }\n        } catch (Exception e) {\n            \n            // in production we would log the error\n        }\n    }//GEN-LAST:event_jbttnPause2ActionPerformed\n\n    private void jbttnStart3ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jbttnStart3ActionPerformed\n    {//GEN-HEADEREND:event_jbttnStart3ActionPerformed\n        // toggle the start button to stop\n        if (isBallStarted3) {\n            jbttnStart3.setText(\"Stop\");\n            addBall(jPanel3, 20, Ball.BallPath.VERTICAL_WAVE, 40, 1, 1, 2);\n            balls[2].startBall();\n            isBallStarted3 = false;\n        } else {\n            jbttnStart3.setText(\"Start\");\n            balls[2].stopBall();\n            balls[2] = null;\n            jPanel3.removeAll();\n            jPanel3.repaint();\n\n            // reset the pause button\n            isBallStarted3 = true;\n            isBallPaused3 = true;\n            jbttnPause3.setText(\"Pause\");\n        }\n    }//GEN-LAST:event_jbttnStart3ActionPerformed\n\n    private void jbttnPause3ActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jbttnPause3ActionPerformed\n    {//GEN-HEADEREND:event_jbttnPause3ActionPerformed\n        try {\n\n            if (isBallPaused3) {\n                jbttnPause3.setText(\"Resume\");\n                balls[2].pauseBall();\n                isBallPaused3 = false;\n            } else {\n                jbttnPause3.setText(\"Pause\");\n                balls[2].resumeBall();\n                isBallPaused3 = true;\n            }\n        } catch (Exception e) {\n            \n            // in production we would log the error\n        }\n    }//GEN-LAST:event_jbttnPause3ActionPerformed\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String args[])\n    {\n        /* Set the Nimbus look and feel */\n        //<editor-fold defaultstate=\"collapsed\" desc=\" Look and feel setting code (optional) \">\n        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.\n         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html \n         */\n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"Nimbus\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(Frame1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        //</editor-fold>\n\n        /* Create and display the form */\n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run()\n            {\n                new Frame1().setVisible(true);\n            }\n        });\n    }\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JPanel jPanel2;\n    private javax.swing.JPanel jPanel3;\n    private javax.swing.JButton jbttnPause1;\n    private javax.swing.JButton jbttnPause2;\n    private javax.swing.JButton jbttnPause3;\n    private javax.swing.JButton jbttnStart1;\n    private javax.swing.JButton jbttnStart2;\n    private javax.swing.JButton jbttnStart3;\n    // End of variables declaration//GEN-END:variables\n}\n","type":"content","url":"/xthreadinga#frame1-java","position":7},{"hierarchy":{"lvl1":"Concurrency Fundamentals"},"type":"lvl1","url":"/xthreadsconcurrencyfundamentalsbrwithswing","position":0},{"hierarchy":{"lvl1":"Concurrency Fundamentals"},"content":"","type":"content","url":"/xthreadsconcurrencyfundamentalsbrwithswing","position":1},{"hierarchy":{"lvl1":"Concurrency Fundamentals","lvl2":"Threads, Synchronization, and Swing UI Threading"},"type":"lvl2","url":"/xthreadsconcurrencyfundamentalsbrwithswing#threads-synchronization-and-swing-ui-threading","position":2},{"hierarchy":{"lvl1":"Concurrency Fundamentals","lvl2":"Threads, Synchronization, and Swing UI Threading"},"content":"In Java, focusing on concurrency (doing multiple things at once) and how it relates to graphical user interfaces (GUIs) like Swing.\n\nImagine you’re working in a kitchen. You’re the main chef.\n\nRunnable - The Recipe\n\nWhat it is: Runnable is an interface in Java. An interface is like a contract – it defines what a class should be able to do, but not how. The Runnable interface has just one method you need to implement: run().\n\nAnalogy: Think of Runnable as a specific recipe or a set of instructions for a task (e.g., “chop vegetables,” “wash dishes”). The run() method contains the step-by-step instructions for that task.\n\nPurpose: It represents a unit of work, a task that can be executed. It doesn’t execute itself; it just defines the work.\n\nExample Skeleton:\n\nJavaclass ChopVegetablesTask implements Runnable {\n    @Override\n    public void run() {\n        // Code to chop vegetables goes here\n        System.out.println(\"Chopping carrots...\");\n        // ... more chopping steps ...\n        System.out.println(\"Vegetables chopped!\");\n    }\n}\n\nThread - The Kitchen Assistant\n\nWhat it is: A Thread is a class in Java. An object of the Thread class represents an actual, independent sequence of execution within your program. It’s the worker that can perform a task.\n\nAnalogy: If Runnable is the recipe, Thread is the kitchen assistant you hire to follow that recipe. You can have multiple assistants (threads) working on different recipes (Runnable tasks) simultaneously.\n\nHow it works with Runnable: You usually create a Thread object and give it a Runnable object (the recipe) to execute.\n\nKey Method: start() .  When you call start()  on a Thread object, it does two things:\n\nIt tells the Java Virtual Machine (JVM) that a new thread of execution should be created.\n\nIt eventually calls the run() method of the Runnable task you provided (or the Thread’s own run() method if you extended the Thread class directly, though implementing Runnable is generally preferred).\n\nImportant: You call start(), not run(). Calling run() directly just executes the code in the current thread, like a normal method call – no new assistant is hired!\n\nExample:\n\nJava// Get the recipe (Runnable task)\nRunnable choppingTask = new ChopVegetablesTask();\n\n// Hire an assistant (Thread) and give them the recipe\nThread assistant1 = new Thread(choppingTask);\n\n// Tell the assistant to start working!\nassistant1.start(); // This eventually calls choppingTask.run() in a new thread\n\n// The main chef (main thread) can continue doing other things...\nSystem.out.println(\"Main chef is checking the oven.\");\n\nWhy Use Multiple Threads?\n\nResponsiveness: Keep your application (especially GUIs) responsive. If a long task (like downloading a file) runs on the main thread, the UI might freeze. Running it on a separate thread keeps the UI alive.\n\nPerformance: On multi-core processors, different threads can run truly simultaneously on different cores, speeding up computation-intensive tasks.\n\nProblems with Multiple Threads: Sharing is Hard!\n\nWhen multiple threads (assistants) access and modify the same data (shared ingredients or utensils), things can go wrong.\n\nRace Conditions: The outcome depends on the unpredictable order in which threads execute. Imagine two assistants trying to update the same count of remaining potatoes. One reads “5”, the other reads “5”. Both calculate “4”, and both write “4”. You’ve lost a potato count!\n\nMemory Visibility: One thread might change data, but due to optimizations like CPU caching, other threads might not see that change immediately; they might still see the old, “stale” value.\n\nTools to Manage Shared Data:\n\nsynchronized - The Talking Stick / Exclusive Access\n\nWhat it is: A keyword used to control access to shared resources. It ensures that only one thread at a time can execute a specific block of code or method associated with a particular object’s lock (also called a monitor).\n\nAnalogy: Imagine a single “talking stick” for a specific resource (like the main recipe book). Only the assistant holding the stick can modify the recipe book. Any other assistant wanting to use it must wait until the first one releases the stick.\n\nHow it works:\n\nSynchronized Method: public synchronized void updateSharedCounter() { ... }. The lock is on the object (this) the method belongs to.\n\nSynchronized Block: synchronized(someObject) { ... }. The lock is on someObject. This is more flexible.\n\nPurpose: Prevents race conditions by enforcing mutual exclusion (only one thread in the critical section at a time). It also helps with memory visibility – changes made inside a synchronized block by one thread are guaranteed to be visible to another thread when it subsequently enters a synchronized block on the same lock.\n\nExample (Conceptual Counter):\n\nJavaclass SharedCounter {\n    private int count = 0;\n    private final Object lock = new Object(); // An object to use as a lock\n\n    public void increment() {\n        synchronized (lock) { // Only one thread can be inside this block at a time\n            count++;\n        }\n    }\n\n    public int getCount() {\n        synchronized (lock) { // Ensure reading the latest value\n            return count;\n        }\n    }\n}\n\nvolatile - The “Always Check the Master Copy” Rule\n\nWhat it is: A keyword applied to a variable. It primarily guarantees visibility.\n\nAnalogy: Imagine a central whiteboard (volatile variable) where an important status is written (e.g., “Stop Processing: true”). The volatile keyword tells every assistant (thread) that whenever they read this status, they must go look at the central whiteboard directly, not rely on their own potentially outdated notes (CPU cache). When they write to it, they must ensure the change is immediately visible on the central whiteboard.\n\nPurpose: Ensures that reads and writes to this specific variable happen directly to/from main memory, bypassing local CPU caches. It prevents threads from seeing stale values for that specific variable. It also prevents certain kinds of compiler instruction reordering related to that variable.\n\nLimitations: volatile guarantees visibility, but not atomicity for compound actions (like count++, which is really read-modify-write). It’s good for simple flags or status indicators read/written by multiple threads, but not sufficient for complex state changes or counters where the previous value matters for the update. Use synchronized or atomic classes (AtomicInteger, etc.) for those.\n\nExample:\n\nJavaclass Worker implements Runnable {\n    private volatile boolean stopRequested = false; // Ensure visibility\n\n    public void requestStop() {\n        stopRequested = true; // Write is made visible quickly\n    }\n\n    @Override\n    public void run() {\n        while (!stopRequested) { // Read checks the 'master copy'\n            // do work...\n        }\n        System.out.println(\"Worker stopping.\");\n    }\n}\n\nTools for Thread Coordination:\n\nSometimes threads need to coordinate more actively, waiting for a certain condition to become true.\n\nwait() and notify() (and notifyAll()) - The Pause/Resume Buttons\n\nWhat they are: Methods belonging to the base Object class (so every object has them). They allow threads to pause execution and wait for a condition, and allow other threads to signal that the condition might now be true.\n\nCrucial Rule: These methods MUST be called from within a synchronized block or method on the same object whose lock the thread currently holds.\n\nAnalogy:\n\nImagine a baker (producer thread) and a delivery person (consumer thread) sharing a bread shelf (shared resource).\n\nwait(): If the delivery person arrives and the shelf is empty, they acquire the lock on the shelf (enter a synchronized block), check the condition (shelf empty?), and then call shelf.wait(). This releases the lock on the shelf and puts the delivery person thread into a waiting state. They “pause.”\n\nnotify(): When the baker adds bread, they acquire the lock on the shelf (enter a synchronized block), add the bread, and then call shelf.notify(). This wakes up one arbitrarily chosen waiting thread (hopefully the delivery person). The awakened thread doesn’t run immediately – it must first re-acquire the lock on the shelf (which it can only do after the baker exits their synchronized block).\n\nnotifyAll(): Like notify(), but wakes up all threads waiting on that object’s lock. They all compete to re-acquire the lock when the notifying thread releases it.\n\nImportant Pattern: Because a thread might wake up even if the condition isn’t really met (spurious wakeups) or because another thread might have changed the condition after notify() but before the waiting thread re-acquires the lock, you MUST always check the condition in a while loop after waking up from wait().\n\nExample (Conceptual Shelf):\n\nJavaclass Shelf {\n    private boolean hasBread = false;\n    private final Object lock = new Object();\n\n    public void putBread() {\n        synchronized (lock) {\n            hasBread = true;\n            System.out.println(\"Baker added bread. Notifying...\");\n            lock.notify(); // Wake up one waiting thread (delivery person)\n        }\n    }\n\n    public void takeBread() throws InterruptedException {\n        synchronized (lock) {\n            // MUST use a while loop here!\n            while (!hasBread) {\n                System.out.println(\"Delivery person waiting for bread...\");\n                lock.wait(); // Release lock and wait\n                System.out.println(\"Delivery person woke up! Checking again...\");\n            }\n            // If we get here, hasBread is true and we hold the lock\n            hasBread = false;\n            System.out.println(\"Delivery person took the bread.\");\n        }\n    }\n}\n\nConcurrency in Swing GUIs:\n\nSwing (a Java GUI toolkit) has its own specific rule for threading:\n\nThe Event Dispatch Thread (EDT): Swing components (buttons, text fields, etc.) are not thread-safe. Almost all interaction with Swing components (creating them, updating them, reading their state) must happen on a single, special thread called the Event Dispatch Thread (EDT).\n\nWhy? This simplifies GUI programming immensely. If any thread could modify a button’s text at any time, you’d need complex locking everywhere, risking deadlocks and making GUI code very hard to write correctly. The EDT handles all user input events (button clicks, key presses) and painting requests in order.\n\nThe Problem: What if you have a long-running task (like downloading a file or a complex calculation) started by a button click? If you run that task directly on the EDT, your entire GUI will freeze until the task is done, because the EDT is busy and cannot process other events like repainting or responding to clicks.\n\nThe Solution: Perform long-running tasks on a separate worker thread (like the “assistants” we discussed using Thread and Runnable). BUT, when that worker thread needs to update the GUI (e.g., display download progress, show results), it cannot directly touch the Swing components.\n\nSwingUtilities.invokeLater() - The “Ask the UI Painter to Do This Later” Mechanism\n\nWhat it is: A static method in the SwingUtilities class.\n\nPurpose: To safely schedule a piece of code (wrapped in a Runnable) to be executed later on the EDT.\n\nHow it works: You create a Runnable containing the GUI update code. You pass this Runnable to SwingUtilities.invokeLater(). This method queues the Runnable and returns immediately. The EDT, when it’s finished with its current task, will pick up your Runnable from the queue and execute its run() method.\n\nAnalogy: The worker assistant (background thread) finishes calculating something. They can’t paint the result on the main canvas (the GUI) themselves. Instead, they write down the instructions (“update label with ‘Done!’”) on a note (Runnable) and hand it to a dispatcher (SwingUtilities.invokeLater). The dispatcher puts the note in the dedicated UI painter’s (EDT’s) inbox. When the painter has a moment, they’ll read the note and perform the update.\n\nExample:\n\nJavaimport javax.swing.*;\nimport java.awt.event.*;\n\npublic class SwingExample {\n    public static void main(String[] args) {\n        JFrame frame = new JFrame(\"Swing Threading\");\n        JButton button = new JButton(\"Start Long Task\");\n        JLabel label = new JLabel(\"Status: Idle\");\n\n        button.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                label.setText(\"Status: Working...\"); // OK, this is on EDT (button click handler)\n\n                // Create the task (recipe) for the long work\n                Runnable longTask = () -> {\n                    try {\n                        // Simulate long work (e.g., network call, calculation)\n                        Thread.sleep(3000); // Sleep for 3 seconds\n\n                        // **** WRONG WAY (don't do this!) ****\n                        // label.setText(\"Status: Done!\"); // Accessing GUI from wrong thread!\n\n                        // **** CORRECT WAY ****\n                        // Create a Runnable for the GUI update\n                        Runnable updateGuiTask = () -> {\n                            label.setText(\"Status: Done!\");\n                        };\n                        // Ask Swing to run this task on the EDT\n                        SwingUtilities.invokeLater(updateGuiTask);\n\n                    } catch (InterruptedException ex) {\n                        Thread.currentThread().interrupt(); // Restore interrupt status\n                        // Handle interruption - perhaps update GUI to show error (using invokeLater!)\n                        SwingUtilities.invokeLater(() -> label.setText(\"Status: Interrupted!\"));\n                    }\n                };\n\n                // Hire an assistant (Thread) and give them the recipe\n                Thread workerThread = new Thread(longTask);\n                workerThread.start(); // Start the work in the background\n            }\n        });\n\n        // Basic frame setup (simplified)\n        frame.setLayout(new java.awt.FlowLayout());\n        frame.add(button);\n        frame.add(label);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n\nSwingUtilities.invokeAndWait(): There’s also invokeAndWait(), which does the same thing but blocks the calling thread until the EDT has finished executing the Runnable. Use this carefully, as it can lead to deadlocks if the EDT is waiting for the blocked thread! invokeLater is generally safer and preferred for responsiveness.\n\nSummary:\n\nRunnable: Defines a task.\n\nThread: Executes a task concurrently.\n\nsynchronized: Controls access to shared resources (mutual exclusion + visibility).\n\nvolatile: Ensures visibility of a specific variable (reads/writes go to main memory).\n\nwait()/notify()/notifyAll(): Coordinate threads based on conditions (must be used with synchronized).\n\nSwing EDT: The single thread for all Swing GUI updates.\n\nSwingUtilities.invokeLater(): The safe way to schedule GUI updates onto the EDT from other threads.\n\nConcurrency is a powerful but complex topic. Understanding these fundamentals is crucial for writing correct, responsive, and efficient Java applications, especially those with GUIs or that perform background processing.","type":"content","url":"/xthreadsconcurrencyfundamentalsbrwithswing#threads-synchronization-and-swing-ui-threading","position":3},{"hierarchy":{"lvl1":"JAVA II"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"JAVA II"},"content":"This section focuses on building Graphical User Interfaces and advance programming techniques.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"JAVA II","lvl2":"History"},"type":"lvl2","url":"/#history","position":2},{"hierarchy":{"lvl1":"JAVA II","lvl2":"History"},"content":"Java’s origin story begins in the early 1990s at Sun Microsystems, where James Gosling and a small, stubbornly visionary team set out to design a language for consumer electronics—set-top boxes, smart appliances, things that were supposed to talk to each other before the rest of the world knew it needed that. The project, initially called Oak, emphasized safety, portability, and simplicity. When Oak ran headlong into trademark trouble and the rise of the internet, it was reborn as Java in 1995, pivoting brilliantly from appliances to the web just as browsers were becoming the new operating system.\n\nJava’s defining idea—write once, run anywhere—came from compiling code to platform-neutral bytecode executed by the Java Virtual Machine. This architectural choice made Java wildly attractive for web applets in the late 1990s and, more importantly, for enterprise systems that needed stability across heterogeneous hardware. Sun reinforced this momentum with a standard library that was unusually rich for its time, strong memory management via garbage collection, and a security model that didn’t assume programmers were saints.\n\nThrough the late 1990s and early 2000s, Java matured rapidly. Java 2 introduced a formal split between Standard, Enterprise, and Micro Editions (SE, EE, ME), signaling Java’s ambition to run everywhere from servers to phones. Enterprise Java became the backbone of large-scale business systems, sometimes elegant, sometimes baroque, but always present. After Oracle acquired Sun in 2010, Java’s stewardship shifted, raising eyebrows but also accelerating a more predictable release cadence. Modern Java, with features like lambdas, modules, and a six-month release cycle, has quietly evolved into a leaner, more expressive language—less ceremony, more intent.\n\nJava’s great trick is endurance. It never chased fashion; it outlasted it. From applets to Android, from monoliths to microservices, Java adapted without losing its core identity. In computing years, that’s not just survival—it’s quiet dominance.","type":"content","url":"/#history","position":3},{"hierarchy":{"lvl1":"JAVA II","lvl2":"Core Language Review"},"type":"lvl2","url":"/#core-language-review","position":4},{"hierarchy":{"lvl1":"JAVA II","lvl2":"Core Language Review"},"content":"This can be found here:\n\nLanguage Review Link\n\nJames Goudy\n\n© 2025\n\nJAVA II\n\nFirst Form\n\nLayout Managers\n\nDisplaying Text\n\nRadio Buttons\n\nMenus\n\nCombo boxes\n\nSlider and Progress Bar\n\nLetters vs Digits\n\nBuilding A String Using Combo, Lists, and Textfield\n\nBuilding Swing Controls Via Code\n\nGame Piece - Dynamically Adding Pieces to a Panel\n\nBounce Balls Animation\n\nBounce With Collision\n\nThreading\n\nConcurrency Fundamentals\n\nPictures and Sound\n\nAdd Image Using Image Icon Label\n\nJTable\n\nJAVA Automated Build Tools\n\nJava Ant: Build Automation\n\nJava Maven:  Build Automation\n\nJava Gradle: Build Automation","type":"content","url":"/#core-language-review","position":5}]}